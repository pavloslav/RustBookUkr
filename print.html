<!DOCTYPE HTML>
<html lang="uk" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Мова програмування Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Мова програмування Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Передмова</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Вступ</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Початок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Встановлення</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Привіт, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Програмування гри - відгадайки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Загальні концепції програмування</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Змінні та мутабельність</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Типи даних</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функції</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Коментарі</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управління потоком виконання</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Розуміння володіння</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Що таке володіння?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Посилання і позичання</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Тип даних слайс</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Використання структур для структурування пов'язаних даних</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Визначення і інстанціювання структур Struct</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Приклад програми, що використовує структури</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис методів</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Енуми і зіставлення з шаблоном</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Визначення енума</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкція управління match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконічний контроль виконання конструкцією if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Керування проєктами, що зростають, за допомогою пакетів, крейтів та модулів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакети та крейти</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Визначення модулів для управління областями видимості та приватністю</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Шлях для доступу до елементів у дереві модулів</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Підключення шляхів до області видимості за допомогою ключового слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Розподіл модулів на різні файли</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Звичайні колекції</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Зберігання списків значень у векторах</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Зберігання тексту у кодуванні UTF-8 у стрічках</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Зберігання ключів і пов'язаних значень у хешмапах</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обробка помилок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Невідновні Помилки із panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Помилки, що піддаються відновленню за допомогою Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! чи не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Узагальнені типи, трейти та лайфтайми</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Узагальнені типи даних</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейти: визначення загальної поведінки</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Перевірка коректності посилань за допомогою часів існування</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написання автоматизованих тестів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Як писати тести</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Контроль над запуском тестів</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Організація тестів</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проєкт з введенням/виведенням: створення програми командного рядка</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Приймання аргументів командного рядка</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Читання файлу</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторизація для покращення модульності та обробки помилок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Розробка Функціонала Бібліотеки із Test-Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Робота зі Змінними Середовища</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Написання Повідомлень Про Помилки в Standard Error Замість Стандартного Виводу</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функціональні можливості мови: Ітератори та Замикання</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замикання: Анонімні Функції що Захоплюють Своє Середовище</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обробка послідовностей елементів за допомогою ітераторів</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Покращуємо наш проєкт з введенням/виведенням</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Порівняння швидкодії: цикли проти ітераторів</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Більше про Cargo та Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Налаштування Збірок з Release Профілями</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публікація Крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Робочі Області Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Встановлення Двійкових Файлів з cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Розширення Cargo із Користувацькими Командами</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Розумні вказівники</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Використання Box&lt;T&gt; для вказування на значення в Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Використання розумних вказівників як звичайних посилань за допомогою трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Виконання коду при очищенні за допомогою трейту Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, розумний вказівник з лічильником посилань</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; і шаблон внутрішньої мутабельності</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Цикли посилань можуть призвести до витоку пам'яті</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Конкурентність без страху</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Використання потоків для одночасного запуску коду</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Використання обміну повідомленнями для передачі даних між потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Паралелізм із спільним станом</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Розширювана конкурентність із трейтами Sync і Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Об'єктно орієнтовані особливості Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики об'єктно орієнтованого програмування</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Використання трейтових об'єктів, які допускають значення різних типів</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реалізація патернів об'єктноорієнтованого програмування</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблони та Зіставлення Шаблонів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Усі Місця Можливого Використання Шаблонів</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Спростовуваність: Чи Може Шаблон Бути Невідповідним</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Синтаксис Шаблонів</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Просунутий функціонал</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезпечний Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Поглиблено про трейти</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Поглиблено про типи</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Поглиблено про функції та замикання</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макроси</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Останній проєкт: збірка багатопотокового вебсервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Збірка однопотокового вебсервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Перетворюємо наш однопотоковий сервер на багатопотоковий</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Плавне вимикання і очищення</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Додатки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - ключові слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - оператори та символи</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> С - вивідні трейти</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - корисні інструменти розробки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - видання</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - переклади цієї книжки</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - як робиться Rust і "щонічний Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Мова програмування Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Мова-програмування-rust"><a class="header" href="#Мова-програмування-rust">Мова програмування Rust</a></h1>
<p><em>автори Steve Klabnik та Carol Nichols, за допомогою спільноти Rust</em></p>
<p>У цій версії тексту припускається, що ви використовуєте Rust 1.65 (випущено 03 листопада 2022 року) або пізніший. Див. розділ <a href="ch01-01-installation.html">«Встановлення» Розділу 1</a>,<!-- ignore -->
щоб встановити або оновити Rust.</p>
<p>Книжка англійською у форматі HTML доступна онлайн за адресою <a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a> і офлайн з встановленим Rust за допомогою <code>rustup</code>; запустіть <code>rustup docs --book</code>, щоб відкрити.</p>
<p>Також є декілька створених спільнотою <a href="appendix-06-translation.html">перекладів</a>.</p>
<p>Цей текст англійською доступний в <a href="https://nostarch.com/rust-programming-language-2nd-edition">паперовому форматі та електронних книжках No Starch Press</a>.</p>
<blockquote>
<p><strong>🚨 Хочете більш інтерактивного навчального досвіду? Спробуйте іншу версію книжки Rust, що включає: завдання, підсвічування, візуалізації і більше</strong>: <a href="https://rust-book.cs.brown.edu">https://rust-book.cs.brown.edu</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Передмова"><a class="header" href="#Передмова">Передмова</a></h1>
<p>Це не завжди можна ясно побачити, та мова програмування Rust принципово задумувалася для <em>розширення можливостей</em>: неважливо, код якого типу ви зараз пишете, та Rust надає вам більше можливостей сягати далі і програмувати впевнено у більшій кількості сфер, ніж раніше.</p>
<p>Візьмемо, наприклад, роботу &quot;системного рівня&quot;, що має справу з низькорівневими деталями керування пам'яттю, представленням даних та конкурентністю. Традиційна ця галузь програмування розглядається як утаємничена, доступна лише небагатьом обраним, хто присвятив необхідну кількість років навчанню, щоб уникнути її сумнозвісних підводних каменів. І навіть ті, хто працює в ній, робить це з обережністю, інакше їхній код буде відкрито для експлойтів, збоїв і ушкоджень.</p>
<p>Rust пробиває ці бар'єри, усуваючи старі підводні камені і надаючи дружній, відшліфований набір інструментів, щоб допомогти вам у цьому шляху. Програмісти, яким треба &quot;зануритися&quot; у нижній рівень контролю, можуть зробити це за допомогою Rust, без прийняття традиційного ризику збоїв і дірок безпеки і без необхідності вивчати тонкощі мінливого набору інструментів. Навіть краще, ця мова розроблена, щоб природним чином привести вас до надійного коду, ефективного з точки зору швидкості та використання пам'яті.</p>
<p>Програмісти, які вже працюють з кодом низького рівня, можуть скористатися Rust для підвищення своїх амбіцій. Скажімо, додавання паралелізму в Rust є відносно малоризикованою операцією: компілятор виявить класичні помилки за вас. І ви можете провернути більш агресивні оптимізації на своєму коді з упевненістю, що ви не додасте випадково збої та вразливості.</p>
<p>Та Rust не обмежується низькорівневим програмуванням. Rust достатньо виразний та ергономічний, щоб зробити розробку застосунків командного рядка, вебсерверів і багатьох інших видів коду дуже приємною - ви знайдете прості приклади і того, й іншого далі в книжці. Робота з Rust дозволяє вам розбудовувати навички, що переходять з однієї сфери в іншу; ви можете вивчити Rust, написавши вебзастосунок, а потім застосувати ті ж навички вже до вашого Raspberry Pi.</p>
<p>Ця книжка повністю охоплює потенціал Rust для розширення можливостей його користувачів. Це дружній та доступний текст, покликаний допомогти вам підвищити рівень не лише вашого знання Rust, але також вашої рішучості та впевненості як програміста в цілому. Тож занурюйтеся, готуйтеся вчитися - і ласкаво просимо до спільноти Rust!</p>
<p>— Nicholas Matsakis and Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Вступ"><a class="header" href="#Вступ">Вступ</a></h1>
<blockquote>
<p>Примітка: Ця редакція книжки така ж сама, як <a href="https://nostarch.com/rust-programming-language-2nd-edition">Мова програмування Rust</a>, доступна у форматі друку та електронної книжки у <a href="https://nostarch.com/">No Starch Press</a>.</p>
</blockquote>
<p>Вітаємо вас у <em>Мові програмування Rust</em>, вступній книзі про Rust. Мова програмування Rust допоможе вам писати швидше та надійніше програмне забезпечення. Ергономіка високого рівня та контроль низького рівня часто є несумісними у дизайні мови програмування; Rust кидає виклик цій суперечності. Завдяки балансу потужних технічних можливостей та великого досвіду розробників Rust надає вам можливість контролювати деталі низького рівня (наприклад, використання пам’яті) без будь-яких клопотів, традиційно пов’язаних із таким контролем.</p>
<h2 id="Для-кого-призначений-rust"><a class="header" href="#Для-кого-призначений-rust">Для кого призначений Rust</a></h2>
<p>Rust ідеально підходить багатьом людям з різних причин. Розгляньмо кілька найважливіших груп.</p>
<h3 id="Команди-розробників"><a class="header" href="#Команди-розробників">Команди розробників</a></h3>
<p>Rust показав себе ефективним інструментом співпраці серед великих команд розробників з різним рівнем знання системного програмування. Низькорівневий код схильний до різних специфічних помилок, які в більшості інших мов програмування можна знайти лише завдяки глибокому тестуванню та ретельному перегляду коду досвідченими розробниками. У Rust компілятор виконує роль воротаря, відмовляючись компілювати код із цими невловними помилками, включно з помилками конкурентності. Працюючи разом із компілятором, команда може ефективніше витратити свій час, зосереджуючись на програмній логіці, а не на виловлюванні помилок.</p>
<p>Rust також привносить сучасні засоби розробники у світ системного програмування:</p>
<ul>
<li>Cargo, менеджер залежностей та інструмент побудови, включений у комплект, робить додавання, компіляцію та управління залежностями безболісним і послідовним в усій екосистемі Rust.</li>
<li>Інструмент форматування Rustfmt забезпечує єдиний стиль кодування у різних розробників.</li>
<li>Rust Language Server надає інтегрованому середовищу розробки (IDE) інтеграцію для завершення коду та вбудованих повідомлень про помилки.</li>
</ul>
<p>Використовуючи ці та інші інструменти в екосистемі Rust, розробники можуть бути такими продуктивними під час написання коду системного рівня.</p>
<h3 id="Студенти"><a class="header" href="#Студенти">Студенти</a></h3>
<p>Rust призначена для студентів та зацікавлених у вивченні системних концепцій. Використовуючи Rust, багато людей вивчили такі теми, як розробка операційних систем. Доброзичлива спільнота із задоволенням відповідає на питання студентів. Різними заходами, такими, як створення цієї книжки, команди Rust хочуть зробити системні концепції більш доступними для більшої кількості людей, особливо для програмістів-новачків.</p>
<h3 id="Компанії"><a class="header" href="#Компанії">Компанії</a></h3>
<p>Сотні компаній, великих і малих, використовують Rust у виробництві для багатьох різних завдань, таких як інструменти командного рядка, вебслужби, інструменти DevOps, вбудовані пристрої, аудіо- та відеоаналіз та перекодування, криптовалюти, біоінформатика, пошукові системи, застосунки &quot;Інтернету речей&quot;, машинне навчання та навіть суттєві частини веббраузера Firefox.</p>
<h3 id="Розробники-відкритого-коду"><a class="header" href="#Розробники-відкритого-коду">Розробники відкритого коду</a></h3>
<p>Rust - для людей, які хочуть розбудовувати мову програмування Rust, спільноту, інструменти розробника та бібліотеки. Ми дуже хотіли б, щоб ви внесли свій внесок у мову Rust.</p>
<h3 id="Люди-які-цінують-швидкість-і-стабільність"><a class="header" href="#Люди-які-цінують-швидкість-і-стабільність">Люди, які цінують швидкість і стабільність</a></h3>
<p>Rust призначений для людей, які вимагають від мови швидкості та стабільності. Під швидкістю ми маємо на увазі як швидкість, з якою код Rust може виконуватися, так і швидкість, з якою Rust дозволяє вам писати програми. Перевірки компілятора Rust забезпечують стабільність під час розширення функціонала та рефакторинга. Це відрізняється від крихкого застарілого коду мовами без цих перевірок, який розробники часто бояться змінювати. Прагнучи до абстракцій з нульовою вартістю, конструкцій вищого рівня, що компілюються в код нижчого рівня, так само швидкий, як і написаний вручну, Rust намагається зробити так, щоб безпечний код був швидким кодом.</p>
<p>Мова Rust сподівається підтримати й багатьох інших користувачів; тут згадані лише деякі з найбільш зацікавлених учасників. Загалом, найвищою метою Rust є усунення компромісів, на які програмісти йшли десятиліттями, забезпечуючи безпеку <em>та</em> продуктивність, швидкість <em>та</em> ергономічність. Спробуйте Rust і побачите, що його вибір вам підходить.</p>
<h2 id="Для-кого-призначена-ця-книга"><a class="header" href="#Для-кого-призначена-ця-книга">Для кого призначена ця книга</a></h2>
<p>Ця книга передбачає, що ви вже писали код іншою мовою програмування, але не робить жодних припущень щодо того, якою саме. Ми спробували зробити матеріал широко доступним для тих, хто має найрізноманітніший досвід програмування. Ми не витрачаємо багато часу на розмови про те, <em>що</em> таке програмування або як думати про нього. Якщо ви зовсім ще новачок у програмуванні, вам краще буде прочитати книгу, яка спеціально написана для вступу до програмування.</p>
<h2 id="Як-користуватися-цією-книгою"><a class="header" href="#Як-користуватися-цією-книгою">Як користуватися цією книгою</a></h2>
<p>Загалом ця книжка передбачає, що ви читатимете її послідовно з початку до кінця. Пізніші розділи спираються на концепції, роз'яснені у попередніх розділах, а початкові розділи можуть не надто заглиблюватися в деталі конкретної теми; ми зазвичай повертаємося до таких тем у наступних розділах.</p>
<p>У цій книзі ви знайдете два типи розділів: розділи про концепції та розділи про проєкти. У розділах про концепції ви дізнаєтесь про різні боки Rust. У розділах проєктів ми разом писатимемо невеликі програми, застосовуючи те, чому ви навчилися. Розділи 2, 12 та 20 - це розділи про проєкти; решта - це розділи про концепції.</p>
<p>Розділ 1 пояснює, як встановити Rust, як написати програму “Hello, world!” і як користуватися Cargo, менеджером пакунків і інструментом побудови Rust. Розділ 2 є практичним вступом до написання програми на Rust, де ви створите гру з відгадуванням чисел. Тут ми висвітлюємо концепції на високому рівні, а пізніші розділи нададуть додаткові подробиці. Якщо ви хочете одразу зануритися в мову, Розділ 2 дає добрий початок. Розділ 3 охоплює функціонал Rust, схожих на аналогічний в інших мовах програмування, а в Розділі 4 ви дізнаєтеся про систему володіння Rust. Якщо ви особливо скрупульозний учень і вважаєте за краще вивчити кожну деталь, перш ніж переходити до наступної, можливо, ви захочете пропустити Розділ 2 і перейти прямо до Розділу 3, повернувшись до Розділу 2, коли захочете застосувати вивчене у проєкті.</p>
<p>У Розділі 5 обговорюються структури та методи, а в Розділі 6 - енуми, вирази <code>match</code> та керівні конструкції <code>if let</code>. Структури та енуми використовуються для створення власних типів у Rust.</p>
<p>У Розділі 7 ви дізнаєтесь про систему модулів Rust та про правила доступу для організації вашого коду та його публічного програмного інтерфейсу (API). У Розділі 8 розглядаються деякі узагальнені структури даних - колекції, які надає стандартна бібліотека, такі як вектори, рядки та геш-таблиці. Розділ 9 досліджує філософію та техніки обробки помилок Rust.</p>
<p>Розділ 10 заглиблюється в узагальнене програмування, трейти та часи існування, що надає вам змогу визначати код, застосований до різних типів. У Розділі 11 йдеться про тестування, яке є необхідним для забезпечення правильної логіки вашої програми навіть за гарантій безпеки Rust. У Розділі 12 ми створимо власну реалізацію підмножини функціонала інструмента командного рядка <code>grep</code>, який шукає заданий текст у файлах. Для цього ми використаємо багато концепцій, обговорених у попередніх розділах.</p>
<p>Розділ 13 досліджує замикання та ітератори - особливості Rust, які походять з функціональних мов програмування. У Розділі 14 ми детальніше розглянемо Cargo і поговоримо про кращі практики спільного використання ваших бібліотек. Розділ 15 обговорює розумні вказівники, надані стандартною бібліотекою, та трейти, що забезпечують їхній функціонал.</p>
<p>У Розділі 16 ми розглянемо різні моделі конкурентного програмування та поговоримо про те, як Rust допомагає вам програмувати декілька потоків без остраху. У Розділі 17 розглядається порівняння ідіом Rust із об'єктноорієнтованими принципами програмування, які вам можуть бути знайомі.</p>
<p>Розділ 18 - це посібник зі шаблонів та зіставлення з шаблонами, які є потужними способами вираження ідей у ​​програмах Rust. Розділ 19 містить вінегрет із просунутих цікавих тем, включно з небезпечним Rust, макросами та різним про час існування, трейти, типи, функції та замикання.</p>
<p>In Chapter 20, we’ll complete a project in which we’ll implement a low-level multithreaded web server!</p>
<p>Нарешті, додатки містять корисну інформацію про мову у більш довідковому форматі. Додаток А охоплює ключові слова Rust, Додаток B охоплює оператори та символи Rust, Додаток C охоплює трейти, що їх можна успадковувати, надані стандартною бібліотекою, Додаток D охоплює деякі корисні інструменти розробки, а Додаток E пояснює видання Rust. У Додатку F ви можете знайти переклади книги, а в Додатку G ми висвітлюємо, як робиться Rust, і що таке нічний Rust.</p>
<p>Немає неправильного способу прочитати цю книгу: якщо ви хочете пропустити щось - вперед! Можливо, вам доведеться повернутися до попередніх розділів, якщо ви відчуєте, що заплуталися. Але робіть все, що вам підходить.</p>
<p><span id="ferris"></span></p>
<p>Важливою складовою у навчанні Rust є навчання читати повідомлення про помилки, які відображає компілятор: вони спрямовують вас до робочого коду. Відтак, ми наведемо багато прикладів, які не компілюються, разом із повідомленням про помилку, яке компілятор покаже вам у кожній ситуації. Знайте, що якщо ви введете та запустите випадковий приклад, він може не скомпілюватись! Не забудьте прочитати навколишній текст, щоб побачити, чи приклад, який ви намагаєтесь запустити, мав на меті помилку. Ferris також допоможе вам розрізнити код, що не має працювати:</p>
<div class="table-wrapper"><table><thead><tr><th>Ферріс</th><th>Значення</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ферріс зі знаком питання" /></td><td>Цей код не компілюється!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Ферріс розводить руками" /></td><td>Цей код призводить до паніки!</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ферріс з однією піднятою клешнею знизує плечима" /></td><td>Цей код не робить того, що від нього очікували.</td></tr>
</tbody></table>
</div>
<p>In most situations, we’ll lead you to the correct version of any code that doesn’t compile.</p>
<h2 id="Вихідний-код"><a class="header" href="#Вихідний-код">Вихідний код</a></h2>
<p>The source files from which this book is generated can be found on <a href="https://github.com/rust-lang/book/tree/main/src">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Починаємо"><a class="header" href="#Починаємо">Починаємо</a></h1>
<p>Почнемо вашу подорож по Rust! Вивчати треба багато, але кожна подорож десь починається. В цьому розділі ми розглянемо:</p>
<ul>
<li>Встановлення Rust на Linux, macOS та Windows</li>
<li>Написання програми, яка виводить <code>Hello, world!</code></li>
<li>Використання <code>cargo</code>, менеджера пакунків і системи збірки Rust</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Встановлення"><a class="header" href="#Встановлення">Встановлення</a></h2>
<p>Наш перший крок - встановити Rust. Ми завантажимо Rust за допомогою <code>rustup</code>, інструмента командного рядка для керування виданнями Rust і пов'язаних інструментів. Для завантаження вам знадобиться з'єднання з Інтернетом.</p>
<blockquote>
<p>Note: If you prefer not to use <code>rustup</code> for some reason, please see the <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">Other Rust Installation Methods page</a> for more options.</p>
</blockquote>
<p>Наступні кроки встановлять найостаннішу стабільну версію компілятора Rust. Принципи стабільності Rust гарантують, що всі приклади в цій книжці, які можна скомпілювати, будуть компілюватися в новіших версіях Rust. Повідомлення можуть незначно змінюватися від версії до версії, бо Rust часто покращує повідомлення і попередження про помилки. Іншими словами, будь-яка новіша стабільна версія Rust, яку ви встановите за цією інструкцією, має працювати відповідно до змісту цієї книжки.</p>
<blockquote>
<h3 id="Запис-у-командному-рядку"><a class="header" href="#Запис-у-командному-рядку">Запис у командному рядку</a></h3>
<p>У цьому розділі та надалі в книжці ми використовуватимемо команди термінала. Рядки, що треба вводити в термінал, починаються з <code>$</code>. Не треба вводити сам  символ <code>$</code>; це запрошення командного рядка, що лише позначає початок команди. Рядки, що не починаються з <code>$</code> зазвичай показують те, що виводить попередня команда. Приклади, специфічні для PowerShell, будуть починатися на <code>&gt;</code> замість <code>$</code>.</p>
</blockquote>
<h3 id="Встановлення-rustup-на-linux-або-macos"><a class="header" href="#Встановлення-rustup-на-linux-або-macos">Встановлення <code>rustup</code> на Linux або macOs</a></h3>
<p>Якщо ви користувач Linux або macOS, відкрийте термінал і введіть цю команду:</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Ця команда завантажить сценарій і почне встановлення інструменту <code>rustup</code>, що встановить останню стабільну версію Rust. Можливо, у вас запитають ваш пароль. Якщо встановлення буде успішним, з'явиться цей рядок:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Крім того, вам знадобиться якийсь <em>компонувальник (linker)</em>, тобто програма, яку Rust використовує, щоб об'єднати результати компіляції в один файл. Швидше за все, він уже встановлений. Якщо ви отримаєте повідомлення про помилки компонувальника, вам слід встановити компілятор C, який зазвичай включає компонувальник. Компілятор C також корисний, бо деякі поширені пакунки Rust залежать від коду на C і потребуватимуть компілятора C.</p>
<p>На macOS, ви можете отримати C компілятор, виконавши команду:</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>Користувачі Linux зазвичай мають встановлювати GCC або Clang, відповідно до документації свого дистрибутиву. Скажімо, якщо ви використовуєте Ubuntu, ви можете встановити пакунок <code>build-essential</code>.</p>
<h3 id="Встановлення-rustup-на-windows"><a class="header" href="#Встановлення-rustup-на-windows">Встановлення <code>rustup</code> на Windows</a></h3>
<p>На Windows, перейдіть до <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> і дотримуйтеся вказаних там інструкцій для встановлення Rust. У певний момент встановлення ви отримаєте повідомлення, що вам також знадобляться інструменти збірки MSVC для Visual Studio 2013 чи пізнішої.</p>
<p>Щоб отримати інструменти збірки, вам потрібно встановити <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio 2022</a>. На питання, які робочі завантаження потрібно встановити, вкажіть:</p>
<ul>
<li>“Desktop Development with C++”</li>
<li>SDK для Windows 10 чи 11</li>
<li>The English language pack component, along with any other language pack of your choosing</li>
</ul>
<p>Надалі книжка використовує команди, які працюють як у <em>cmd.exe</em>, так і в PowerShell. Якщо будуть відмінності, ми пояснимо, що робити.</p>
<h3 id="Вирішення-проблем"><a class="header" href="#Вирішення-проблем">Вирішення проблем</a></h3>
<p>Щоб перевірити, чи правильно встановлено Rust, відкрийте оболонку і введіть рядок:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>Ви маєте побачити номер версії, хеш коміту і дату коміту останньої стабільної версії, яку було випущено, в наступному форматі:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Якщо ви це бачите, Rust було успішно встановлено! Якщо ви не бачите цю інформацію, перевірте, чи є Rust у системній змінній <code>%PATH%</code>.</p>
<p>У Windows CMD наберіть:</p>
<pre><code class="language-console">&gt; echo %PATH%
</code></pre>
<p>У PowerShell наберіть:</p>
<pre><code class="language-powershell">&gt; echo $env:Path
</code></pre>
<p>У Linux і macOS наберіть:</p>
<pre><code class="language-console">$ echo $PATH
</code></pre>
<p>Якщо все правильно і Rust все ще не працює, можна звернутися по допомогу у кілька місць. Дізнайтеся, як зв'язатися з іншими растацеанцями (так ми себе називаємо, від англ. crustacean - &quot;ракоподібний&quot;) на <a href="https://www.rust-lang.org/community">сторінці спільноти</a>.</p>
<h3 id="Оновлення-та-видалення"><a class="header" href="#Оновлення-та-видалення">Оновлення та видалення</a></h3>
<p>Після встановлення Rust за допомогою <code>rustup</code> легко можна оновитися до нової версії після її виходу. З командної оболонки запустіть такий сценарій оновлення:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>To uninstall Rust and <code>rustup</code>, run the following uninstall script from your shell:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="Локальна-документація"><a class="header" href="#Локальна-документація">Локальна документація</a></h3>
<p>Установлений Rust також включає локальну копію документації, тож ви можете читати її в офлайні. Запустіть <code>rustup doc</code>, щоб відкрити локальну документацію у веббраузері.</p>
<p>Any time a type or function is provided by the standard library and you’re not sure what it does or how to use it, use the application programming interface (API) documentation to find out!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h2>
<p>Після встановлення Rust настав час написати першу програму цією мовою. Давно стало традицією при вивченні нової мови програмування писати маленьку програму, що виводить на екран текст <code>Hello, world!</code>, і ми не будемо відступати від цієї традиції.</p>
<blockquote>
<p>Примітка: ця книжка передбачає базове знайомство із командним рядком. Rust як така не висуває особливих вимог до редакторів, інструментів і розміщення коду, тому якщо вам зручніше використовувати інтегроване середовище розробки (IDE) замість командного рядка, можете користуватися вашим улюбленим IDE. Багато сучасних IDE певною мірою підтримують Rust; зверніться до документації IDE, щоб дізнатися більше. Останнім часом команда Rust зосередилася на підтримці IDE за допомогою <code>rust-analyzer</code>. Перегляньте <a href="appendix-04-useful-development-tools.html">Додаток D</a>,<!-- ignore --> для більш докладної інформації.</p>
</blockquote>
<h3 id="Створення-теки-проєкту"><a class="header" href="#Створення-теки-проєкту">Створення теки проєкту</a></h3>
<p>Для початку, створіть теку для розміщення вашого коду мовою Rust. Для Rust немає значення, де розміщено ваш код, але для вправ і проєктів у цій книжці ми рекомендуємо зробити теку <em>projects</em> у вашій домашній теці і тримати всі проєкти там.</p>
<p>Запустіть термінал і введіть такі команди, щоб створити теку <em>projects</em> та теку для проєкту “Hello, world!” усередині теки <em>projects</em>.</p>
<p>У Linux, macOS та PowerShell на Windows, введіть це:</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Для Windows CMD введіть це:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3 id="Написання-і-запуск-програми-на-rust"><a class="header" href="#Написання-і-запуск-програми-на-rust">Написання і запуск програми на Rust</a></h3>
<p>Тепер створіть новий вихідний файл і назвіть його <em>main.rs</em>. Файли Rust завжди закінчуються розширенням <em>.rs</em>. Якщо у назві файлу використовується більш ніж одне слово, домовлено для розділення використовувати підкреслення. Наприклад, можна назвати файл <em>hello_world.rs</em>, але не <em>helloworld.rs</em>.</p>
<p>Тепер відкрийте файл <em>main.rs</em>, який ви щойно створили, і наберіть код з Роздруку 1-1:</p>
<p><span class="filename">Файл: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">Блок коду 1-1: програма, що виводить <code>Hello, world!</code></span></p>
<p>Збережіть цей файл і поверніться до вікна термінала у теці <em>~/projects/hello_world</em>. На Linux або macOs наберіть такі команди, щоб скомпілювати та запустити файл:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>У Windows запустіть команду <code>.\main.exe</code> замість <code>./main</code>:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>Незалежно від вашої операційної системи, у терміналі буде виведено рядок <code>Hello, world!</code>. Якщо він не вивівся, зверніться до підрозділу <a href="ch01-01-installation.html#troubleshooting">Розв'язання проблем</a><!-- ignore --> розділу Встановлення, щоб дізнатися, як отримати допомогу.</p>
<p>Якщо вивелося <code>Hello, world!</code> - вітаємо! Ви щойно офіційно написали програму мовою Rust. Тобто ви стали Rust програмістом! Ласкаво просимо!</p>
<h3 id="Анатомія-програми-rust"><a class="header" href="#Анатомія-програми-rust">Анатомія програми Rust</a></h3>
<p>Розгляньмо програму “Hello, world!” по деталях. Ось перший шматок пазла:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Ці рядки визначають функцію, що зветься <code>main</code>. Функція <code>main</code> особлива: вона завжди є першим кодом, що запускається у кожній виконуваній програмі Rust. Перший рядок проголошує функцію з назвою <code>main</code> без параметрів і яка нічого не повертає. Якби були параметри, їхні імена треба було розмістити між дужками <code>()</code>.</p>
<p>Тіло функції обгорнуто у <code>{}</code>. Rust вимагає фігурних дужок навколо тіл усіх функцій. Вважається хорошим стилем розміщувати початкову дужку на тому ж рядку, що й проголошення функції, з відступом в один пробіл.</p>
<blockquote>
<p>Примітка: якщо ви бажаєте використовувати стандартний стиль у проєктах Rust, можете скористатися інструментом для автоматичного форматування, що зветься <code>rustfmt</code>, для форматування коду в цьому стилі (більше у <code>rustfmt</code> з <a href="appendix-04-useful-development-tools.html">Додатку D</a><!-- ignore -->). Команда Rust додала цей інструмент до стандартного набору програм Rust, на кшталт <code>rustc</code>, тобто він уже має бути встановленим на вашому комп'ютері!</p>
</blockquote>
<p>Тіло функції <code>main</code> містить такий код:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hello, world!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Цей рядок виконує всю роботу в цій маленькій програмі: виводить текст на екран. Тут треба зазначити чотири важливі деталі.</p>
<p>По-перше, у Rust заведено робити відступи в чотири пробіли, а не табуляцію.</p>
<p>По-друге, <code>println!</code> викликає макрос Rust. Якби він викликав функцію, то це виглядало б як <code>println</code> (без <code>!</code>). Ми поговоримо про макроси в Rust детальніше в Розділі 19. Поки що вам достатньо знати, що коли ви бачите <code>!</code>, це означає, що ви викликаєте макрос, а не звичайну функцію, і що макроси не завжди дотримуються тих самих правил, що функції.</p>
<p>По-третє, ви бачите стрічку <code>Hello, world!</code>. Ми передаємо цю стрічку як аргумент до <code>println!</code>, і вона виводиться на екран.</p>
<p>По-четверте, рядок завершується крапкою із комою (<code>;</code>), що позначає, що цей вираз завершено, і можна починати наступний. Більшість рядків в коді Rust завершується крапкою із комою.</p>
<h3 id="Компіляція-і-запуск---окремі-кроки"><a class="header" href="#Компіляція-і-запуск---окремі-кроки">Компіляція і запуск - окремі кроки</a></h3>
<p>Ви щойно запустили новостворену програму, тож дослідимо кожен крок у цьому процесі.</p>
<p>Перед запуском програми Rust необхідно її скомпілювати за допомогою компілятора Rust, набравши команду <code>rustc</code> і передавши їй ім'я вихідного файлу, отак:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>Якщо ви маєте досвід роботи з C чи C++, ви можете помітити, що це схоже на <code>gcc</code> чи <code>clang</code>. Після вдалої компіляції Rust створює двійковий виконуваний файл.</p>
<p>На Linux, macOs чи PowerShell на Windows можна побачити цей файл, ввівши команду <code>ls</code> у командній оболонці:</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>На Linux і macOs ви побачите два файли. У PowerShell на Windows ви побачите ті ж три файли, що й за допомогою CMD. У CMD на Windows ви побачите таке:</p>
<pre><code class="language-cmd">&gt; dir r /B %= опція /B означає показувати лише імена файлів =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Тут показано вихідний файл з розширенням <em>.rs</em>, виконуваний файл (<em>main.exe</em> на Windows, але просто <em>main</em> на інших платформах) і, на Windows, файл з інформацією для зневадження з розширенням <em>.pdb</em>. Тепер можна запустити <em>main</em> чи <em>main.exe</em>, ось так:</p>
<pre><code class="language-console">$ ./main  # чи .\main.exe у Windows
</code></pre>
<p>Якщо <em>main.rs</em> - це ваша програма &quot;Hello, world!&quot;, вона виведе <code>Hello, world!</code> у ваш термінал.</p>
<p>Якщо ви більше знайомі з динамічними мовами на кшталт Ruby, Python чи JavaScript, вам може бути незвичним, що компіляція і виконання програми - окремі кроки. Rust є <em>завчасно компільованою</em> мовою, тобто ви можете скомпілювати програму, передати виконуваний файл комусь іншому, і він зможе запустити її навіть якщо у нього не встановлено Rust. Якщо ви передаєте комусь файл <em>.rb</em>, <em>.py</em> чи <em>.js</em>, йому, натомість буде потрібна встановлена реалізація мови Ruby, Python чи Javascript (відповідно), але в тих мовах потрібна лише одна команда, щоб скомпілювати та запустити вашу програму. Всі переваги мови програмування мають свою ціну.</p>
<p>Проста компіляція за допомогою <code>rustc</code> годиться для простеньких програм, але зі зростанням вашого проєкту вам захочеться мати можливість керувати всіма параметрами і легко ділитися кодом. Наступний крок - інструмент Cargo, що допоможе вам писати програми Rust для реального світу.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Привіт-cargo"><a class="header" href="#Привіт-cargo">Привіт, Cargo!</a></h2>
<p>Cargo - це система побудови та пакетний менеджер Rust. Більшість растацеанців використовують цей інструмент для керування проєктами Rust, бо Cargo виконує багато задач, таких, як збірка коду, завантаження бібліотек, від яких залежить ваш код, та збірка цих бібліотек. (Бібліотеки, потрібні коду, звуться <em>залежностями</em>.)</p>
<p>Найпростіші програми Rust, як та, яку ми щойно написали, не мають жодних залежностей. Якби ми зібрали проєкт &quot;Hello world&quot; за допомогою Cargo, то скористалися б тільки тією частиною Cargo, що відповідає за збірку коду. Коли ж ви писатимете складніші програми Rust, то додаватимете залежності, і якщо почнете проєкт за допомогою Cargo, додавати залежності буде значно легше.</p>
<p>Оскільки переважна більшість проєктів Rust використовують Cargo, надалі в книзі вважатиметься, що ви теж використовуєте Cargo. Cargo встановлюється з Rust, якщо ви скористалися офіційним встановлювачем, як сказано в підрозділі <a href="ch01-01-installation.html#installation">Встановлення</a><!-- ignore --> . Якщо ви встановили Rust у інший спосіб, перевірте, чи встановлений Cargo, ввівши це у свій термінал:</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>Якщо ви побачите номер версії, то Cargo встановлений! Але якщо ви бачите помилку на кшталт <code>не знайдено команду</code>, зверніться до документації по вашому методу встановлення, щоб визначити, як окремо встановити Cargo.</p>
<h3 id="Створення-проєкту-за-допомогою-cargo"><a class="header" href="#Створення-проєкту-за-допомогою-cargo">Створення проєкту за допомогою Cargo</a></h3>
<p>Створімо новий проєкт за допомогою Cargo і подивімося, як він відрізняється від нашого початкового проєкту Hello World. Поверніться до вашої теки <em>projects</em> (чи іншої, де ви зберегли ваш код) і введіть команди (незалежно від системи):</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>Перша команда створює нову теку і проєкт, що зветься <em>hello_cargo</em>. Ми назвали наш проєкт <em>hello_cargo</em>, і Cargo створює свої файли у теці з такою назвою.</p>
<p>Перейдіть до теки <em>hello_cargo</em> і перегляньте файли. Ви побачите, що Cargo створив два файли і одну теку: <em>Cargo.toml</em> і теку <em>src</em> із файлом <em>main.rs</em>.</p>
<p>Також він розпочав новий репозиторій Git, додавши файл <em>.gitignore</em>. Файли Git не будуть створені, якщо ви запустите <code>cargo new</code> в уже створеному репозиторії Git; ви можете змінити цю поведінку за допомогою <code>cargo new --vcs=git</code>.</p>
<blockquote>
<p>Примітка: Git - це поширена система контролю версій. Ви можете сказати <code>cargo new</code> використовувати іншу систему контролю версій чи не  використовувати жодної за допомогою прапорця <code>--vcs</code>. Запустіть <code>cargo new --help</code>, щоб побачити можливі варіанти.</p>
</blockquote>
<p>Відкрийте файл <em>Cargo.toml</em> у будь-якому текстовому редакторі. Він має виглядати десь так, як показано у Роздруку 1-2.</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p><span class="caption">Блок коду 1-2: Вміст файлу <em>Cargo.toml</em>, створеного командою <code>cargo new</code></span></p>
<p>Це файл у форматі <a href="https://toml.io"><em>TOML</em></a><!-- ignore --> (<em>Tom’s Obvious, Minimal Language</em> - &quot;Томова очевидна мінімальна мова&quot;), який Cargo використовує як формат для конфігурації.</p>
<p>Перший рядок, <code>[package]</code> (пакет) - це заголовок розділу, що показує, що наступні інструкції стосуються конфігурації пакета. Коли ми додамо більше інформації до цього файлу, ми додамо й інші розділи.</p>
<p>Наступні три рядки встановлюють конфігураційну інформацію, потрібну Cargo для компілювання вашої програми: ім'я, версію і яке видання Rust використовувати. Про ключ <code>edition</code> (видання) детальніше розповідається в <a href="appendix-05-editions.html">Додатку E</a><!-- ignore -->.</p>
<p>Останній рядок, <code>[dependencies]</code>, розпочинає розділ, де можна вказувати залежності вашого проєкту. Пакети з кодом в Rust звуться <em>крейтами</em> (&lt;0&gt;crate&lt;/0&gt;). Нам не потрібні інші крейти для цього проєкту, але вони знадобляться для першого проєкту у Розділі 2, і тоді ми скористаємося цим розділом.</p>
<p>Тепер відкрийте файл <em>src/main.rs</em> і подивіться на його вміст:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo створив для вас “Hello World!”, точно такий, який ми написали в Роздруку 1-1! Поки що відмінності між нашим попереднім проєктом та згенерованим Cargo полягає в тому, що Cargo розмістив код у теці <em>src</em> і додав конфігураційний файл <em>Cargo.toml</em> в основній теці.</p>
<p>Cargo очікує, що вихідні файли будуть розташовані в теці <em>src</em>, а основна тека міститиме лише README, ліцензійну інформацію, конфігураційні файли і все таке, що не стосується вашого коду. Використання Cargo допомагає організувати ваші проєкт. Все має своє місце, і все лежить на своїх місцях.</p>
<p>Якщо ви почали проєкт, що не використовує Cargo, як було із нашим проєктом “Hello, world!” , його можна перетворити на проєкт із підтримкою Cargo, перемістивши код до теки <em>src</em> і створивши відповідний файл <em>Cargo.toml</em>.</p>
<h3 id="Побудова-і-запуск-проєкту-cargo"><a class="header" href="#Побудова-і-запуск-проєкту-cargo">Побудова і запуск проєкту Cargo</a></h3>
<p>Погляньмо, як відрізняється збірка і запуск програми “Hello, world!” за допомогою Cargo. Зберіть проєкт такими командами з теки <em>hello_cargo</em>:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Ця команда створить виконанний файл <em>target/debug/hello_cargo</em> (чи <em>target\debug\hello_cargo.exe</em> на Windows), а не в поточній теці. Оскільки усталена збірка - дебажна, Cargo розміщує двійковий файл у теці, що зветься <em>debug</em>. Виконуваний файл можна запустити такою командою:</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # чи .\target\debug\hello_cargo.exe на Windows
Hello, world!
</code></pre>
<p>Якщо все пройшло добре, в термінал виведеться <code>Hello, world!</code>. Запуск <code>cargo build</code> уперше також призводить до створення Cargo нового файлу в теці верхнього рівня: <em>Cargo.lock</em>. Цей файл відстежує конкретні версії залежностей вашого проєкту. Цей проєкт не має залежностей, тому файл дещо порожній. Вам не треба нічого самостійно змінювати у цьому файлі, його вмістом займається Cargo.</p>
<p>Ми щойно зібрали проєкт за допомогою <code>cargo build</code> і запустили його за допомогою <code>. target/debug/hello_cargo</code>, але ми також можемо використати <code>cargo run</code>, щоб скомпілювати код, а потім запустити отриманий виконуваний файл однією командою:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Використання <code>cargo run</code> зручніше, ніж запам'ятовувати виконати <code>cargo build</code>, а потім писати весь шлях до двійкового файлу, тому більшість розробників використовують <code>cargo run</code>.</p>
<p>Зверніть увагу, що цього разу ми не побачили повідомлення про те, що Cargo компілює <code>hello_cargo</code>. Cargo зрозумів, що файли не змінилися, тому не перезібрав, а просто запустив двійковий файл. Якби ви змінили вихідний код, Cargo б довелося перебудувати проєкт перед виконанням, і ви б побачили такий вивід:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Крім того, Cargo має команду <code>cargo check</code>. Ця команда швидко перевіряє ваш код, щоб переконатися, що він компілюється, але не створює виконанного файлу:</p>
<pre><code class="language-console">$ cargo check
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>Чому виконуваний файл може бути непотрібним? <code>cargo check</code> зазвичай працює значно швидше за <code>cargo build</code>, бо пропускає створення виконанного файлу. Якщо ви постійно перевіряєте свій код під час його написання, використання <code>cargo check</code> дозволить вам швидше дізнатися, чи ваш проєкт все ще компілюється! Ось чому багато растацеанців запускають <code>cargo  check</code> час від часу поки пишуть програму, щоб переконатися, що вона компілюються, а потім запускають <code>cargo build</code>, коли готові працювати з виконуваним файлом.</p>
<p>Підіб'ємо підсумок, що ж ми дізналися про Cargo:</p>
<ul>
<li>Ми можемо створити проєкт за допомогою <code>cargo new</code>.</li>
<li>Ми можемо зібрати проєкт за допомогою <code>cargo build</code>.</li>
<li>Ми можемо зібрати і запустити проєкт в одну дію за допомогою <code>cargo run</code>.</li>
<li>Ми можемо зібрати проєкт без створення двійкового файлу для пошуку помилок за допомогою <code>cargo check</code>.</li>
<li>Cargo зберігає результат збірки не в одній теці з кодом, а в теці <em>target/debug</em>.</li>
</ul>
<p>Додаткова перевага використання Cargo полягає в тому, що його команди однакові незалежно від операційної системи, в якій ви працюєте. Тому з цього моменту ми більше не надаватимемо окремих команд для Linux, macOS чи Windows.</p>
<h3 id="Збірка-для-релізу"><a class="header" href="#Збірка-для-релізу">Збірка для релізу</a></h3>
<p>Коли ваш проєкт нарешті готовий для релізу, ви можете запустити <code>cargo build --release</code>, щоб скомпілювати його з оптимізаціями. Ця команда створить виконуваний файл у теці <em>target/release</em> замість <em>target/debug</em>. Ці оптимізації дозволяють коду Rust працювати швидше, але подовжують час, потрібний для компіляції програми. Ось чому є два різні профілі: один для розробки, щоб можна було перебудовувати часто і швидко, і другий для збірки фінальної програми, яку можна дати користувачеві, яку не треба часто перебудовувати і яка буде виконуватися якомога швидше. Якщо ви робите бенчмарк вашого коду, запускайте <code>cargo build  --release</code> і робіть бенчмарк виконуваного файлу у <em>target/release</em>.</p>
<h3 id="cargo-як-загальна-домовленість"><a class="header" href="#cargo-як-загальна-домовленість">Cargo як загальна домовленість</a></h3>
<p>У простих проєктах Cargo надає ненабагато більше можливостей за <code>rustc</code>, але в подальшому він виявить свою цінність, коли ваші програми стануть складнішими. Щойно програми доростають до декількох файлів чи потребують залежності, набагато простіше дозволити Cargo координувати збірку.</p>
<p>Хоча проєкт <code>hello_cargo</code> і нескладний, тепер він використовує багато інструментів, якими ви будете користуватися решту вашої кар'єри з Rust. Фактично, щоб працювати із будь-яким існуючим проєктом ви можете скористатися цими командами, щоб завантажити код за допомогою Git, перейти до теки проєкту і зібрати його:</p>
<pre><code class="language-console">$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>Для отримання додаткової інформації про Cargo перегляньте <a href="https://doc.rust-lang.org/cargo/">документацію</a>.</p>
<h2 id="Підсумок"><a class="header" href="#Підсумок">Підсумок</a></h2>
<p>Це був непоганий початок вашої подорожі по Rust! У цьому розділі ви навчилися:</p>
<ul>
<li>Встановлювати останню стабільну версію Rust за допомогою <code>rustup</code></li>
<li>Оновлюватися до нової версії Rust</li>
<li>Відкривати локально встановлену документацію</li>
<li>Писати і запускати програму “Hello, world!” за допомогою <code>rustc</code> безпосередньо</li>
<li>Створювати і запускати новий проєкт за допомогою домовленостей Cargo</li>
</ul>
<p>Настав час побудувати більш змістовну програму, щоб призвичаїтися до читання та написання коду Rust. У Розділі 2 ми створимо програму для відгадування числа. Якщо ви натомість бажаєте почати з вивчення, як загальні концепції програмування працюють в Rust, переходьте до Розділу 3, а потім поверніться до Розділу 2.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Програмування-гри---відгадайки"><a class="header" href="#Програмування-гри---відгадайки">Програмування гри - відгадайки</a></h1>
<p>Розпочнемо вивчення Rust зі спільної розробки проєкту! Цей розділ ознайомить вас із кількома поширеними концепціями Rust, демонструючи як вони використовуються у реальній програмі. Ви дізнаєтеся про <code>let</code>, <code>match</code>, методи, асоційовані функції, використання зовнішніх крейтів і навіть більше! Наступні розділи розкриють ці концепції детальніше. У цьому розділі ви займатиметеся основами.</p>
<p>Ми розв'язуватимемо класичну задачу для програмістів-початківців: гру &quot;відгадай число&quot;. Умови такі: програма генерує випадкове ціле число між 1 та 100. Потім пропонує гравцю ввести спробу відгадати. Після введення спроби вона скаже, чи число більше або менше за загадане. Якщо відгадано правильно, гра виведе привітання і припинить роботу.</p>
<h2 id="Початок-нового-проєкту"><a class="header" href="#Початок-нового-проєкту">Початок нового проєкту</a></h2>
<p>Щоб розпочати новий проєкт, перейдіть до теки <em>projects</em>, яку ви створили у Розділі 1, і створіть новий проєкт за допомогою Cargo, ось так:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>Перша команда, <code>cargo new</code>, приймає першим параметром ім'я проєкту (<code>guessing_game</code>). Друга команда переходить до теки нового проєкту.</p>
<p>Перегляньмо щойно створений файл <em>Cargo.toml</em>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>Як ви вже бачили у Розділі 1, <code>cargo new</code> створює програму &quot;Hello, world!&quot;. Подивімося, що міститься у файлі <em>src/main.rs</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Скомпілюймо цю програму “Hello, world!” і запустимо її за один крок за допомогою команди <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>Команда <code>run</code> стає в пригоді, коли треба швидко розвивати проєкт, і ця гра є якраз таким проєктом: ми хочемо швидко тестувати кожну ітерацію перед тим, як переходити до наступної.</p>
<p>Відкрийте файл <em>src/main.rs</em>. Увесь код ми писатимемо у цьому файлі.</p>
<h2 id="Обробляємо-здогадку"><a class="header" href="#Обробляємо-здогадку">Обробляємо здогадку</a></h2>
<p>Перша частина програми буде просити у користувача ввести здогадку, обробляти те, що він увів, і перевіряти, чи ввів він дані у потрібній формі. Для початку, дозволимо користувачеві ввести здогадку. Введіть код з Блоку коду 2-1 до <em>src/main.rs</em>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {guess}&quot;);
}
</code></pre>
<p><span class="caption">Блок коду 2-1: Код, що отримує здогадку у користувача і виводить її</span></p>
<p>Цей код містить багато інформації, тому розбиратимемо його рядок за рядком. Щоб отримати, що ввів користувач, і вивести результат, нам треба ввести бібліотеку введення/виведення <code>io</code> в область видимості. Бібліотека <code>io</code> входить до стандартної бібліотеки, що зветься <code>std</code>:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>За замовчуванням Rust має набір елементів, визначених у стандартній бібліотеці, що їх він вводить до області видимості будь-якої програми. Цей набір зветься <em>прелюдією</em>, і ви можете побачити все, що в ній міститься, <a href="../std/prelude/index.html">в документації стандартної бібліотеки</a>.</p>
<p>Якщо типу, який ви хочете використати, нема у прелюдії, вам доведеться явно вносити цей тип у область видимості за допомогою інструкції <code>use</code>. Використання бібліотеки <code>std::io</code> надає вам ряд корисних особливостей, включно з можливістю користувацького вводу.</p>
<p>Як ви вже бачили у Розділі 1, функція <code>main</code> є точкою входу у програму:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Синтаксична конструкція <code>fn</code> проголошує нову функцію, <code>()</code> показує, що вона не має параметрів, і фігурна дужка <code>{</code> починає тіло функції.</p>
<p>Як ви вже дізналися з того ж Розділу 1, <code>println!</code> - це макрос, що виводить стрічку на екран:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Цей код виводить повідомлення, що це за гра і запитує введення у користувача.</p>
<h3 id="Зберігання-значень-у-змінних"><a class="header" href="#Зберігання-значень-у-змінних">Зберігання значень у змінних</a></h3>
<p>Тепер створімо <em>змінну</em> для зберігання того, що користувач увів, ось так:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Тепер програма стає цікавішою! В цьому коротенькому рядку відбувається багато всього. Ми використовуємо інструкцію <code>let</code>, щоб створити змінну. Ось інший приклад:</p>
<pre><code class="language-rust ignore">let apples = 5;
</code></pre>
<p>Цей рядок створює нову змінну з назвою <code>apples</code> і зв'язує її зі значенням 5. У Rust змінні є немутабельними за замовчанням, тобто щойно ми надамо змінній значення, воно не зміниться. Детально ця концепція обговорюється в підрозділі <a href="ch03-01-variables-and-mutability.html#variables-and-mutability">&quot;Змінні та мутабельність&quot;</a><!-- ignore -->
Розділу 3. Щоб зробити змінну мутабельною, слід додати <code>mut</code> перед її іменем:</p>
<pre><code class="language-rust ignore">let apples = 5; // немутабельна
let mut bananas = 5; // мутабельна
</code></pre>
<blockquote>
<p>Примітка: синтаксична конструкція <code>//</code> починає коментар, що продовжується до кінця рядка. Rust ігнорує весь вміст коментаря. Про коментарі детальніше йдеться в <a href="ch03-04-comments.html">Розділі 3</a><!-- ignore -->.</p>
</blockquote>
<p>Повернімося до нашої ігрової програми - відгадайки. Тепер ви знаєте, що <code>let  mut guess</code> створить мутабельну змінну на ім'я <code>guess</code>. Знак рівності (<code>=</code>) каже Rust, що тепер ми хочемо зв'язати щось зі змінною. З правого боку знаку рівності знаходиться значення, з яким зв'язується <code>guess</code>, а саме результат виклику <code>String::new</code>, функції, що повертає новий екземпляр стрічки <code>String</code>. <a href="../std/string/struct.String.html"><code>String</code></a><!-- ignore --> <code>String</code> - це тип стрічки, що надається стандартною бібліотекою; це кодовані в UTF-8 шматки тексту, які можна нарощувати.</p>
<p>Синаксична конструкція <code>::</code> в рядку <code>::new`</code>позначає, що <code>new</code> - це асоційована функція типу <code>String</code>. <em>Асоційована функція</em> є реалізованою для типу, в цьому випадку <code>String</code>. Ця функція <code>new</code> створює нову, порожню <code>String</code>. Функція <code>new</code> зустрінеться вам у багатьох типах, оскільки це звичайна назва функції, що створює нове значення певного виду.</p>
<p>В цілому: рядок <code>let mut guess = String::new();</code> створив мутабельну змінну, що зараз зв'язана з новим, порожнім екземпляром <code>String</code>. Хух!</p>
<h3 id="Отримання-введення-від-користувача"><a class="header" href="#Отримання-введення-від-користувача">Отримання введення від користувача</a></h3>
<p>Згадаймо, що ми додали функціональність введення/виведення зі стандартної бібліотеки за допомогою <code>use std::io;</code> у першому рядку програми. Тепер викличмо функцію <code>stdin</code> з модуля <code>io</code>, що дозволить обробляти те, що вводить користувач:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Якби ми не імпортували бібліотеку <code>io</code> за допомогою <code>use std::io</code> на початку програми, ми могли б використати цю функцію, написавши цей виклик як <code>std::io::stdin</code>. Функциія <code>stdin</code> повертає екземпляр <a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->; цей тип являє собою дескриптор (handle) стандартного потоку введення термінала.</p>
<p>Далі рядок <code>.read_line(&amp;mut guess)</code> викликає метод <a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!--
ignore --> дескриптора стандартного введення, щоб отримати, що ввів користувач. Ми також передаємо </p>
<p><code>&amp;mut guess</code> аргументом до <code>read_line</code>, щоб повідомити йому, до якої стрічки зберегти введення користувача. Повне завдання <code>read_line</code> - взяти те, що користувач набрав у стандартний потік введення і додати до стрічки (не перезаписавши її вміст), тому ми передаємо стрічку як аргумент. Стрічка-аргумент має бути мутабельною, щоб метод міг змінити її вміст.</p>
<p><code>&amp;</code> позначає, що цей аргумент - <em>посилання</em>, що дає вам можливість надати кільком частинам вашого коду доступ до одного фрагменту даних без кількаразового копіювання цих даних у пам'яті. Посилання - складна тема, але одна з основних переваг Rust полягає в безпеці та легкості використання посилань. Для завершення цієї програми вам не знадобляться особливо детальні знання про посилання. Поки що все, що вам треба знати - що посилання, як і зміні, типово є немутабельними. Тому необхідно писати<code>&amp;mut guess</code>, а не просто<code>&amp;guess</code>, щоб зробити його мутабельним. (Розділ 4 пояснить посилання ретельніше.)</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="Керування-потенційною-невдачею-за-допомогою-result"><a class="header" href="#Керування-потенційною-невдачею-за-допомогою-result">Керування потенційною невдачею за допомогою <code>Result</code></a></h3>
<p>Ми ще не закінчили розбиратися із цим рядком коду. Хоча ми обговорюємо третій рядок тексту, це все ще частина єдиного логічного рядка коду. Наступна частина - це ось цей метод:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect(&quot;Failed to read line&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Ми могли б написати цей код ось так:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
</code></pre>
<p>Однак один довгий рядок важко читати, тому краще його розділити. Коли ви викликаєте метод за допомогою синтаксичної конструкції <code>.method_name()</code> часто має сенс розпочати новий рядок і додати відступи, щоб розділити довгі рядки. Тепер розглянемо, що цей рядок робить.</p>
<p>Як уже було сказано, <code>read_line</code> додає те, що ввів користувач, у стрічку, яку ми передали як аргумент, але також повертає значення <code>Result</code>. <a href="../std/result/enum.Result.html"><code>Result</code></a><!--
ignore --> Тип <code>Result</code> - це </p>
<p><a href="ch06-00-enums.html"><em>перелік (enumeration)</em></a><!-- ignore -->, який часто звуть просто <em>енум</em>, і цей тип може перебувати в одному з кількох можливих станів. Кожен такий стан зветься <em>варіантом</em>.</p>
<p><a href="ch06-00-enums.html">Розділ 6</a><!-- ignore --> розповість про енуми детальніше. Призначення типів <code>Result</code> - представлення інформації для обробки помилок.</p>
<p><code>Result</code> має варіанти <code>Ok</code> та <code>Err</code>. Варіант <code>Ok</code> показує, що операція була вдалою, і всередині варіанту <code>Ok</code> знаходиться успішно згенероване значення. Варіант <code>Err</code> позначає невдачу, і містить інформацію, як і чому операція була невдалою.</p>
<p>Значення типу <code>Result</code>, як і значення будь-якого іншого типу, мають визначені для них методи. Екземпляр <code>Result</code> має доступний для виклику <a href="../std/result/enum.Result.html#method.expect">метод <code>expect</code></a><!-- ignore -->
. Якщо цей екземпляр <code>Result</code> має значення <code>Err</code>, то <code>expect</code> викличе аварійне завершення програми та виведе повідомлення, яке ви передали до <code>expect</code> параметром. Якщо метод <code>read_line</code> поверне <code>Err</code>, це, швидше за все, станеться внаслідок помилки, яка станеться в операційній системі. Якщо цей екземпляр <code>Result</code> має значення <code>Ok</code>, <code>expect</code> візьме повернуте значення, яке знаходиться в <code>Ok</code>, і поверне тільки це значення, щоб ним можна було скористатися. В цьому випадку це значення - кількість байтів, введених користувачем до стандартного потоку.</p>
<p>Якщо ви не викличете <code>expect</code>, програма скомпілюється, проте ви отримаєте попередження:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `guessing_game` (bin &quot;guessing_game&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust попереджає, що ви не використали значення <code>Result</code>, повернуте з <code>read_line</code>, що означає, що програма не обробляє можливу помилку.</p>
<p>Правильний спосіб пригнітити попередження - власне, обробити помилку, але оскільки ми в цьому випадку просто хочемо, щоб програма аварійно завершилася, якщо виникне проблема, то можемо скористатися <code>expect</code>. Ви дізнаєтеся про те, як відновити роботу програми при помилці, у <a href="ch09-02-recoverable-errors-with-result.html">Розділі 9</a><!-- ignore -->.</p>
<h3 id="Вивід-значень-за-допомогою-заповнювачів-println"><a class="header" href="#Вивід-значень-за-допомогою-заповнювачів-println">Вивід значень за допомогою заповнювачів <code>println!</code></a></h3>
<p>Якщо не враховувати завершувальної фігурної дужки, лишився лише один рядок, який ми ще не обговорили:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>    println!(&quot;You guessed: {guess}&quot;);
<span class="boring">}
</span></code></pre>
<p>Цей рядок виводить стрічку, в якій ми зберегли те, що ввів користувач. Фігурні дужки <code>{}</code> - це заповнювач: можна уявити, що <code>{}</code> - клешні маленького краба, що тримає значення на місці. При виведенні значення змінної, назву змінної можна розмістити у фігурних дужках. При виведенні результату обчислення виразу розмістіть порожні фігурні дужки у форматній стрічці, а потім додайте за форматною стрічкою список, розділений комами, виразів, які треба вивести у кожному порожньому заповнювачі з фігурних дужок у тому самому порядку. Виведення змінної і результату обчислення виразу в одному виклику <code>println!</code> виглядатиме так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {x} and y + 2 = {}&quot;, y + 2);
<span class="boring">}
</span></code></pre></pre>
<p>Цей код виведе <code>x = 5 and y + 2 = 12</code>.</p>
<h3 id="Тестування-першої-частини"><a class="header" href="#Тестування-першої-частини">Тестування першої частини</a></h3>
<p>Протестуймо першу частину гри &quot;відгадай число&quot;. Запустіть її за допомогою <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>На цей момент перша частина гри завершена: ми отримуємо дані з клавіатури та виводимо їх.</p>
<h2 id="Генерація-таємного-числа"><a class="header" href="#Генерація-таємного-числа">Генерація таємного числа</a></h2>
<p>Тепер нам треба згенерувати таємне число, яке користувач пробуватиме відгадати. Таємне число має бути різним кожного разу, щоб у гру було цікаво грати більше одного разу. Використаймо випадкове число від 1 до 100, щоб гра була не надто складною. Rust поки що не має функціональності для генерації випадкових чисел у стандартній бібліотеці; натомість команда Rust надає <a href="https://crates.io/crates/rand">крейт <code>rand</code></a> з таким функціоналом.</p>
<h3 id="Генерація-випадкового-числа"><a class="header" href="#Генерація-випадкового-числа">Генерація випадкового числа</a></h3>
<p>Пам'ятайте, що крейт є набором файлів вихідного коду Rust. Проєкт, що ми збираємо - це <em>двійковий крейт</em>, який є виконуваним. Крейт <code>rand</code> - це <em>бібліотечний крейт</em>, і він містить код, призначений для використання в інших програмах, та не може бути запущеним самостійно.</p>
<p>Використання зовнішніх крейтів - найсильніший бік Cargo. Перед тим, як писати код, що використовує <code>rand</code>, ми маємо змінити файл <em>Cargo.toml</em>, додавши туди крейт <code>rand</code> як залежність. Відкрийте цей файл і додайте такий рядок унизу, під заголовком секції <code>[dependencies]</code>, яку для вас створив Cargo. Переконайтеся, що зазначили <code>rand</code> точно так, як тут, із цим номером версії, інакше приклади коду з цього розділу можуть не запрацювати:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.3&quot;
</code></pre>
<p>У файлі <em>Cargo.toml</em> все, що йде після заголовку секції, належить до цієї секції - до початку нової секції. У секції <code>[dependencies]</code> ви повідомляєте Cargo, від яких зовнішніх крейтів залежить ваш проєкт і які версії цих крейтів вам потрібні. У цьому випадку, ми зазначаємо крейт <code>rand</code> із семантичним версіюванням <code>0.8.5</code>. Cargo розуміє <a href="http://semver.org">Семантичне версіювання</a><!-- ignore --> (яке іноді звуть <em>SemVer</em>), що є стандартом для запису номерів версій. Запис <code>0.8.5</code> насправді є скороченням для <code>^0.8.5</code>, що означає будь-яку версію, не меншу за 0.8.5, але меншу за 0.9.0.</p>
<p>Cargo вважає ці версії з сумісними з публічним API з версією 0.8.5, і ця специфікація гарантує, що ви отримаєте останній патч реліз, який все ще буде скомпільований з кодом у цьому розділі. У версій 0.9.0 і більших не гарантується збереження API, яке використовується подальшими прикладами.</p>
<p>Тепер, не змінюючи коду, побудуємо проєкт, як показано в Блоці коду 2-2.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">Блок коду 2-2: Вивід команди <code>cargo build</code> після додавання крейту rand як залежності</span></p>
<p>Ви можете бачити інші номери версій (але всі вони будуть сумісні з кодом, завдяки SemVer!) і різні рядки (залежно від операційної системи), і рядки можуть бути в іншому порядку.</p>
<p>Тепер, коли ми маємо зовнішню залежність, Cargo витягає останні версії всього, що нам треба, з <em>реєстру</em>, тобто копії даних з <a href="https://crates.io/">Crates.io</a>. На crates.io в екосистемі Rust люди викладають свої проєкти Rust з відкритим кодом, щоб ними могли скористатися інші.</p>
<p>Після оновлення реєстру Cargo перевіряє секцію <code>[dependencies]</code> і завантажує крейти, вказані там, але яких у вас бракує. В цьому випадку, хоча ми вказали тільки залежність від <code>rand</code>, Cargo також завантажив інші крейти, від яких залежить робота <code>rand</code>. Після завантаження крейтів Rust їх компілює, а потім компілює проєкт із доступними залежностями.</p>
<p>Якщо ви знову запустите <code>cargo build</code>, не зробивши жодних змін, ви не отримаєте жодної відповіді окрім рядка <code>Finished</code>. Cargo знає, що він вже завантажив і скомпілював залежності, а ви не змінили нічого, що б їх стосувалося, у файлі <em>Cargo.toml</em>. Cargo також знає, що ви не змінили нічого у коді, тому він не буде його перекомпільовувати. Оскільки роботи у Cargo немає, він просто завершується.</p>
<p>Якщо ви відкриєте файл <em>src/main.rs</em>, зробите тривіальну зміну, збережете і знову зберете, то побачите тільки два рядки виводу:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Ці рядки показують, що Cargo оновив збірку тільки вашою дрібною правкою до файлу <em>src/main.rs</em>. Залежності не змінилися, і Cargo знає, що може заново використати те, що він вже завантажив і скомпілював.</p>
<h4 id="Файл-cargolock-гарантує-відтворюваність-збірки"><a class="header" href="#Файл-cargolock-гарантує-відтворюваність-збірки">Файл <em>Cargo.lock</em> гарантує відтворюваність збірки</a></h4>
<p>Cargo має механізм, що гарантує однаковість збірки того самого артефакту кожного разу, коли ви чи хтось інший збирає ваш код: Cargo використає тільки ті версії залежностей, які ви зазначили, доки ви не вкажете інші. Наприклад, якщо наступного тижня вийде <code>rand</code> версії <code>0.8.6</code>, що міститиме важливе виправлення помилки, але також міститиме регресію, що зламає ваш код. Щоб упоратися з цим, при першому запуску <code>cargo build</code> Rust створює файл <em>Cargo.lock</em>, що відтепер розміщується у теці <em>guessing_game</em>.</p>
<p>Коли ви збираєте проєкт вперше, Cargo визначає всі версії залежностей, що відповідають критерію, і записує їх до файлу <em>Cargo.lock</em>. Коли ви пізніше збиратимете проєкт, Cargo побачить, що файл <em>Cargo.lock</em> існує, і використає версії, зазначені там, а не буде наново робити всю роботу з визначення версій. Це дозволяє автоматично робити відтворювану збірку. Іншими словами, ваш проєкт залишиться на версії 0.8.5, доки ви самі не захочете оновити її, завдяки файлу <em>Cargo.lock</em>. Оскільки файл <em>Cargo.lock</em> важливий для відтворюваної збірки, він часто додається до контролю початкового коду разом із рештою коду в проєкті.</p>
<h4 id="Оновлення-крейта-для-отримання-нової-версії"><a class="header" href="#Оновлення-крейта-для-отримання-нової-версії">Оновлення крейта для отримання нової версії</a></h4>
<p>Коли ж ви <em>хочете</em> оновити крейт, Cargo надає іншу команду, <code>update</code>, яка ігнорує файл <em>Cargo.lock</em> і визначає всі останні версії, що відповідають специфікаціям у <em>Cargo.toml</em>. Cargo запише ці версії до файлу <em>Cargo.lock</em>. Але за замовчанням Cargo шукатиме тільки версії, більші за 0.8.5 і менші 0.9.0. Якщо крейт <code>rand</code> вийшов у двох нових версіях, 0.8.6 та 0.9.0, то запустивши <code>cargo update</code> ви побачите таке:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo проігнорує реліз 0.9.0. Тут також можна звернути увагу на зміну у файлі <em>Cargo.lock</em> - версія крейта <code>rand</code>, яку ви використовуєте, тепер 0.8.6. Якщо вам потрібен <code>rand</code> версії 0.9.0 чи будь-якої версії у гілці 0.9.<em>x</em>, вам доведеться оновити файл <em>Cargo.toml</em>, щоб він мав такий вигляд:</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.9.0&quot;
</code></pre>
<p>Наступного разу, коли ви запустите <code>cargo build</code>, Cargo оновить реєстр доступних крейтів і заново перечитає вимоги до <code>rand</code> відповідно до вказаної вами нової версії.</p>
<p>Можна ще багато розповісти про <a href="http://doc.crates.io">Cargo</a><!-- ignore --> і <a href="http://doc.crates.io/crates-io.html">його екосистему</a><!-- ignore -->, яка обговорюється у Розділі 14, але поки що цього знати достатньо. Cargo робить використання бібліотек дуже простим, що дозволяє растацеанцям писати менші проєкти, зібрані з кількох пакетів.</p>
<h3 id="Генерація-випадкового-числа-1"><a class="header" href="#Генерація-випадкового-числа-1">Генерація випадкового числа</a></h3>
<p>Використаймо <code>rand</code> для генерації числа, що треба відгадати. Наступний крок - оновити <em>src/main.rs</em>, як показано в Блоці коду 2-3.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!(&quot;The secret number is: {secret_number}&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {guess}&quot;);
}
</code></pre>
<p><span class="caption">Listing 2-3: Adding code to generate a random number</span></p>
<p>Спершу ми додаємо рядок <code>use rand::Rng</code>. Трейт <code>Rng</code> визначає методи, які реалізує генератор випадкових чисел, і цей трейт має бути в області видимості, щоб ми могли скористатися цими методами. Розділ 10 розповість про трейти детальніше.</p>
<p>Далі ми додаємо всередині ще два рядки. У першому рядку ми викликаємо функцію <code>rand::thread_rng</code>, що дає нам генератор випадкових чисел, яким ми користуватимемся: він прив'язаний до потоку виконання, а його початкове значення задане операційною системою. Потім ми викликаємо метод генератора випадкових чисел <code>gen_range</code>. Цей метод визначається трейтом <code>Rng</code>, який ми внесли до області видимості інструкцією <code> use range::Rng</code>. Метод <code>gen_range</code> приймає параметрами два числа і генерує випадкове число в діапазоні між ними. Вираз для діапазону, що ми його тут застосували, має форму <code>початок..=кінець</code> і включає нижню і верхню межі, тому треба вказувати <code>1..=100</code>, щоб отримати число між 1 та 100.</p>
<blockquote>
<p>Примітка: Ви, звісно, не можете одразу знати, які трейти використати і які методи та функції викликати з крейта, тому кожен крейт має документацію з інструкцією до використання. Ще одна корисна можливість Cargo полягає в тому, що команда <code>cargo doc --open</code> збере на вашому комп'ютері документацію, надану всіма залежностями, і відкриє її у вашому переглядачі. Якщо вам цікавий інший функціонал, скажімо, крейту <code>rand</code>, запустіть <code>cargo doc --open</code> і клацніть <code>rand</code> на боковій панелі ліворуч.</p>
</blockquote>
<p>Другий рядок, який ми додали до коду, виводить таємне число. Це корисно, поки ми розробляємо програму, щоб можна було перевірити її роботу, але ми видалимо його у фінальній версії. Буде не дуже цікаво, якщо програма виводитиме відповідь одразу по запуску!</p>
<p>Спробуємо запустити програму кілька разів:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>Ви маєте побачити різні випадкові числа, і вони мають бути між 1 та 100. Чудова робота!</p>
<h2 id="Порівняння-здогадки-з-таємним-числом"><a class="header" href="#Порівняння-здогадки-з-таємним-числом">Порівняння здогадки з таємним числом</a></h2>
<p>Тепер, коли ми маємо введене користувачем і випадкове числа, ми можемо їх порівняти. Цей крок показано в Блоці коду 2-4. Зверніть увагу, що цей код ще не компілюється, як ми зараз пояснимо.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span>
    println!(&quot;You guessed: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p><span class="caption">Блок коду 2-4: Різні дії в залежності від порівняння двох чисел</span></p>
<p>Спершу ми додали ще одну інструкцію <code>use</code>, яка вводить тип <code>std::cmp::Ordering</code> зі стандартної бібліотеки в область видимості. Тип <code>Ordering</code> (&quot;впорядкування&quot;) - це ще один енум, що має варіанти: <code>Less</code> (&quot;менше&quot;), <code>Greater</code> (&quot;більше&quot;), and <code>Equal</code> (&quot;дорівнює&quot;). Це три можливі результати порівняння двох значень.</p>
<p>Потім ми додали в кінець коду п'ять нових рядків, в яких використали тип <code>Ordering</code>. Метод <code>cmp</code> порівнює два значення і може бути викликаний для всього, що можна порівнювати. Він приймає параметром посилання на те, що ви хочете порівнювати; тут він порівнює <code>guess</code> із <code>secret_number</code>. Потім він повертає варіант енуму <code>Ordering</code>, який ми внесли у область видимості за допомогою інструкції <code>use</code>. Ми скористалися виразом <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> , щоб визначити, що робити далі залежно від варіанту <code>Ordering</code>, що його повернув виклик <code>cmp</code> зі значеннями <code>guess</code> та <code>secret_number</code>.</p>
<p>Вираз <code>match</code> складається з <em>рукавів</em>. Рукав складається зі <em>шаблона</em> (&lt;0&gt;pattern&lt;/0&gt;) для порівняння та коду, який буде виконано, якщо значення, передане виразу <code>match</code>, відповідає шаблону цього рукава. Rust бере значення, передане <code>match</code>, і по черзі перевіряє шаблони рукавів. Шаблони та конструкція <code>match</code> - потужні засоби Rust, які дозволяють вам виражати різноманітні ситуації, які можуть трапитися вам при програмуванні, і допомагають переконатися, що ви обробили їх усіх. Детально ці можливості будуть розглянуті в Розділах 6 і 18, відповідно.</p>
<p>Розберімо крок за кроком цей приклад з виразом <code>match</code>. Нехай користувач увів 50, а випадково згенероване цього разу таємне число -
38.</p>
<p>Коли код порівнює 50 і 38, метод <code>cmp</code> поверне <code>Ordering::Greater</code>, бо 50 більше за 38. Вираз <code>match</code> отримує значення <code>Ordering::Greater</code> і починає перевіряти шаблони кожного рукава. Він перевіряє шаблон першого рукава, <code>Ordering::Less</code>, і бачить, що значення <code>Ordering::Greater</code> не відповідає <code>Ordering::Less</code>, тому пропускає рукав і переходить до наступного рукава. Шаблон наступного рукава, <code>Ordering::Greater</code>, <em>відповідає</em> <code>Ordering::Greater</code>! Код цього рукава буде виконано і виведе на екран <code>Too big!</code>. Вираз <code>match</code> завершується після першого вдалого порівняння, тому останній рукав в цьому випадку не буде перевірено.</p>
<p>Але Блок коду 2-4 все ще не компілюється. Спробуймо його скомпілювати:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`

error[E0283]: type annotations needed for `{integer}`
   --&gt; src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..=100);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
note: required by a bound in `gen_range`
   --&gt; /Users/carolnichols/.cargo/registry/src/github.com-1ecc6299db9ec823/rand-0.8.3/src/rng.rs:129:12
    |
129 |         T: SampleUniform,
    |            ^^^^^^^^^^^^^ required by this bound in `gen_range`
help: consider specifying the type arguments in the function call
    |
8   |     let secret_number = rand::thread_rng().gen_range::&lt;T, R&gt;(1..=100);
    |                                                     ++++++++

Some errors have detailed explanations: E0283, E0308.
For more information about an error, try `rustc --explain E0283`.
error: could not compile `guessing_game` due to 2 previous errors
</code></pre>
<p>Суть цієї помилки в тому, що тут є <em>невідповідні типи</em>. Rust має сильну, статичну систему типів. Разом із тим, він має систему виведення типів. Коли ми писали <code>let mut guess = String::new()</code>, Rust зміг вивести, що <code>guess</code> має бути типу <code>String</code> і не просив нас написати тип. <code>secret_number</code>, з іншого боку, числового типу. Кілька числових типів Rust можуть мати значення між 1 та 100: <code>i32</code>, знакове 32-бітне число; <code>u32</code>, беззнакове 32-бітне число; <code>i64</code>, знакове 64-бітне число і кілька інших. Як не вказати іншого, Rust за замовчанням обере <code>i32</code>, і це й буде типом <code>secret_number</code>, якщо ви не додасте інформацію про тип деінде, щоб змусити Rust вивести інший числовий тип. Причина ж цієї помилки полягає в тому, що Rust не може порівнювати стрічку і числовий тип.</p>
<p>Зрештою, ми хочемо перетворити стрічку <code>String</code>, яку програма прочитала з клавіатури, в числовий тип, щоб можна було порівняти його як число зі таємним числом. Це можна зробити, додавши ще один рядок до функції <code>main</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
<span class="boring">}
</span></code></pre>
<p>Ось цей рядок:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</code></pre>
<p>Ми створили змінну з назвою <code>guess</code>. Але чекайте, в програмі вже ніби існує змінна з назвою <code>guess</code>? Так, але Rust дозволяє затінити попереднє значення <code>guess</code> новим. <em>Затінення</em> дозволяє нам наново використати ім'я змінної <code>guess</code>, щоб не довелося створювати дві окремі змінні на кшталт <code>guess_str</code> і <code>guess</code>. Про це детальніше піде у <a href="ch03-01-variables-and-mutability.html#shadowing">Розділі 3</a><!-- ignore -->Розділ 3 детальніше розповідає про затінення, а поки що знайте, що ця особливість часто використовується, коли нам треба перетворити значення з одного типу в інший.</p>
<p>Ми зв'язали нову змінну з виразом <code>guess.trim().parse()</code>. <code>guess</code> у цьому виразі стосується першої змінної <code>guess</code>, у якій міститься стрічка, введена користувачем. Метод <code>trim</code>, застосований до екземпляра <code>String</code>, видалить всі пробільні символи на початку і в кінці, що треба зробити, аби порівняти стрічку з <code>u32</code>, який містить виключно числові дані. Користувач має натиснути на <span class="keystroke">enter</span>, щоб спрацював метод <code>read_line</code> і данні були введені, але це додає символ нового рядка до стрічки. Наприклад, якщо користувач набере <span class="keystroke">5</span> і натисне <span
class="keystroke">enter</span>, <code>guess</code> буде виглядати як <code>5\n</code>. <code>\n</code> позначає символ нового рядка. (У Windows натискання <span
class="keystroke">enter</span> створює символи повернення каретки та нового рядка, <code>\r\n</code>.) Метод <code>trim</code> видалить <code>\n</code> чи <code>\r\n</code>, і залишиться просто <code>5</code>.</p>
<p><a href="../std/primitive.str.html#method.parse">Метод <code>parse</code> для стрічок</a><!-- ignore --> перетворює стрічку на інший тип. Тут ми застосовуємо його для перетворення стрічки в число. Ми маємо повідомити Rust, який саме числовий тип нам потрібен, за допомогою <code>let guess: u32</code>. Двокрапка (<code>:</code>) після <code>guess</code> каже Rust, що ми анотуємо тип змінної. У Rust є кілька вбудованих числових типів; <code>u32</code>, що ви бачите тут є беззнаковим 32-бітним цілим. Це непоганий вибір для невеликих додатних чисел. Ви дізнаєтесь про інші типи у <a href="ch03-02-data-types.html#integer-types">Розділі 3</a><!-- ignore -->.</p>
<p>На додачу, саме анотація <code>u32</code> в цьому прикладі та порівняння із <code>secret_number</code> означає, що Rust виведе, що <code>secret_number</code> теж має бути <code>u32</code>. І тепер порівнюватимуться два значення одного типу!</p>
<p>Метод <code>parse</code> буде працювати тільки з символами, які можна логічно перетворити на числа, і тому легко може викликати помилки. Якщо, наприклад, стрічка містить <code>A👍%</code>, її неможливо буде перетворити на число. Оскільки метод <code>parse</code> може завершитися невдачею, він повертає <code>Result</code>, майже так само, як і метод <code>read_line</code> (про який ми вже говорили раніше в підрозділі <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result">&quot;Керування потенційною невдачею за допомогою <code>Result</code>&quot;</a><!-- ignore-->). Ми обробимо цей <code>Result</code> так само - за допомогою методу <code>expect</code>. Якщо <code>parse</code> поверне варіант <code>Result</code> <code>Err</code>, бо він не зміг створити число зі стрічки, виклик <code>expect</code> аварійно припинить гру і виведе повідомлення, яке ми йому надали. Якщо <code>parse</code> вдало створив число зі стрічки, він поверне варіант <code>Result</code> <code>Ok</code>, а <code>expect</code> поверне потрібне нам число зі значення <code>Ok</code>.</p>
<p>А тепер запустімо програму:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Чудово! Хоча ми й додали пробіли перед здогадкою, програма все одно зрозуміла, що користувач увів 76. Запустіть програму кілька разів, щоб перевірити різну поведінку на різних введених даних: введіть таємне число, більше за нього і менше.</p>
<p>Гра тепер майже працює, але користувачеві надається тільки одна можливість вгадати. Змінімо це, додавши цикл!</p>
<h2 id="Введення-кількох-здогадок-за-допомогою-циклу"><a class="header" href="#Введення-кількох-здогадок-за-допомогою-циклу">Введення кількох здогадок за допомогою циклу</a></h2>
<p>Ключове слово <code>loop</code> створює нескінчений цикл. Ми додамо цикл, щоб дати користувачам більше можливостей відгадати число:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --snip--

    println!(&quot;The secret number is: {secret_number}&quot;);

    loop {
        println!(&quot;Please input your guess.&quot;);

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<p>Як ви можете бачити, ми перенесли в цикл усе від запрошення ввести здогадку і до кінця. Обов'язково додайте в ці рядки відступи у чотири пробілами та знову запустіть програму. Програма запрошує ввести нову здогадку до нескінченості, що, власне, є новою проблемою. Не схоже, що користувач може вийти!</p>
<p>Користувач завжди може перервати програму, натиснувши клавіатурне скорочення <span class="keystroke">ctrl-c</span>. Але є інший спосіб втекти від цього ненажерного чудовиська - згаданий при обговоренні <code>parse</code> у підрозділі <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">&quot;Порівняння здогадки з таємним числом”</a><!--
ignore -->: якщо користувач введе щось, крім числа, програма аварійно завершиться. Ми можемо скористатися з цього, щоб користувач зумів вийти з програми, як показано тут:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Введення <code>quit</code> (&quot;вийти&quot;) дійсно призводить до виходу з гри, але так само спрацює будь-що, що не є числом. А все ж таки, це щонайменше не найкращий спосіб. Ми хочемо, щоб гра сама зупинялася, коли ми відгадали число.</p>
<h3 id="Вихід-після-вдалої-здогадки"><a class="header" href="#Вихід-після-вдалої-здогадки">Вихід після вдалої здогадки</a></h3>
<p>Запрограмуймо гру виходити, якщо користувач виграв, додавши інструкцію <code>break</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Додавання рядку <code>break</code> після<code>You win!</code> примусить програму вийти з циклу, якщо користувач відгадав таємне число. Вихід із циклу призведе до виходу з програми, бо цикл - це остання частина функції <code>main</code>.</p>
<h3 id="Обробка-неправильного-введення"><a class="header" href="#Обробка-неправильного-введення">Обробка неправильного введення</a></h3>
<p>Для покращення роботи гри, замість аварійного виходу, коли користувач вводить не число, зробімо так, що гра ігнорувала те, що ввели, щоб користувач міг продовжувати відгадувати. Ми можемо зробити це, змінивши рядок, де <code>guess</code> перетворюється зі <code>String</code> на <code>u32</code>, як показано в Блоці коду 2-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {guess}&quot;);

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 2-5: ігнорування введеного не-числа і запит ввести іншу відгадку замість аварійного завершення програми</span></p>
<p>Ми замінили виклик <code>expect</code> на вираз <code>match</code>, щоб перейти від аварійного завершення програми до обробки помилки. Згадаймо, що метод <code>parse</code> повертає тип <code>Result</code>, а <code>Result</code> - це енум, що має варіанти <code>Ok</code> та <code>Err</code>. Ми використовуємо тут вираз <code>match</code>, так само як робили з <code>Ordering</code>, що його повертає метод <code>cmp</code>.</p>
<p>Якщо <code>parse</code> зможе вдало перетворити стрічку на число, він поверне значення <code>Ok</code>, що міститиме результат - число. Це значення <code>Ok</code> буде відповідати зразку першого рукава, і весь вираз <code>match</code> поверне значення <code>num</code>, яке <code>parse</code> обчислив і поклав всередину значення <code>Ok</code>. Це число потрапить саме туди, куди нам треба - в нову змінну <code>guess</code>, яку ми створюємо.</p>
<p>Якщо <code>parse</code> <em>не</em> зможе перетворити стрічку на число, він поверне значення <code>Err</code>, що міститиме більше інформації про помилку. Значення <code>Err</code> не відповідає шаблону <code>Ok(num)</code> у першому рукаві <code>match</code>, але відповідає шаблону <code>Err(_)</code> у другому. Підкреслення <code>_</code> перехопить будь-яке значення; в цьому випадку, ми кажемо, що вираз має відповідати будь-якому <code>Err</code>, незалежно від інформації, що міститься у ньому. Тож програма виконає код другого рукава, <code>continue</code>, який каже програмі перейти на наступну ітерацію циклу <code>loop</code> і знову запитати наступну спробу. Таким чином, програма ігнорує всі помилки, які можуть зустрітися <code>parse</code>!</p>
<p>Нарешті все у нашій програмі має працювати як треба. Спробуймо запустити її:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>Блискуче! Лишилася тільки одна дрібна правка, і гра-відгадайка буде завершена. Згадаймо, що програма все ще виводить таємне число. Це було потрібно для тестування, але псує гру. Видалімо <code>println!</code>, який виводить таємне число. Блок коду 2-6 показує остаточний код.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {guess}&quot;);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Блок коду 2-6: Повний код гри &quot;відгадай число!&quot;</span></p>
<p>Отже, ви зуміли вдало зібрати гру &quot;відгадай число&quot;. Вітаємо!</p>
<h2 id="Підсумок-1"><a class="header" href="#Підсумок-1">Підсумок</a></h2>
<p>Цей проєкт був вступом до багатьох концепцій мови Rust через практику: <code>let</code>, <code>match</code>, функції, використання зовнішніх крейтів та інших. У кількох наступних розділах ми детальніше розберемо ці концепції. Розділ 3 розповідає про концепції, які є у більшості мов програмування, такі як змінні, типи даних, функції і показує, як ними користуватися в Rust. Розділ 4 досліджує володіння, концепцію мови Rust, що є найбільш відмінною від інших мов. Розділ 5 обговорює синтаксис структур і методів, а Розділ 6 детально розкриває, як працюють енуми.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Загальні-концепції-програмування"><a class="header" href="#Загальні-концепції-програмування">Загальні концепції програмування</a></h1>
<p>Цей розділ описує концепції, які можна зустріти у майже кожній мові програмування, і як вони працюють у Rust. Чимало мов програмування мають багато спільного у своїй основі. Жодна з концепцій, представлених у цьому розділі, не унікальна для Rust, але ми говоритимемо про них в контексті Rust і роз'яснимо пов'язані із ними умовності.</p>
<p>Зокрема, ви дізнаєтеся про змінні, базові типи, функції, коментарі і потік керування. Ці базові поняття зустрічаються у кожній програмі Rust, і вивчення їх на початку надасть вам міцну основу для подальшого руху.</p>
<blockquote>
<h4 id="Ключові-слова"><a class="header" href="#Ключові-слова">Ключові слова</a></h4>
<p>У мові Rust є набір <em>ключових слів</em>, зарезервованих для використання виключно самою мовою, так само як і в інших мовах. Пам'ятайте, що не можна використовувати ці слова як назви змінних та функцій. Більшість ключових слів мають особливе значення, і ви використовуватимете їх для виконання різноманітних задач у ваших програмах на Rust; декілька наразі не мають пов'язаної функціональності, проте лишаються зарезервованими для можливостей, які можуть бути додані до Rust в майбутньому. Список ключових слів можна знайти у <a href="appendix-01-keywords.html">Додатку A</a><!-- ignore -->.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Змінні-і-мутабельність"><a class="header" href="#Змінні-і-мутабельність">Змінні і мутабельність</a></h2>
<p>Як уже згадувалося у підрозділі <a href="ch02-00-guessing-game-tutorial.html#storing-values-with-variables">“Зберігання значень у змінних”</a><!-- ignore --> , за замовчанням змінні є <em>немутабельними</em>. Це - один з численних штурханців, якими Rust заохочує вас писати код, що користується перевагами у безпеці та простоті написання конкретного коду, які надає Rust. З усім тим, ви все ж маєте можливість зробити змінні мутабельними. Дослідимо, як і чому Rust заохочує вас надавати перевагу немутабельності, та чому ви можете захотіти відмовитися від цього.</p>
<p>Якщо змінна є немутабельною, це означає, що відколи значення стає прив'язаним до імені, ви не можете змінити це значення. Щоб проілюструвати це, згенеруємо новий проєкт з назвою<em>variables</em> у вашій теці <em>projects</em> за допомогою <code>cargo new variables</code>.</p>
<p>Потім, у новоствореній теці <em>variables</em>, відкрийте <em>src/main.rs</em> і замініть його код цим, який поки що не компілюється:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {x}&quot;);
    x = 6;
    println!(&quot;The value of x is: {x}&quot;);
}
</code></pre>
<p>Збережіть і запустіть програму за допомогою <code>cargo run</code>. Ви маєте отримати повідомлення про помилку щодо помилки немутабельності, як показано на цьому виведенні:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;The value of x is: {x}&quot;);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
</code></pre>
<p>Цей приклад показує, як компілятор допомагає вам знаходити помилки у програмах. Хоча повідомлення компілятора про помилки й можуть засмучувати, та вони лише означають, що ваша програма ще не робить те, що ви хотіли, у безпечний спосіб; вони <em>не</em> означають, що ви поганий програміст! Досвідчені растацеанці також отримують повідомлення про помилки від компілятора.</p>
<p>Ви отримали повідомлення про помилку <code>cannot assign twice to immutable variable `x`</code>, бо ви намагалися присвоїти друге значення немутабельній змінній <code>x</code>.</p>
<p>Важливо, що ми отримали помилку часу компіляції, коли намагалися змінити значення, яке раніше визначили як немутабельне, тому що ця ситуація може призвести до вад у програмі. Якщо одна частина нашого коду працює з припущенням, що значення не буде змінене, а інша частина нашого коду змінює це значення, можливо, що перша частина коду буде робити не те, для чого вона була розроблена. Цю причину вад важко відслідкувати після виявлення, особливо коли другий фрагмент коду змінює значення лише <em>час від часу</em>. У Rust компілятор гарантує, що, якщо ми заявили, що змінна не зміниться, вона і дійсно не зміниться, тому не треба відстежувати її самостійно. Ваш код стає легше зрозуміти.</p>
<p>Але мутабельність може бути дуже корисною і може бути зручнішим писати код з мутабельністю. Хоча змінні за замовчуванням є немутабельними, ви можете зробити їх мутабельними, додавши <code>mut</code> перед назвою змінної, як ви робили у <a href="ch02-00-guessing-game-tutorial.html#storing-values-with-variables">Розділі 2</a><!-- ignore -->. Додавання <code>mut</code> також передає ваші наміри майбутнім читачам коду, вказавши, що інші частини коду буде змінювати значення цієї змінної.</p>
<p>Наприклад, змінімо <em>src/main.rs</em> на такий код:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {x}&quot;);
    x = 6;
    println!(&quot;The value of x is: {x}&quot;);
}
</code></pre></pre>
<p>Запустивши програму ми отримаємо:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>Застосувавши <code>mut</code>, ми дозволили змінити значення, прив'язане до <code>x</code>, з <code>5</code> на <code>6</code>. Остаточне рішення, використовувати мутабельність чи ні, належить вам і залежить від того, що ви вважаєте найочевиднішим у конкретній ситуації.</p>
<h3 id="Константи"><a class="header" href="#Константи">Константи</a></h3>
<p>Подібно до немутабельних змінних, <em>константи</em> так само є значенням, прив'язаним до імені, які не можна змінювати, але є кілька відмінностей між константами і змінними.</p>
<p>По-перше, не можна використовувати <code>mut</code> з константами. Константи не просто немутабельні за замовчанням, вони завжди немутабельні. Константи проголошуються ключовим словом <code>const</code> замість <code>let</code>, і тип значення <em>має</em> явно позначатися. Ми розкажемо про типи і анотації типів у наступному підрозділі, <a href="ch03-02-data-types.html#data-types">&quot;Типи даних&quot;</a>,<!-- ignore -->, тому не хвилюйтеся зараз про деталі. Просто пам'ятайте, що тип констант треба зазначати завжди.</p>
<p>Константи можуть проголошуватися у будь-якій області видимості, у тому числі глобальній, що робить їх корисними для зберігання значень, що використовуються у багатьох частинах вашого коду.</p>
<p>Остання відмінність полягає в тому, що константи можуть набувати тільки значення константних виразів, а не значень, які можуть бути обчислені лише у час виконання.</p>
<p>Ось приклад проголошення константи:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}
</span></code></pre></pre>
<p>Константа зветься <code>THREE_HOURS_IN_SECONDS</code> і її значення встановлене в результат множення 60 (числа секунд у хвилині) на 60 (числа хвилин у годині) на 3 (числа годин, що ми хочемо порахувати у цій програмі). Угода про назви констант в Rust вимагає використання верхнього регістру із підкресленнями між словами. Компілятор здатний обчислити невеликий набір операцій під час компіляції, що дозволяє нам виписати це значення так, щоб його було легше зрозуміти та перевірити, замість того щоб встановлювати константі значення 10800. Зверніться до <a href="../reference/const_eval.html">Підрозділу Довідника Rust про обчислення констант</a> за додатковою інформацією про те, які операції можна використовувати при проголошенні констант.</p>
<p>Константи є коректними протягом усього часу життя програми у тій області видимості, де вони були проголошені. Це робить константи корисними для зберігання значень з предметної області вашого застосунку, про які необхідно знати багатьом частинам програми, наприклад, максимальна кількість балів, яку може отримати гравець чи швидкість світла.</p>
<p>Корисно давати назви жорстко заданим значенням, що використовуються у вашій програмі, позначаючи їх константами, щоб передати сенс цього значення тим, хто супроводжуватиме код. Це також корисно тим, що в коді буде тільки одне місце, яке буде необхідно змінити у разі потреби оновити жорстко задане значення.</p>
<h3 id="Затінення"><a class="header" href="#Затінення">Затінення</a></h3>
<p>Як ви бачили під час програмування гри - відгадайки у <a href="">Розділі 2</a><!-- ignore -->, можна проголошувати нову змінну із таким самим іменем, як і в раніше проголошеної змінної. Растацеанці кажуть, що перша змінна <em>затінена</em> другою, що означає, що при використанні змінної компілятор бачить лише другу змінну. По суті, друга змінна перекриває першу, перехоплюючи будь-яку згадку імені змінної на себе до тих пір, поки вона сама не буде затінена або область видимості не закінчиться. Ми можемо затінити змінну за допомогою ключового слова <code>let</code> та імені цієї змінної, ось так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;The value of x in the inner scope is: {x}&quot;);
    }

    println!(&quot;The value of x is: {x}&quot;);
}
</code></pre></pre>
<p>Ця програма спершу прив'язує <code>x</code> до значення <code>5</code>. Потім створює нову змінну <code>x</code>, повторюючи <code>let x =</code> і початкове значення та додає до нього <code>1</code>, так що значення <code>x</code> тепер <code>6</code>. Потім, у внутрішній області видимості, створеній фігурними дужками, третя інструкція <code>let</code> знову затінює <code>x</code> і створює нову змінну, домножуючи попереднє значення на <code>2</code>, щоб надати <code>x</code> значення <code>12</code>. Коли область видимості завершується, внутрішнє затінення теж завершується і <code>x</code> повертається до значення <code>6</code>. Якщо ми запустимо цю програму, вона виведе:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
</code></pre>
<p>Затінення відрізняється від позначення змінної <code>mut</code>, адже, якщо ми випадково спробуємо переприсвоїти значення цій змінній, не додавши ключове слово <code>let</code>, то отримаємо помилку часу компіляції. Використовуючи <code>let</code>, ми можемо виконати кілька перетворень значення, але лишити змінну немутабельною виконання цих перетворень.</p>
<p>Інша різниця між <code>mut</code> та затіненням полягає в тому, що, оскільки коли ми пишемо знову ключове слово <code>let</code>, насправді ми створюємо нову змінну, тож можемо змінити тип значення, але залишити ім'я. Наприклад, хай наша програма просить користувача вказати, скільки пробілів має бути всередині якогось тексту, ввівши символи пробілу, але насправді ми хочемо зберігати це значення як число:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let spaces = &quot;   &quot;;
    let spaces = spaces.len();
<span class="boring">}
</span></code></pre></pre>
<p>Перша змінна <code>spaces</code> має стрічковий тип, а друга змінна <code>spaces</code> має числовий тип. Затінення, таким чином, позбавляє нас необхідності придумувати різні імена, на кшталт <code>spaces_str</code> та <code>spaces_num</code>; натомість, ми можемо заново використати простіше ім'я <code>spaces</code>. Але якщо ми спробуємо для цього скористатися <code>mut</code>, як показано далі, то дістанемо помилку часу компіляції:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut spaces = &quot;   &quot;;
    spaces = spaces.len();
<span class="boring">}
</span></code></pre>
<p>Помилка каже, що не можна змінювати тип змінної:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = &quot;   &quot;;
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
</code></pre>
<p>Now that we’ve explored how variables work, let’s look at more data types they can have. ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Типи-даних"><a class="header" href="#Типи-даних">Типи даних</a></h2>
<p>Кожне значення в Rust має певний <em>тип даних</em>, який каже Rust, якого виду це дані, щоб мова знала, як працювати з цими даними. Ми поглянемо на дві категорії типів даних: скалярні і складені.</p>
<p>Пам'ятайте, що Rust - <em>статично типізована</em> мова, тобто типи всіх змінних має бути відомим під час компіляції. Компілятор зазвичай може вивести, який тип ми хочемо використати, виходячи зі значення і того, як ми його використовуємо. У випадках, коли може підійти кілька типів, наприклад коли якщо ми перетворювали <code>String</code> на числовий тип за допомогою <code>parse</code> у підрозділі <a href="">“Порівняння здогадки з таємним числом”</a><!-- ignore --> Розділу 2, ми маємо додавати анотацію типу, ось так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Якщо ми не додамо анотацію типу <code>: u32</code>, показану у попередньому коді, Rust видасть наступну помилку, яка означає, що компілятору потрібно більше інформації від нас, щоб дізнатися, який тип ми хочемо використати:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ consider giving `guess` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
</code></pre>
<p>Ви побачите різні анотації типів для інших типів даних.</p>
<h3 id="Скалярні-типи"><a class="header" href="#Скалярні-типи">Скалярні типи</a></h3>
<p><em>Скалярний</em> тип представляє єдине значення. У Rust є чотири первинні скалярні типи: цілі, числа з рухомою комою, булівські та символи. Ви можете впізнати їх з інших мов програмування. Гайда подивимося, як вони працюють у Rust.</p>
<h4 id="Цілі-типи"><a class="header" href="#Цілі-типи">Цілі типи</a></h4>
<p><em>Ціле</em> - це число без дробової частини. Ви використали один цілий тип у Розділі 2, а саме <code>u32</code>. Проголошення цього типу означає, що асоційоване з ним значення має бути беззнаковим цілим (знакові цілі типи починаються на <code>i</code>, на відміну від беззнакових <code>u</code>), що займає 32 біти пам'яті. Таблиця 3-1 показує вбудовані цілі типи в Rust. Ми можемо скористатися будь-яким з них для оголошення типу цілого числа.</p>
<p><span class="caption">Таблиця 3-1: Цілі типи в Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Довжина</th><th>Знаковий</th><th>Беззнаковий</th></tr></thead><tbody>
<tr><td>8 бітів</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 бітів</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 біти</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 біти</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128 бітів</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>Залежно від архітектури</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Кожен цілий тип є знаковим чи беззнаковим і має явно зазначений розмір. <em>Знаковий</em> і <em>беззнаковий</em> стосується того, чи може число бути від'ємним — іншими словами, чи має число знак (знакове) чи воно буде лише додатним і, відтак, може бути представлене без знаку (беззнакове). Це як запис чисел на папері: якщо знак має значення, число записується зі знаком плюс чи знаком мінус; але, якщо можна вважати, що число буде додатним, воно записується без знаку. Знакові числа зберігаються у <a href="https://en.wikipedia.org/wiki/Two%27s_complement">доповняльному коді</a><!-- ignore
--> .</p>
<p>Кожен знаковий цілий тип може зберігати числа від -(2<sup>n - 1</sup>) до 2<sup>n - 1</sup> - 1 включно, де <em>n</em> - кількість біт, які він використовує. Так, <code>i8</code> може зберігати числа від -(2<sup>7</sup>) до 2<sup>7</sup> - 1, тобто від -128 до 127. Беззнакові цілі типи зберігають числа від 0 до 2<sup>n</sup> - 1, так, <code>u8</code> може зберігати числа від 0 до 2<sup>8</sup> - 1, тобто від 0 до 255.</p>
<p>На додачу, типи <code>isize</code> та <code>usize</code> залежать від архітектури комп'ютера, на якому працює ваша програма: 64 біти, якщо це 64-бітна архітектура, чи 32 біти, якщо 32-бітна.</p>
<p>Ви можете писати цілі літерали в будь-якій формі, вказаній у Таблиці 3-2. Зверніть увагу, що числові літерали, які можуть бути різних типів, дозволяють використовувати суфікс типу на кшталт <code>57u8</code>, для визначення типу. Числові літерали також можуть використовувати <code>_</code> як роздільник для поліпшення читання, як-от <code>1_000</code>, що позначає те саме значення, що й запис <code>1000</code>.</p>
<p><span class="caption">Таблиця 3-2: Цілі літерали в Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Числові літерали</th><th>Приклад</th></tr></thead><tbody>
<tr><td>Десятковий</td><td><code>98_222</code></td></tr>
<tr><td>Шістнадцятковий</td><td><code>0xff</code></td></tr>
<tr><td>Вісімковий</td><td><code>0o77</code></td></tr>
<tr><td>Двійковий</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Байт (лише <code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>Як же зрозуміти, який тип цілого використати? Якщо ви непевні, вибір Rust за замовучанням зазвичай непоганий, а цілий тип за замовчуванням в Rust - <code>i32</code>. Основна ситуація, в якій варто використовувати <code>isize</code> та <code>usize</code> - індексація якого виду колекції.</p>
<blockquote>
<h5 id="Переповнення-цілого-числа"><a class="header" href="#Переповнення-цілого-числа">Переповнення цілого числа</a></h5>
<p>Скажімо, що у вас є змінна типу <code>u8</code>, що може мати значення між 0 та 255. Якщо ви спробуєте змінити її значення на те, що виходить за межі цього діапазону, скажімо 256, стається  <em>переповнення</em>, що призводить однієї з двох поведінок. Коли ви компілюєте програму в режимі дебагу, Rust додає перевірки на переповнення, які призведуть до <em>паніки</em> під час роботи програми, якщо воно станеться. Rust використовує термін <em>паніка</em>, коли програма завершується із помилкою; ми обговоримо паніку детальніше у підрозділі <a href="ch09-01-unrecoverable-errors-with-panic.html">“Невідновлювані помилки за допомогою <code>panic!</code>”</a><!-- ignore --> Розділу 9.</p>
<p>Коли ж ви компілюєте в режимі релізу за допомогою прапорця  <code>--release</code>, Rust <em>не</em> додає перевірок на переповнення, що спричинили б паніку. Натомість якщо виникає переповнення, Rust <em>загортає з доповненням до двох</em> це число. Якщо коротко, значення, більші за максимальне значення, що вміщується в тип, &quot;загортаються&quot; до мінімального значення, що вміщується в тип. У випадку з <code>u8</code>, значення 256 стає 0, 257 стає 1 і так далі. Програма не панікуватиме, але змінна матиме значення, що, мабуть, не відповідає вашим очікуванням. Не варто розраховувати на загортання при переповненні як на коректну поведінку, це помилка.</p>
<p>Щоб явно обробити можливість переповнення, ви можете використати такі групи методів, наданих стандартною бібліотекою для примітивних числових типів:</p>
<ul>
<li>Якщо вам потрібне саме загортання, використовуйте методи <code>wrapping_*</code>, наприклад <code>wrapping_add</code>.</li>
<li>Якщо вам потрібне значення <code>None</code> при переповненні, використовуйте методи <code>checked_*</code>.</li>
<li>Для виявлення переповнення методи <code>overflowing_*</code> повертають значення і булеве значення, що показує, чи сталося переповнення.</li>
<li>Якщо вам потрібне насичення до мінімального чи максимального значення, використовуйте методи <code>saturating_*</code>.</li>
</ul>
</blockquote>
<h4 id="Числа-з-рухомою-комою"><a class="header" href="#Числа-з-рухомою-комою">Числа з рухомою комою</a></h4>
<p>Також Rust має два примітивні типи для <em>чисел з рухомою комою</em>, тобто чисел з десятковою комою. Числа з рухомою комою в Rust - це <code>f32</code> та <code>f64</code>, які мають розмір у 32 біти та 64 біти відповідно. Тип за замовчанням - <code>f64</code>, оскільки на сучасних процесорах його швидкість приблизно така ж сама, як і в <code>f32</code>, але він має вищу точність. Усі числа з рухомою комою знакові.</p>
<p>Ось приклад, що демонструє числа з рухомою комою у дії:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>Числа з рухомою комою представлені відповідно до стандарту IEEE-754. Тип <code>f32</code> є числом одинарної точності, а <code>f64</code> має подвійну точність.</p>
<h4 id="Числові-операції"><a class="header" href="#Числові-операції">Числові операції</a></h4>
<p>Rust підтримує звичайні математичні операції, які ви очікуєте для будь-яких типів чисел: додавання, віднімання, множення, ділення й остача. Цілочисельне ділення округлює результат униз до найближчого цілого. Наступний код демонструє, як використовувати числові операції в інструкції <code>let</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
</code></pre></pre>
<p>Кожен вираз використовує математичний оператор і обчислює значення, яке прив'язується до змінної. <a href="appendix-02-operators.html">Додаток B</a><!-- ignore --> містить список усіх операторів, які використовуються в мові Rust.</p>
<h4 id="Булівський-тип"><a class="header" href="#Булівський-тип">Булівський тип</a></h4>
<p>Як і в більшості інших мов програмування, булівський тип у Rust має два можливі значення: <code>true</code> (&quot;істина&quot;) та <code>false</code> (&quot;неправда&quot;). Булівський тип займає 1 байт. Булівський тип у Rust позначається <code>bool</code>. Наприклад:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre></pre>
<p>Основний спосіб використання булівських значень - умовні вирази, такі, як вираз <code>if</code>. Ми розкажемо, як працюють вирази <code>if</code>, у підрозділі <a href="ch03-05-control-flow.html#control-flow">Потік виконання</a><!-- ignore --> .</p>
<h4 id="Символьний-тип"><a class="header" href="#Символьний-тип">Символьний тип</a></h4>
<p>Тип<code>`char</code> в Rust є найпростішим алфавітним типом. Ось кілька прикладів проголошення значень <code>char</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>Зверніть увагу, що літерали <code>char</code> позначаються одинарними лапками, на відміну від стрічкових літералів, які послуговуються подвійними. Тип <code>char</code> в Rust має чотири байти і представляє cкалярне значення в Юнікоді, тобто може представляти значно більше, ніж просто ASCII. Літери з наголосами, китайські, японські і корейські символи, смайлики і пробіли нульової ширини є коректними значеннями для <code>char</code> у Rust. Скалярні значення Юнікода можуть бути в діапазоні від <code>U+0000</code> до <code>U+D7FF</code> і <code>U+E000</code> до <code>U+10FFFF</code> включно. Однак &quot;символ&quot; насправді не є концепцією Юнікода, тому ваше інтуїтивне уявлення про те, що таке &quot;символ&quot; може не зовсім відповідати тому, чим є <code>char</code> у Rust. Цю тему ми детальніше обговоримо в підрозділі <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">&quot;Зберігання тексту, кодованого в UTF-8, у стрічках&quot;</a><!-- ignore --> Розділу 8.</p>
<h3 id="Складені-типи"><a class="header" href="#Складені-типи">Складені типи</a></h3>
<p><em>Складені типи</em> дозволяють об'єднувати багато значень в один тип. Rust має два базових складених типи: кортежі та масиви.</p>
<h4 id="Тип-кортеж"><a class="header" href="#Тип-кортеж">Тип кортеж</a></h4>
<p><em>Кортеж</em> (tuple) - основний спосіб збирати до купи ряд значень різних типів у один складений тип. Кортежі мають фіксовану довжину: один раз проголошені, вони не можуть зростати чи скорочуватися.</p>
<p>Кортеж утворюється списком значень, розділених комами, в дужках. Кожна позиція в кортежі має тип, і типи різних значень у кортежі не обов'язково мають збігатися. Ми додали необов'язкову анотацію типу у цьому прикладі:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>Змінна <code>tup</code> зв'язується з усім кортежем, оскільки кортеж розглядається як єдиний складений елемент. Щоб отримати окремі значення з кортежу, можна скористатися зіставлянням з шаблоном, щоб деструктуризувати значення кортежу, на кшталт цього:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {y}&quot;);
}
</code></pre></pre>
<p>Ця програма спершу створює кортеж і зв'язує його зі змінною <code>tup</code>. Далі вона використовує шаблон з <code>let</code>, щоб перетворити <code>tup</code> на три окремі змінні: <code>x</code>, <code>y</code> і <code>z</code>. Це зветься <em>деструктуризацією</em>, бо розбирає єдиний кортеж на три частини. І врешті програма виводить значення <code>y</code>, тобто <code>6.4</code>.</p>
<p>Ми також можемо отримати доступ до елементу кортежу напряму за допомогою точки (<code>.</code>), за якою іде індекс значення, яке нам треба отримати. Наприклад:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>Ця програма створює кортеж <code>x</code>, а потім створює нові змінні для кожного елементу за допомогою їхніх індексів. Як і в більшості мов програмування, перший індекс в кортежі - 0.</p>
<p>Кортеж без значень має особливу назву - <em>одиничний тип</em>. Це значення і відповідний тип обидва записуються як <code>()</code> і представляють порожнє значення чи порожній тип результату. Вирази неявно повертають одиничний тип, якщо вони не повертають жодного іншого значення.</p>
<h4 id="Тип-Масив"><a class="header" href="#Тип-Масив">Тип Масив</a></h4>
<p>Інший спосіб організувати колекцію з багатьох значень - це <em>масив</em>. На відміну від кортежу, всі елементи масиву мусять мати один тип. На відміну від масивів у деяких інших мовах, масиви в Rust мають фіксовану довжину.</p>
<p>Значення в масиві записуються як список, розділений комами, в квадратних дужках:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>Масиви корисні, коли дані мають бути розмішені в стеку, а не в купі (детальніше про це йдеться у <a href="ch04-01-what-is-ownership.html#the-stack-and-the-heap">Розділі 4</a><!-- ignore -->), чи коли ви хочете бути певним, що завжди маєте фіксовану кількість елементів. Втім, масиви не такі гнучкі, як вектори. <em>Вектор</em> - це схожий тип-колекція, наданий стандартною бібліотекою, який <em>може</em> зростати і скорочуватися. Якщо ви не певні, використовувати вам масив чи вектор, швидше за все варто використати вектор. <a href="ch08-01-vectors.html">Розділ 8</a><!-- ignore --> розповідає про вектори детальніше.</p>
<p>Разом із тим, масиви корисніші, коли ви знаєте, що кількість елементів не треба буде змінювати. Наприклад, коли ви використовуєте імена місяців у програмі, швидше за все ви використаєте масив, а не вектор, бо ви знаєте, що він завжди складатиметься з 12 елементів:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>Тип масиву записується за допомогою квадратних дужок з типом кожного елементу, крапки з комою і числом елементів масиву, ось так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Тут <code>i32</code> є типом кожного елементу. Після крапки з комою, число <code>5</code> позначає, що масив містить п'ять елементів.</p>
<p>Ви також можете ініціалізувати масив однаковими значеннями для кожного елементу, вказавши початкове значення, потім крапку з комою і довжину масиву у квадратних дужках, як показано тут:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<p>Масив, що зветься <code>a</code>, міститиме <code>5</code> елементів, що початково матимуть значення <code>3</code>. Це - те саме, що написати <code>let a = [3, 3, 3, 3, 3];</code> але стисліше.</p>
<h5 id="Доступ-до-елементів-масиву"><a class="header" href="#Доступ-до-елементів-масиву">Доступ до елементів масиву</a></h5>
<p>Масив - це єдиний блок пам'яті відомого, фіксованого розміру, що може бути виділений у стеку. Ви можете працювати з елементами масиву за допомогою індексів, ось так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<p>У цьому прикладі, змінна, що зветься <code>first</code>, отримає значення <code>1</code>, бо це значення в масиві за індексом <code>[0]</code>. Змінна, що зветься <code>second</code>, отримає значення <code>2</code> за індексом <code>[1]</code> у масиві.</p>
<h5 id="Некоректний-доступ-до-елементів-масиву"><a class="header" href="#Некоректний-доступ-до-елементів-масиву">Некоректний доступ до елементів масиву</a></h5>
<p>Подивімося, що станеться, якщо ви спробуєте дістатися до елемента масиву, що знаходиться за його кінцем. Скажімо, ви запустите цей код, схожий на гру-здогадайку з Розділу 2, щоб отримати індекс масиву від користувача:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Please enter an array index.&quot;);

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect(&quot;Failed to read line&quot;);

    let index: usize = index
        .trim()
        .parse()
        .expect(&quot;Index entered was not a number&quot;);

    let element = a[index];

    println!(&quot;The value of the element at index {index} is: {element}&quot;);
}
</code></pre>
<p>Цей код успішно компілюється. Якщо ви запустите цей код за допомогою <code>cargo run</code> і введете <code>0</code>, <code>1</code>, <code>2,</code>, ``, або <code>4</code>, програма виведе на екран відповідне значення з цього індексу в масиві. Якщо ж ви натомість введете число за кінцем масиву, таке як <code>10</code>, програма виведе таке:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Програма завершилася помилкою <em>часу виконання</em> у той момент, коли використала некоректне значення при застосуванні індексу. Програма вийшла з повідомленням про помилку і не виконала останню інструкцію <code>println!</code>. Коли ви намагаєтеся отримати доступ до елементу масиву, Rust перевіряє, чи зазначений індекс менший за довжину масиву. Якщо індекс більший чи дорівнює довжині, Rust панікує. Ця перевірка здійснюється під час виконання, особливо в цьому випадку, бо компілятор не має жодної можливості знати, яке значення введе користувач, коли код буде запущено.</p>
<p>Це приклад безпеки роботи з пам'яттю Rust у дії. У багатьох мовах низького рівня такої перевірки не відбувається, і коли ви задаєте некоректний індекс, може відбутися доступ до некоректної пам'яті. Rust захищає вас від такої помилки, одразу перериваючи роботу програми замість того, щоб дозволити некоректний доступ і продовжити роботу. Розділ 9 розповідає більше про обробку помилок у Rust і як ви можете писати читаний, безпечний код що не панікує і не дозволяє некоректний доступ до пам'яті.
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Функції"><a class="header" href="#Функції">Функції</a></h2>
<p>Функції використовуються скрізь у коді на Rust. Ви вже бачили одну з найважливіших функцій у мові - функцію <code>main</code>, яка є точкою входу багатьох програм. Ви також бачили ключове слово <code>fn</code>, яке дозволяє вам оголошувати нові функції.</p>
<p>У мові Rust для назв функцій і змінних домовлено використовувати <em>зміїний регістр</em> - тобто всі літери маленькі, а слова відокремлюються підкресленнями. Ось приклад програми, що містить визначення функції:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}
</code></pre></pre>
<p>Визначення функцій у Rust починаються з <code>fn</code>, далі іде назва функції і пара дужок. Фігурні дужки кажуть компілятору, де починається і закінчується тіло функції.</p>
<p>Ми можемо викликати будь-яку визначену нами функцію, написавши її назву і пару дужок. Оскільки в програмі є визначеної <code>another_function</code>, її можна викликати зсередини функції <code>main</code>. Зверніть увагу, що ми визначили <code>another_function</code> у початковому коді <em>після</em> функції <code>main</code>; так само її можна було визначити до функції &lt;0&gt;main&lt;/0&gt;. Для Rust не має значення, де ви визначаєте функції, важливо, щоб вони були визначені хоч десь у області видимості, доступної з місця виклику.</p>
<p>Почнімо новий двійковий проєкт з назвою <em>functions</em>, щоб глибше дослідити функції. Помістіть приклад <code>another_function</code> до файлу <em>src/main.rs</em> і запустіть його. Ви маєте побачити таке:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p>Рядки виконуються в порядку, в якому вони знаходяться в функції <code>main</code>. Спершу виводиться повідомлення “Hello, world!”, а потім викликається <code>another_function</code> і виводить своє повідомлення.</p>
<h3 id="Параметри"><a class="header" href="#Параметри">Параметри</a></h3>
<p>При визначенні функції ми можемо задати <em>параметри</em>, тобто спеціальні змінні, що є частиною сигнатури функції. Коли функція має параметри, ми можемо надати функції конкретні значення для цих параметрів. Формально, конкретні значення звуться <em>аргументами</em> або <em>фактичними параметрами</em>, а параметри у визначенні функції - <em>формальними параметрами</em>, але зазвичай слова &lt;0&gt;параметр&lt;/0&gt; та &lt;0&gt;аргумент&lt;/0&gt; використовуються як для частини визначення функції, так і для конкретних значень, які були передані при виклику функції.</p>
<p>Додамо параметр у нову версію <code>another_function</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {x}&quot;);
}
</code></pre></pre>
<p>Запустіть цю програму; вона має вивести таке:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>Проголошення <code>another_function</code> містить один параметр під назвою <code>x</code>. Тип <code>x</code> зазначено як <code>i32</code>. Коли в <code>another_function </code>передається <code>5</code>, макрос <code>println!</code> виведе <code>5</code> на місце фігурних дужок з <code>x</code> у форматній стрічці.</p>
<p>У сигнатурі функції ви <em>обов'язково</em> маєте проголошувати тип кожного параметру. Це свідоме рішення у дизайні мови Rust: обов'язкові анотації типів у визначенні функцій означають, що компілятору дуже рідко знадобиться просити вас використовувати їх деінде ще в коді, щоб зрозуміти, який тип ви мали на увазі. Також компілятор може надавати більш помічні повідомлення про помилки, якщо знатиме, які типи параметрів очікує функція.</p>
<p>When defining multiple parameters, separate the parameter declarations with commas, like this:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!(&quot;The measurement is: {value}{unit_label}&quot;);
}
</code></pre></pre>
<p>Цей приклад створює функцію <code>print_labeled_measurement</code> з двома параметрами. Перший параметр зветься <code>value</code> і має тип <code>i32</code>. Другий зветься <code>unit_label</code> і має тип <code>char</code>. Функція виводить текст, що містить і <code>value</code>, і <code>unit_label</code>.</p>
<p>Спробуймо запустити цей код. Замініть програму у файлі <em>src/main.rs</em> вашого проєкту <em>functions</em> попереднім прикладом, і запустіть його командою <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
</code></pre>
<p>Because we called the function with <code>5</code> as the value for <code>value</code> and <code>'h'</code> as the value for <code>unit_label</code>, the program output contains those values.</p>
<h3 id="Тіла-функцій"><a class="header" href="#Тіла-функцій">Тіла функцій</a></h3>
<p>Тіла функцій складаються з послідовності інструкцій, яка може закінчуватися виразом. Поки що ми функції, які ми згадували, не мали виразу наприкінці, але вирази були частиною інструкцій. Оскільки Rust є мовою, що ґрунтується на виразах, важливо розуміти цю відмінність. Інші мови не мають таких відмінностей, тому роздивімося, що таке інструкції та вирази і як різниця між ними впливає на тіла функцій.</p>
<ul>
<li><strong>Інструкції</strong> (&lt;0&gt;statement&lt;/0&gt;) - це команди, що виконують певну дію і не повертають значення.</li>
<li><strong>Вирази</strong> (&lt;0&gt;expression&lt;/0&gt;) обчислюються, в результаті даючи певне значення. Розгляньмо приклади.</li>
</ul>
<p>Власне, ми вже використовували інструкції та вирази. Створення змінної та приписування їй значення за допомогою ключового слова <code>let</code> є інструкцією. У Блоці коду 3-1 <code>let y = 6;</code> є інструкцією.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption">Блок коду 3-1. Проголошення функції <code>main</code>, що містить одну інструкцію</span></p>
<p>Визначення функцій також є інструкціями; весь попередній приклад як такий є інструкцією.</p>
<p>Інструкції не повертають значень. Таким чином, не можна присвоїти інструкцію <code>let</code> іншій змінній, як ми намагаємося в наступному коді; ви отримаєте помилку:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>При спробі запустити цю програму, ви отримаєте повідомлення про помилку:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement

error[E0658]: `let` expressions in this position are unstable
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  | 

For more information about this error, try `rustc --explain E0658`.
warning: `functions` (bin &quot;functions&quot;) generated 1 warning
error: could not compile `functions` due to 2 previous errors; 1 warning emitted
</code></pre>
<p>Інструкція <code>let y = 6</code> не повертає значення, тому немає нічого, з чим можна було б зв'язати <code>x</code>. Це відрізняється від інших мов, таких як C чи Ruby, де присвоєння повертає значення, яке воно присвоїло. У тих мовах можна написати <code>x = y = 6</code> і обидві змінні <code>x</code> та <code>y</code> набудуть значення <code>6</code>; у Rust так робити не можна.</p>
<p>Вирази обчислюються у певне значення і складають більшу частину коду, який ви писатимете на Rust. Розгляньмо просту математичну операцію, таку, як <code>5 + 6</code>, яка є виразом, що обчислюється у значення <code>11</code>. Вирази можуть бути частинами інструкцій: у Блоці коду 3-1 в інструкції <code>let y = 6;</code>, <code>6</code> - це вираз, що обчислюється у значення <code>6</code>. Виразами також є виклик функції чи макросу; блок, що створює нову область видимості за допомогою фігурних дужок - це також вираз, наприклад:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {y}&quot;);
}
</code></pre></pre>
<p>Цей вираз:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>є блоком, який, в цьому випадку, обчислюється у <code>4</code>. Це значення прив'язується до <code>y</code>, як частина інструкції <code>let</code>. Зверніть увагу, що <code>x + 1</code> не має крапки з комою наприкінці, на відміну від більшості рядків, які нам поки що траплялися. Вирази не мають завершувальної крапки з комою. Якщо ви додасте крапку з комою в кінець виразу, ви зробите його інструкцією, яка не повертає значення. Пам'ятайте це, коли вивчатимете далі значення, які повертають функції та вирази.</p>
<h3 id="Функції-що-повертають-значення"><a class="header" href="#Функції-що-повертають-значення">Функції, що повертають значення</a></h3>
<p>Функції можуть повертати значення в код, що їх викликав. Цим значенням ми не даємо власних імен, але маємо проголосити їхній тип після стрілочки (<code>-&gt;</code>). У Rust значення, що його повертає функція - це те саме, що значення останнього виразу в блоці - тілі функції. Ви можете також вийти з функції раніше за допомогою ключового слова <code>return</code> і вказання значення, але більшість функцій неявно повертають значення останнього виразу. Ось приклад функції, що повертає значення:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {x}&quot;);
}
</code></pre></pre>
<p>У функції <code>five</code> немає викликів інших функцій, макросів чи навіть інструкцій <code>let</code> - саме тільки число <code>5</code>. І це абсолютно коректна функція в Rust. Зверніть увагу, що тут зазначено тип значення, яке функція повертає <code>-&gt; i32</code>. Спробуймо запустити цей код; вивід має виглядати так:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p><code>5</code> у <code>five</code> є значенням, яке повертає функція, і тому тип, який повертає функція - <code>i32</code>. Розгляньмо це детальніше. Є два важливі моменти: по-перше, рядок <code>let x = five();</code> показує, що ми використовуємо значення, яке повернула функція, для ініціалізації змінної. Оскільки функція <code>five</code> повертає <code>5</code>, цей рядок робить те саме, що й такий:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>По-друге, функція <code>п'ять</code> не має параметрів і визначає тип значення, що повертає, але тіло функції -- самотнє <code>5</code> без крапки з комою -- це вираз, значення якого ми хочемо повернути.</p>
<p>Подивімося інший приклад:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {x}&quot;);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>Якщо виконати цей код, він виведе <code>The value of x is: 6</code>. Але якщо ми поставимо крапку з комою в кінець рядка <code>x + 1</code>, щоб він став не виразом, а інструкцією, ми дістанемо помилку:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {x}&quot;);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>Компіляція цього коду призводить до такої помилки:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` due to previous error
</code></pre>
<p>Основне повідомлення про помилку <code>mismatched types</code> (“невідповідні типи”) розкриває основну проблему цього коду. Визначення функції <code>plus_one</code> каже, що вона має повернути <code>i32</code>, але інструкції не обчислюються в значення, що позначається як <code>()</code>, одиничний тип. Таким чином, нічого не повертається, що суперечить визначенню функції й призводить до помилки. У цьому виведенні Rust повідомляє про можливість виправити цю проблему: він радить прибрати крапку з комою, що дійсно виправить помилку.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Коментарі"><a class="header" href="#Коментарі">Коментарі</a></h2>
<p>Всі програмісти прагнуть зробити свій код зрозумілішим, та деколи не завадить додаткове пояснення. В таких випадках програмісти лишають в початковому коді <em>коментарі</em>, які ігнорує компілятор, але які можуть бути корисними людям, що читатимуть цей код.</p>
<p>Ось простий коментар:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}
</span></code></pre></pre>
<p>У Rust найтиповіший стиль коментарів починається з двох знаків дробу і продовжується до кінця рядка. Для коментарів, що займають більше одного рядка, вам доведеться ставити <code>//</code> у кожному рядку, ось так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Тут ми робимо щось складне, досить довге, щоб нам знадобилося кілька рядків
// коментаря! Хух! Сподіваюся, цей коментар достатньо детально пояснює, що 
// тут відбувається.
<span class="boring">}
</span></code></pre></pre>
<p>Коментарі також можна розміщувати в кінці рядків, що містять код:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
</code></pre></pre>
<p>But you’ll more often see them used in this format, with the comment on a separate line above the code it’s annotating:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}
</code></pre></pre>
<p>Rust також має інший вид коментарів, документаційні коментарі, які ми обговоримо в підрозділі <a href="ch14-02-publishing-to-crates-io.html">&quot;Публікація крейта на Crates.io&quot;</a><!-- ignore -->
Розділу 14.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Управління-потоком-виконання"><a class="header" href="#Управління-потоком-виконання">Управління потоком виконання</a></h2>
<p>Здатність виконувати чи ні певний код залежно від того, чи умова істинна (<code>true</code>), чи повторити певний код кілька разів, доки умова <code>true</code> - базові будівельні елементи коду у більшості мов програмування. Найпоширеніші конструкції, що дозволяють вам управляти потоком виконання коду на Rust є вирази <code>if</code> та цикли.</p>
<h3 id="Вирази-if"><a class="header" href="#Вирази-if">Вирази <code>if</code></a></h3>
<p>Вираз <code>if</code> дозволяє розгалужувати код у залежності від умов. Ви задаєте умову, а потім вказуєте: “Якщо цю умову дотримано, запустити цей блок коду. Якщо ж умову не дотримано, не запускай цей блок коду”.</p>
<p>Створіть новий проект з назвою <em>branches</em> у вашій теці <em>projects</em> для вправ із виразом <code>if</code>. У файл <em>src/main.rs</em> введіть таке:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}
</code></pre></pre>
<p>Всі вирази <code>if</code> починаються з ключового слова <code>if</code>, за яким іде умова. В цьому випадку умова перевіряє, має чи ні змінна <code>number</code> значення, менше за 5. Ми розміщуємо блок коду, який треба виконати, якщо умова <code>true</code>, одразу після умови в фігурних дужках. Блоки коду, прив'язані до умов у виразах <code>if</code>, іноді звуть <em>рукавами</em>, так само як рукави у виразах <code>match</code>, що ми обговорювали у підрозділі <a href="">Порівняння здогадки з таємним числом</a><!--
ignore --> Розділу 2.</p>
<p>Також можна додати необов'язковий вираз <code>else</code>, як ми зробили тут, щоб надати програмі альтернативний блок коду для виконання, якщо умова виявиться <code>false</code>. Якщо ви не надасте виразу <code>else</code>, а умова буде <code>false</code>, програма просто пропустить блок <code>if</code> і перейде до наступного фрагмента коду.</p>
<p>Спробуйте запустити цей код; ви маєте побачити, що він виведе таке:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
</code></pre>
<p>Спробуймо змінити значення <code>number</code> на таке, що зробить умову <code>хибною</code>, і подивитися, що станеться:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!(&quot;condition was true&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;condition was false&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Запустіть програму знову і подивіться на вивід:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
</code></pre>
<p>Також варто зазначити, що умова в цьому коді <em>має</em> бути типу <code>bool</code>. Якщо умова не <code>bool</code>, ми отримаємо помилку. Наприклад, спробуйте запустити такий код:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);
    }
}
</code></pre>
<p>Умова у виразі <code>if</code> обчислюється тепер у значення <code>3</code>, і Rust повідомляє про помилку:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p>Помилка показує, що Rust очікував <code>bool</code>, але виявив ціле число. Rust не буде автоматично намагатися перетворити небулівські типи в булівський, на відміну від таких мов, як Ruby чи JavaScript. Ви маєте завжди явно надавати виразу <code>if</code> умову булівського типу. Якщо ми хочемо, щоб блок із кодом <code>if</code> виконувався тільки, скажімо, якщо число не дорівнює <code>0</code>, ми можемо змінити вираз <code>if</code> на такий:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);
    }
}
</code></pre></pre>
<p>Виконання цього коду виведе <code>number was something other than zero</code>.</p>
<h4 id="Обробка-множинних-умов-за-допомогою-else-if"><a class="header" href="#Обробка-множинних-умов-за-допомогою-else-if">Обробка множинних умов за допомогою <code>else if</code></a></h4>
<p>Можливо обирати з багатьох умов, комбінуючи <code>if</code> та <code>else</code> у ланцюжок виразів <code>else if</code>. Наприклад:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<p>Ця програма має чотири можливі шляхи. Після запуску, ви маєте побачити таке:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>Коли ця програма виконується, вона перевіряє по черзі кожен вираз <code>if</code> і виконує перший блок, для якого умова справджується. Зверніть увагу, що, хоча 6 і ділиться на 2, ми не бачимо повідомлення <code>number is divisible by 2</code>, так само як не бачимо і <code>number is not divisible by 4, 3 чи 2</code> з блоку <code>else</code> - бо Rust виконає тільки той блок, в якого першого умова буде <code>true</code>, а знайшовши його, не перевіряє всю решту умов.</p>
<p>Забагато виразів <code>else if</code> можуть захарастити ваш код, тому, якщо вам треба більш ніж одна така конструкція, цілком можливо, що знадобиться рефакторизувати ваш код. У Розділі 6 описана потужна конструкція мови Rust для розгалуження, що зветься <code>match</code>, для таких випадків.</p>
<h4 id="Використання-if-в-інструкції-let"><a class="header" href="#Використання-if-в-інструкції-let">Використання <code>if</code> в інструкції <code>let</code></a></h4>
<p>Because <code>if</code> is an expression, we can use it on the right side of a <code>let</code> statement to assign the outcome to a variable, as in Listing 3-2.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {number}&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 3-2: Assigning the result of an <code>if</code> expression to a variable</span></p>
<p>Змінна <code>number</code> буде прив'язана до значення, залежно від результату обчислення виразу <code>if</code>. Запустіть цей код і подивіться, що відбудеться:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>Нагадаємо, що значенням блоку коду є значення останнього виразу в них, а числа як такі самі є виразами. В цьому випадку, значення всього виразу <code>if</code> залежить від того, який блок коду буде виконано. Це означає, що значення, які можуть бути результатами у кожному рукаві <code>if</code> мають бути одного типу; у Блоці коду 3-2 результати рукавів <code>if</code> та <code>else</code> є цілими числами типу <code>i32</code>. Якщо ж типи не будуть збігатися, як у наступному прикладі, ми отримаємо помилку:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { &quot;six&quot; };

    println!(&quot;The value of number is: {number}&quot;);
}
</code></pre>
<p>Якщо ми спробуємо запустити цей код, то отримаємо помилку. Рукави <code>if</code> та <code>else</code> мають несумісні типи значень, і Rust точно вказує, де шукати проблему в програмі:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { &quot;six&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p>Вираз у блоці <code>if</code> обчислюється у ціле число, а вираз у блоці <code>else</code> обчислюється у стрічку. Це не працює, оскільки змінна мусить мати лише один тип. Rust має точно знати під час компіляції тип змінної <code>number</code>, щоб перевірити, що цей тип коректний усюди, де змінна <code>number</code> використовується. Rust не зможе зробити це, якщо тип <code>number</code> буде визначений після запуску програми; компілятор був би складнішим і надавав би менше гарантій стосовно коду, якби мусив стежити за чисельними можливими типами кожної змінної.</p>
<h3 id="Повторення-коду-за-допомогою-циклів"><a class="header" href="#Повторення-коду-за-допомогою-циклів">Повторення коду за допомогою циклів</a></h3>
<p>Часто трапляється, що блок коду треба виконати більше одного разу. Для цього Rust надає декілька <em>циклів</em>. Цикл виконує весь код тіла циклу до кінця, після чого починає спочатку. Для експериментів з циклами зробімо новий проєкт під назвою <em>loops</em>.</p>
<p>У Rust є три види циклів: <code>loop</code>, <code>while</code> та <code>for</code>. Спробуємо кожен з них.</p>
<h4 id="Повторення-коду-за-допомогою-loop"><a class="header" href="#Повторення-коду-за-допомогою-loop">Повторення коду за допомогою <code>loop</code></a></h4>
<p>Ключове слово <code>loop</code> каже Rust виконувати блок коду знову і знову без кінця або ж доки не буде прямо сказано зупинитися.</p>
<p>Наприклад, змініть вміст файлу <em>src/main.rs</em> в теці <em>loops</em>, щоб він виглядав так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre>
<p>Якщо запустити цю програму, ми побачимо, що <code>again!</code> виводиться неперервно раз у раз, доки ми не зупинимо програму вручну. Більшість терміналів підтримують клавіатурне скорочення <span class="keystroke">ctrl+c</span>, яке зупиняє програму, що застрягла у нескінченому циклі. Спробуйте:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>Символ <code>^C</code> позначає, де ви натиснули <span
class="keystroke">ctrl-c</span>. Слово <code>again!</code> може вивестися після <code>^C</code> чи ні, залежно від того, в який саме момент виконання коду був надісланий сигнал зупинки.</p>
<p>На щастя, Rust надає також інший, більш надійний спосіб перервати цикл за допомогою коду. Ви можете розмістити в циклі ключове слово <code>break</code>, щоб сказати програмі, коли припинити виконувати цикл. Згадайте, що ми вже його використовували у грі &quot;Відгадай число&quot; в підрозділі <a href="">&quot;Вихід після вдалої здогадки&quot;</a><!-- ignore
--> Розділу 2, щоб вийти з програми, коли користувач вигравав у грі, відгадавши правильне число.</p>
<p>Ми також використовували у цій грі <code>continue</code>, який у циклі каже програмі пропустити будь-який код, що лишився в цій ітерації циклу і перейти до наступної ітерації.</p>
<h4 id="Повернення-значень-з-циклів"><a class="header" href="#Повернення-значень-з-циклів">Повернення значень з циклів</a></h4>
<p>Одне з застосувань циклу <code>loop</code> - повторні спроби здійснити операцію, яка може зазнати невдачі, такої як перевірка, чи завершив певний процес свою роботу. Вам може бути потрібно при цьому передати результат цієї операції з циклу для використання в подальшому коді. Для цього, ви можете дописати значення, що ви хочете повернути, після виразу <code>break</code>, яким ви зупиняєте цикл; це значення повернеться з циклу і ви зможете використати його, як показано тут:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {result}&quot;);
}
</code></pre></pre>
<p>Перед циклом ми проголошуємо змінну <code>counter</code> і ініціалізуємо її в <code>0</code>. Потім ми проголошуємо змінну <code>result</code>, що отримає значення, повернуте з циклу. На кожній ітерації циклу ми додаємо <code>1</code> до змінної <code>counter</code>, а потім перевіряємо, чи дорівнює <code>counter</code> <code>10</code>. Коли так, ми використовуємо ключове слово <code>break</code> зі значенням <code>counter * 2</code>. Після циклу ми ставимо крапку з комою, щоб завершити інструкцію, що присвоює значення змінній <code>result</code>. Наприкінці ми виводимо значення <code>result</code>, у цьому випадку <code>20</code>.</p>
<h4 id="Мітки-циклів-для-розрізнення-між-декількома-циклами"><a class="header" href="#Мітки-циклів-для-розрізнення-між-декількома-циклами">Мітки циклів для розрізнення між декількома циклами</a></h4>
<p>Якщо у вас є цикли, вкладені в інші цикли, <code>break</code> і <code>continue</code> стосуються найглибшого циклу в точці, де вони застосовані. Ви можете за потреби вказати на циклі <em>мітку циклу</em>, що її можна потім використати в інструкціях <code>break</code> та <code>continue</code>, щоб вказати, що ці ключові слова стосуються циклу з міткою, а не найглибшого циклу. Мітки циклу починаються з одинарної лапки. Ось приклад із двома вкладеними циклами:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!(&quot;count = {count}&quot;);
        let mut remaining = 10;

        loop {
            println!(&quot;remaining = {remaining}&quot;);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(&quot;End count = {count}&quot;);
}
</code></pre></pre>
<p>Зовнішній цикл має мітку <code>'counting_up</code>, і він лічить від 0 до 2. Внутрішній цикл без мітки лічить навпаки від 10 до 9. Перший <code>break</code>, без указання мітки, виходить лише з внутрішнього циклу. Інструкція <code>break 'counting_up;</code> вийде з зовнішнього циклу. Цей код виведе:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
<h4 id="Умовні-цикли-за-допомогою-while"><a class="header" href="#Умовні-цикли-за-допомогою-while">Умовні цикли за допомогою <code>while</code></a></h4>
<p>Програмі часто потрібно обчислювати умову в циклі. Доки умова <code>true</code>, цикл виконується. Коли умова припиняє бути <code>true</code>, програма викликає <code>break</code>, щоб зупинити цикл. Подібну поведінку можна реалізувати за допомогою комбінації <code>loop</code>, <code>if</code>, <code>else</code> та <code>break</code>; якщо бажаєте, можете спробувати зробити це зараз. Утім, цей шаблон настільки поширений, що Rust має вбудовану конструкцію для цього, що зветься циклом <code>while</code>. У Блоці коду 3-3 ми використовуємо <code>while</code>, щоб повторити програму тричі, зменшуючи кожного разу відлік, і потім, після циклу, вивести повідомлення і завершитися.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{number}!&quot;);

        number -= 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p><span class="caption">Блок коду 3-3: використання циклу <code>while</code> для виконання коду, поки умова лишається істинною</span></p>
<p>Ця конструкція мови усуває складні вкладені конструкції, які були б потрібні, якби ви використовували <code>loop</code>, <code>if</code>, <code>else</code> та <code>break</code>, і вона зрозуміліша. Поки умова <code>true</code>, код виконується; в іншому разі, виходить з циклу.</p>
<h4 id="Цикл-по-колекції-за-допомогою-for"><a class="header" href="#Цикл-по-колекції-за-допомогою-for">Цикл по колекції за допомогою <code>for</code></a></h4>
<p>Ви можете скористатися конструкцією <code>while</code>, щоб зробити цикл по елементах колекції, такої, як масив. Наприклад, цикл у Блоці коду 3-4 виводить кожен елемент масиву <code>a</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index += 1;
    }
}
</code></pre></pre>
<p><span class="caption">Блок коду 3-4: перебір елементів колекції за допомогою циклу <code>while</code></span></p>
<p>Тут код перелічує всі елементи в масиві. Він починає з індексу <code>0</code>, а потім повторює, доки не досягне останнього індексу масиву (тобто коли <code>index &lt; 5</code> вже не буде <code>true</code>). Виконання цього коду виведе всі елементи масиву:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>Всі п'ять значень з масиву з'являються в терміналі, як і очікувалося. Хоча <code>index</code> досягне значення <code>5</code>, виконання циклу припиняється до спроби отримати шосте значення з масиву.</p>
<p>Але такий підхід вразливий до помилок; ми можемо викликати паніку в програмі некоректним індексом чи умовою продовження. Скажімо, якщо ви зміните визначення масиву <code>a</code> так, щоб він мав чотири елементи, і забудете змінити умову на <code>while index &lt; 4</code>, це код викличе паніку. Також він повільний, оскільки компілятор додає код для перевірки коректності індексу кожного елементу на кожній ітерації циклу.</p>
<p>Як стислішу альтернативу можна використати цикл <code>for</code>, який виконує код для кожного елементу колекції. Цикл <code>for</code> виглядає так, як показано в Блоці коду 3-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;the value is: {element}&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 3-5: Looping through each element of a collection using a <code>for</code> loop</span></p>
<p>Запустивши цей код, ми побачимо такий самий вивід, як і в Блоці коду 3-4. Що важливіше, ми збільшили безпеку коду та усунули можливість помилок - тепер неможливо, що код перейде за кінець масиву чи завершиться зарано, пропустивши кілька значень.</p>
<p>При використанні циклу <code>for</code> вам не треба пам'ятати, що треба змінити якийсь інший код, якщо ви змінили кількість значень у масиві, як це потрібно за методу, застосованого в Блоці коду 3-4.</p>
<p>Безпечність і лаконічність циклів <code>for</code> робить їх найпоширенішою конструкцією циклів у Rust. Навіть у ситуаціях, де треба виконати певний код визначену кількість разів, як у прикладі відліком в циклі <code>while</code> з Блоку коду 3-3, більшість растацеанців скористаються циклом <code>for</code>. Для цього треба буде скористатися типом <code>Range</code> (&quot;діапазон&quot;), який надається стандартною бібліотекою і генерує послідовно всі числа, починаючи з одного і закінчуючись перед іншим.</p>
<p>Ось як виглядає відлік, що використовує цикл <code>for</code> і ще один метод, про який ми ще не говорили, <code>rev</code>, для обернення діапазону:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{number}!&quot;);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p>Виглядає трохи краще, правда ж?</p>
<h2 id="Підсумок-2"><a class="header" href="#Підсумок-2">Підсумок</a></h2>
<p>Нарешті закінчили! Це був величенький розділ: ви вивчили змінні, скалярні та складені типи даних, функції, коментарі, вирази <code>if</code>, та ще цикли! Якщо ви хочете повправлятися з концепціями, обговореними у цьому розділі, спробуйте написати програми, що роблять таке:</p>
<ul>
<li>Конвертує температуру між шкалами Фаренгейта та Цельсія.</li>
<li>Обчислює <em>n</em>-е число Фібоначчі.</li>
<li>Виводить слова англійської різдвяної пісні &quot;Дванадцять днів Різдва&quot; з використанням повторень у пісні (якщо хочете - можете спробувати вивести казку &quot;Ріпка&quot;).</li>
</ul>
<p>Коли будете готові продовжувати, ми поговоримо про концепцію мови Rust, якої <em>немає</em> серед поширених в інших мовах програмування - володіння.
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Розуміння-володіння"><a class="header" href="#Розуміння-володіння">Розуміння володіння</a></h1>
<p>Володіння є найунікальнішою особливістю мови Rust, що має глибокий вплив на решту мови. Воно дозволяє Rust гарантувати безпечну роботу з пам'яттю без потреби у збирачі сміття, і тому важливо розуміти, як володіння працює. У цьому розділі ми поговоримо про володіння і декілька пов'язаних особливостей: позичання, слайси, і як Rust розташовує дані в пам'яті.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Що-таке-володіння"><a class="header" href="#Що-таке-володіння">Що таке володіння?</a></h2>
<p><em>Володіння</em> - це набір правил, які регулюють, як програма на Rust керує пам'яттю. Усі програми мають керувати тим, як вони використовують пам'ять комп'ютера під час роботи. Деякі мови мають збирача сміття, який постійно шукає пам'ять, що її вже не використовують, під час роботи програми; в інших мовах програміст має явно виділяти та звільняти пам'ять. Rust використовує третій підхід: пам'ять управляється системою володіння з набором правил, які перевіряє компілятор. Якщо якесь із правил порушується, програма не скомпілюється. Жодна з особливостей володіння не сповільніть вашу програму під час виконання.</p>
<p>Оскільки володіння - нова концепція для багатьох програмістів, потрібен деякий час, щоб звикнути до нього. Добра новина - що досвідченішим ви ставатимете в Rust і правилах системи володіння, тим легшим для вас буде природно писати безпечний і ефективний код. Не здавайтеся!</p>
<p>Коли ви зрозумієте володіння, ви матимете надійну основу для розуміння особливостей, що роблять Rust унікальною мовою. В цьому розділі ви вивчите володіння, працюючи з прикладами, що зосереджуються на добре відомих структурах даних: стрічках.</p>
<blockquote>
<h3 id="Стек-і-купа"><a class="header" href="#Стек-і-купа">Стек і купа</a></h3>
<p>У багатьох мовах програмування програміст нечасто має думати про стек і купу. Але в системних мовах, таких, як Rust, розташування значення в стеку чи в купі впливає на поведінку програми й змушує вас ухвалювати певні рішення. Деталі володіння будуть описані стосовно стека та купи пізніше у цьому розділі, а тут коротке пояснення для підготовки.</p>
<p>І стек, і купа - частини пам'яті, до яких ваш код має доступ під час виконання, але вони мають різну структуру. Стек зберігає значення в порядку, в якому їх отримує, і видаляє їх у зворотньому порядку. Це зветься <em>останнім надійшов, першим пішов</em> (&lt;0&gt;last in, first out&lt;/0&gt;). Стек можна уявити, як стос тарілок: коли ви додаєте тарілки, треба ставити їх зверху, а коли треба зняти тарілку, то доводиться брати теж зверху. Додавання чи прибирання тарілок з середини чи знизу стосу матимуть значно гірший наслідок! Додавання даних також зветься <em>заштовхуванням у стек</em> (<em>push</em>), а видалення - відповідно, &lt;0&gt;виштовхуванням&lt;/0&gt; (&lt;0&gt;pop&lt;/0&gt;). Усі дані. що зберігаються в стеку, мають бути відомого і незмінного розміру. Дані, розмір яких невідомий під час компіляції, або може змінитися, мають зберігатися в купі.</p>
<p>Купа менш організована: коли ви розміщуєте дані в купі, то запитуєте певний обсяг місця. Програма-розподілювач знаходить достатньо велику порожню ділянку в купі, позначає, що вона використовується, і повертає <em>вказівник</em>, тобто адресу цього місця. Цей процес зветься <em>розподілом у купі</em>, що іноді скорочується до простого <em>розподілом</em> (заштовхування значень до стека не вважається розподілом). Оскільки вказівник на купу має відомий, постійний розмір, ви можете зберегти цей вказівник у стеку, але коли вам потрібні дані, вам треба перейти за вказівником. Уявіть собі столи в ресторані. Коли ви входите до ресторану, вам треба сказати кількість людей, що прийшли з вами, тоді офіціант знайде вам порожній стіл, за який всі зможуть сісти, і відведе вас до нього. Якщо хтось спізнився, він зможе спитати, де вас розмістили, щоб приєднатися.</p>
<p>Заштовхування до стека швидше за розподіл у купі, оскільки розподілювачу не треба шукати місце для нових даних, бо це місце завжди є вершиною стека. Розподіл місця у купі вимагає порівняно більше роботи, бо розподілювач має спершу знайти достатньо місця для даних, а потім провести облік місця, щоб приготуватися до наступного розподілу.</p>
<p>Доступ доданих у купі повільніший, ніж у стеку, бо треба переходити за вказівником, щоб дістатися туди. Сучасні процесори швидше працюють, якщо відбувається менше переходів у пам'яті. Розвинемо аналогію: уявімо офіціанта у ресторані, який приймає замовлення з багатьох столів. Найефективніше буде &gt; прийняти всі замовлення з одного столу перед тим, як переходити до наступного. Приймати замовлення зі столу A, потім зі столу B, потім знову з A і знову з B буде значно повільніше. З тієї ж причини процесор краще працює з даними, розташованими поруч (як у стеку), ніж далеко (як може статися в купі).</p>
<p>Коли ваш код викликає функцію, значення, що передаються у функцію (включно з, можливо, вказівниками на дані у купі) і локальні змінні функції заштовхуються у стек. Коли функція завершується, ці значення виштовхуються зі стека.</p>
<p>Відстеження, які частини коду використовують які дані в купі, мінімізація дублювання даних у купі та очищення даних у купі, що вже не потрібні, щоб не скінчилося місце - ось ті завдання, які покликане розв'язати володіння. Коли ви зрозумієте концепцію володіння, вам більше не треба буде постійно думати про стек і купу, але знання, що причина існування володіння - управління даними у купі, допоможе вам зрозуміти, чому воно працює саме так.</p>
</blockquote>
<h3 id="Правила-володіння"><a class="header" href="#Правила-володіння">Правила володіння</a></h3>
<p>По-перше, познайомимося із правилами володіння. Тримайте ці правила на увазі, поки ми працюватимемо із прикладами, що їх ілюструють:</p>
<ul>
<li>Кожне значення в Rust має <em>власника</em>.</li>
<li>У кожен момент може бути лише один власник.</li>
<li>Коли власник виходить зі зони видимості, значення буде скинуто.</li>
</ul>
<h3 id="Область-видимості-змінної"><a class="header" href="#Область-видимості-змінної">Область видимості змінної</a></h3>
<p>Тепер, оскільки ми вже знайомі з основами синтаксису Rust, більше не будемо включати всі ці <code>fn main() {</code> у приклади, тому, щоб випробувати їх, вам доведеться помістити ці приклади до функції <code>main</code> самостійно. Завдяки цьому приклади стануть лаконічнішими і дозволять зосередитися на важливих деталях, а не на шаблонному коді.</p>
<p>У першому прикладі володіння ми розглянемо <em>область видимості</em> деяких змінних. Область видимості - це фрагмент програми, в якому з елементом можна працювати. Нехай ми маємо ось таку змінну:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Змінна <code>s</code> посилається на стрічковий літерал, значення якого жорстко задане в тексті нашої програми. Зі змінною можна працювати з моменту її проголошення до кінця поточної <em>області видимості</em>. Коментарі у Блоці коду 4-1 підказують, де змінна <code>s</code> доступна.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                      // s is not valid here, it’s not yet declared
        let s = &quot;hello&quot;;   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 4-1: A variable and the scope in which it is valid</span></p>
<p>Іншими словами, є два важливі моменти часу:</p>
<ul>
<li>Коли <code>s</code> потрапляє <em>в область видимості</em>, вона стає доступною.</li>
<li>Вона лишається доступною, доки не вийде <em>з області видимості</em>.</li>
</ul>
<p>Поки що стосунки між областями видимості та доступністю змінних такі ж самі, як і в інших мовах програмування. Тепер, спираючися на це розуміння, будемо розвиватися, додавши тип <code>String</code>.</p>
<h3 id="Тип-string"><a class="header" href="#Тип-string">Тип <code>String</code></a></h3>
<p>Щоб проілюструвати правила володіння, нам знадобиться тип даних, складніший за ті, що ми вже розглянули у підрозділі <a href="ch03-02-data-types.html#data-types">“Типи даних”</a><!-- ignore --> Розділу 3. Всі типи даних, які ми розглядали раніше, мають заздалегідь відомий розмір, можуть зберігатися в стеку і виштовхуватися звідти, коли їхня область видимості закінчується, і їх можна швидко і просто скопіювати, щоб зробити новий, незалежний екземпляр, коли інша частина коду потребує використати те саме значення в іншій області видимості. Але тепер ми розглянемо дані, що зберігаються в купі та подивимося, як Rust дізнається, коли ці дані треба вичищати, і тип <code>String</code> є чудовим прикладом.</p>
<p>Ми зосередимося на особливостях <code>String</code>, що стосуються володіння. Ці аспекти також застосовуються до інших складних типів даних, які надає стандартна бібліотека або ви створюєте самі. Ми поговоримо про <code>String</code> більш детально в <a href="ch08-02-strings.html">Розділі 8</a><!-- ignore -->.</p>
<p>Ми вже бачили стрічкові літерали, де значення стрічки жорстко задане в програмі. Стрічкові літерали зручні, але не завжди підходять для різних ситуацій, де виникає потреба скористатися текстом. Одна з причин полягає в тому, що вони є сталими. Інша - що не кожне значення стрічки є відомим під час написання коду: наприклад, як взяти те, що ввів користувач, і зберегти його? Для цих ситуацій, Rust має другий стрічковий тип, <code>String</code>. Цей тип керує даними, розподіленими в купі й, відтак, може зберігати текст, обсяг якого невідомий під час компіляції. Можна створити <code>String</code> зі стрічкового літерала за допомогою функції <code>from</code>, ось так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Оператор подвійна двокрапка <code>::</code> дозволяє доступ до простору імен, що надає нам можливість використати, в цьому випадку, функцію <code>from</code> з типу <code>String</code>, щоб не довелося використовувати назву на кшталт <code>string_from</code>. Цей синтаксис детальніше обговорюється у підрозділі <a href="ch05-03-method-syntax.html#method-syntax">“Синтакис методів”</a><!-- ignore --> Розділу 5 і в обговоренні просторів імен в модулях у <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Способи звертання до елементу в модульному дереві”</a><!-- ignore --> Розділу 7.</p>
<p>Цей тип стрічок <em>може</em> бути зміненим:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    s.push_str(&quot;, world!&quot;); // push_str() appends a literal to a String

    println!(&quot;{}&quot;, s); // This will print `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<p>У чому ж різниця? Чому <code>String</code> може бути зміненим, але літерали - ні? Різниця полягає в тому, як ці два типи працюють із пам'яттю.</p>
<h3 id="Память-і-розподіл"><a class="header" href="#Память-і-розподіл">Пам'ять і розподіл</a></h3>
<p>У випадку стрічкового літерала ми знаємо його вміст під час компіляції, тому текст жорстко заданий прямо у виконуваному файлі, що робить стрічкові літерали швидкими і ефективними. Але ці властивості випливають з незмінності літерала. На жаль, ми не можемо розмістити у двійковому файлі по шмату пам'яті для кожного фрагменту тексту, розмір якого ми не знаємо під час компіляції й чий розмір може змінитися під час виконання програми.</p>
<p>Для типу <code>String</code>, задля підтримки несталого шматка тексту, що може зростати, нам потрібно розподілити певну кількість пам'яті в купі, невідому під час компіляції, для зберігання вмісту. Це означає:</p>
<ul>
<li>Пам'ять має бути запитана в розподілювача під час виконання.</li>
<li>Нам потрібен спосіб повернення цієї пам'яті до розподілювача, коли ми закінчили працювати з нашим <code>String</code>.</li>
</ul>
<p>Першу частину робимо ми самі: коли ми викликаємо <code>String::from</code>, її реалізація запитує потрібну пам'ять. Так роблять практично всі мови програмування.</p>
<p>Але друга частина відбувається інакше. У мовах зі <em>збирачем сміття (garbage collector, GC)</em>, саме GC стежить і очищує пам'ять, що більше не використовується, і ми, як програмісти, більше можемо не думати про неї. У більшості мов без GC це наша відповідальність - визначити, яка пам'ять більше не потрібна та викликати код для її повернення, так само як до того ми її запитали. Правильно це робити історично є складною задачею у програмуванні. Якщо ми забудемо, ми змарнуємо пам'ять. Якщо ми це зробимо зарано, ми матимемо некоректну змінну. Якщо ми це зробимо двічі, це теж буде помилкою. Потрібно забезпечити, щоб на кожен <code>розподіл</code> було рівно одне <code>звільнення</code> пам'яті.</p>
<p>Rust іде іншим шляхом: пам'ять автоматично повертається, щойно змінна, що нею володіла, іде з області видимості. Ось версія нашого прикладу з Блоку коду 4-1 із використанням <code>String</code> замість стрічкового літерала:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from(&quot;hello&quot;); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid
<span class="boring">}
</span></code></pre></pre>
<p>Існує точка, де природно можна повернути пам'ять, використану нашою стрічкою, розподілювачу: коли <code>s</code> іде з області видимості. Коли змінна виходить з області видимості, Rust викликає для нас спеціальну функцію. Ця функція зветься <a href="../std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->, і саме там автор <code>String</code> може розмістити код для повернення пам'яті. Rust викликає <code>drop</code> автоматично на закриваючій фігурній дужці.</p>
<blockquote>
<p>Примітка: в C++ цей шаблон звільнення ресурсів наприкінці життя об'єкта іноді зветься <em>Отримання ресурсу є ініціалізація</em> (&lt;0&gt;Resource Acquisition Is Initialization, RAII&lt;/0&gt;). Функція Rust <code>drop</code> має бути знайома вам, якщо ви користувалися шаблонами RAII.</p>
</blockquote>
<p>Цей шаблон має глибокий вплив на спосіб написання коду Rust. Він наразі може виглядати простим, але поведінка коду може бути неочікуваною у складніших ситуаціях, коли ми працюватимемо із декількома змінними, що використовують дані, розподіленими в купі. Тепер дослідимо деякі з цих ситуацій.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-move"></a></p>
<h4 id="Як-взаємодіють-змінні-з-даними-переміщення"><a class="header" href="#Як-взаємодіють-змінні-з-даними-переміщення">Як взаємодіють змінні з даними: переміщення</a></h4>
<p>Різні змінні у Rust можуть взаємодіяти з одними й тими ж даними у різні способи. Подивимося на приклад, що використовує ціле число, у Блоці коду 4-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 4-2: Присвоєння цілого значення змінної <code>x</code> змінній <code>y</code></span></p>
<p>Ми, мабуть, можемо здогадатися, що робить цей код: &quot;прив'язати значення <code>5</code> до <code>x</code>; потім зробити копію значення у <code>x</code> і прив'язати її до <code>y</code>&quot;. Тепер ми маємо дві змінні, <code>x</code> та <code>y</code>, і обидві дорівнюють <code>5</code>. І дійсно це так і відбувається, бо цілі - прості значення із відомим, фіксованим розміром, і ці два значення <code>5</code> заштовхуються у стек.</p>
<p>Тепер подивімося на версію зі <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>Це виглядає дуже схожим на попередній код, тому ми можемо припустити, що воно працює так само, тобто другий рядок створить копію значення з <code>s1</code> і прив'яже її до <code>s2</code>. Але тут відбувається щось трохи інше.</p>
<p>Поглянемо на Рисунок 4-1, щоб зрозуміти, що відбувається всередині <code>String</code>. <code>String</code> складається з трьох частин, показаних ліворуч: вказівника на пам'ять, що зберігає вміст стрічки, довжини та місткості. Цей набір даних зберігається в стеку. Праворуч показана пам'ять у купі, що зберігає вміст.</p>
<p><img alt="Дві таблиці: перша таблиця містить представлення s1 у стеку, що
складається з довжини (5), місткості (5) і вказівника на перше значення
у другій таблиці. Друга таблиця містить побайтове представлення 
стрічкових даних у купі." src="img/trpl04-01.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">Рисунок 4-1: Представлення в пам'яті <code>String</code> зі значенням <code>&quot;hello&quot;</code>, прив'язаної до <code>s1</code></span></p>
<p>Довжина - це кількість пам'яті, в байтах, що вміст <code>String</code> наразі використовує. Місткість - це загальний обсяг пам'яті в байтах, що <code>String</code> отримала від розподілювача. Різниця між довжиною та місткістю має значення, але не в цьому контексті, тому поки що місткість можна спокійно ігнорувати.</p>
<p>Коли ми присвоюємо значення <code>s1</code> змінній <code>s2</code>, дані <code>String</code> копіюються - тобто копіюється вказівник, довжина і місткість, що знаходяться в стеку. Ми не копіюємо даних у купі, на які посилається вказівник. Іншими словами, представлення даних у пам'яті виглядає як на Рисунку 4-2.</p>
<p><img alt="Три таблиці: таблиці s1 і s2, які представляють ці стрічки у стеку, 
відповідно, і обидві вони вказують на одну і ту саму стрічку даних у купі."
src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Рисунок 4-2: Представлення в пам'яті змінної <code>s2</code>, що містить копію вказівника, довжини та місткості з <code>s1</code></span></p>
<p>Представлення <em>не</em> виглядає, як показано на Рисунку 4-3, як було б якби Rust дійсно копіювала також і дані в купі. Якби Rust так робила, операція <code>s2 = s1</code> була б потенційно дуже витратною з точки зору швидкості виконання, якщо в купі було б багато даних.</p>
<p><img alt="Чотири таблиці: дві таблиці, що представляють стекові дані для s1 і s2,
і кожна вказує на власну копію стрічкових даних у купі."
src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Рисунок 4-3: Інша можливість того, що могло б робити <code>s2 = s1</code>, якби Rust копіювала також дані в купі</span></p>
<p>Раніше ми казали, що коли змінна виходить з області видимості, Rust автоматично викликає функцію <code>drop</code> і очищає пам'ять цієї змінної в купі. Але Рисунок 4-2 показує, що обидва вказівники вказують на одне й те саме місце. Це створює проблему: коли <code>s2</code> і <code>s1</code> вийдуть з області видимості, вони удвох спробують звільнити одну й ту саму пам'ять. Це зветься помилкою <em>подвійного звільнення</em>, і ми про неї вже згадували. Звільнення пам'яті двічі може призвести до пошкодження пам'яті, і, потенційно, до вразливостей у безпеці.</p>
<p>Для убезпечення пам'яті після рядка <code>let s2 = s1</code> Rust розглядає змінну <code>s1</code> як більше не коректну. Відтак, Rust тепер не буде нічого звільняти, коли <code>s1</code> вийде з області видимості. Перевірте, що станеться, коли ви спробуєте використати <code>s1</code> після створення <code>s2</code>; це не спрацює:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;

    println!(&quot;{}, world!&quot;, s1);
<span class="boring">}
</span></code></pre>
<p>Ви отримаєте помилку на кшталт цієї, бо Rust не допускає використання некоректних посилань:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;hello&quot;);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Якщо ви чули терміни <em>пласка копія</em> та <em>глибока копія</em> (“shallow copy” та “deep copy”), коли працювали з іншими мовами, поняття копіювання вказівника, довжини та місткості без копіювання даних виглядають для вас схожими на пласку копію. Але оскільки Rust також унепридатнює першу змінну, це зветься не пласкою копією, а <em>переміщенням</em>. У цьому прикладі ми кажемо, що <code>s1</code> було <em>переміщено</em> в <code>s2</code>. Що фактично відбувається, показано на Рисунку 4-4.</p>
<p><img alt="Три таблиці: таблиці s1 і s2, які представляють ці стрічки у стеку, 
відповідно, і обидві вони вказують на одні й ті самі стрічкові даних у купі.
Таблиця s1 є затемнена, бо s1 більше не є коректним; лише s2 можна використовувати
для доступу до даних у купі." src="img/trpl04-04.svg" class="center" style="width:
50%;" /></p>
<p><span class="caption">Рисунок 4-4: Представлення в пам'яті після унепридатнення <code>s1</code></span></p>
<p>Це розв'язує нашу проблему! Якщо коректним зосталося лише <code>s2</code>, коли воно вийде з області видимості, то саме звільнить пам'ять, і готово.</p>
<p>На додачу, такий дизайн мови неявно гарантує, що Rust ніколи не буде автоматично створювати &quot;глибокі&quot; копії ваших даних. Таким чином, будь-яке <em>автоматичне</em> копіювання може вважатися недорогим з точки зору продуктивності під час виконання.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-clone"></a></p>
<h4 id="Як-взаємодіють-змінні-з-даними-клонування"><a class="header" href="#Як-взаємодіють-змінні-з-даними-клонування">Як взаємодіють змінні з даними: клонування</a></h4>
<p>Якщо ми <em>хочемо</em> зробити глибоку копію даних <code>String</code> у купі, а не лише в стеку, ми можемо використати загальний метод, що зветься <code>clone</code>. Синтаксис використання методів буде обговорено в Розділі 5, але оскільки методи є загальною особливістю багатьох мов програмування, ви, швидше за все, вже бачили їх.</p>
<p>Ось приклад застосування методу <code>clone</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>This works just fine and explicitly produces the behavior shown in Figure 4-3, where the heap data <em>does</em> get copied.</p>
<p>Коли ви бачите виклик <code>clone</code>, ви знаєте, що виконується певний визначений код і цей код може коштувати продуктивності. Це візуальний індикатор, що відбувається певна операція.</p>
<h4 id="Дані-в-стеку-копіювання"><a class="header" href="#Дані-в-стеку-копіювання">Дані в стеку: копіювання</a></h4>
<p>Є ще одна дрібниця, про яку ми ще не говорили. Цей код, що використовує цілі числа, частина якого вже була показана раніше в Блоці коду 4-2, коректно працює:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>But this code seems to contradict what we just learned: we don’t have a call to <code>clone</code>, but <code>x</code> is still valid and wasn’t moved into <code>y</code>.</p>
<p>Причина у тому, що типи на кшталт цілих, що мають відомий розмір часу компіляції, зберігаються повністю в стеку, тому копіювання їхніх значень відбувається швидко. Це означає, що нема підстав запобігати коректності <code>x</code> після створення змінної <code>y</code>. Іншими словами, тут немає різниці між глибокою та пласкою копією, і виклик <code>clone</code> не зробить нічого відмінного від звичайного плаского копіювання, тож можна його не викликати.</p>
<p>Rust має спеціальне позначення, що зветься трейтом <code>Copy</code>, який можна додати до типів на кшталт цілих, що зберігаються в стеку (детальніше трейти обговорюються в <a href="ch10-02-traits.html">Розділі 10</a><!-- ignore -->). Якщо тип реалізовує трейт <code>Copy</code>, змінні, що використовують його не переміщуються, а банально копіюються, що робить їх коректними після присвоєння іншій змінній.</p>
<p>Rust не дозволить позначити тип трейтом <code>Copy</code>, якщо тип, чи якась з його частин, реалізовує<code>трейт`Drop</code>. Якщо тип потребує чогось особливого, коли змінна виходить з області видимості, і ми додаємо позначення <code>Copy</code> до цього типу, ми отримаємо помилку часу компіляції. Щоб дізнатися про те, як додати позначку <code>Copy</code> до вашого типу для реалізації трейта, див. <a href="appendix-03-derivable-traits.html">&quot;Придатні до успадкування трейти&quot;</a><!-- ignore --> у Додатку C.</p>
<p>Тож які типи реалізовують трейт <code>Copy</code>? Можна перевірити документацію до певного типу, щоб бути певним, але загальне правило таке: будь-яка група простих скалярних значень може реалізовувати <code>Copy</code>, і нічого з того, що потребує розподілу пам'яті чи є ресурсом, не є <code>Copy</code>. Ось кілька типів, що реалізовують <code>Copy</code>:</p>
<ul>
<li>Всі цілі типи, на кшталт <code>u32</code>.</li>
<li>Булевий тип, <code>bool</code>, значення якого <code>true</code> та <code>false</code>.</li>
<li>Всі типи з рухомою комою, на кшталт <code>f64</code>.</li>
<li>Символьний тип, <code>char</code>.</li>
<li>Кортежі, якщо вони містять лише типи, що реалізовують <code>Copy</code>. Скажімо, <code>(i32, i32)</code> реалізовує <code>Copy</code>, але <code>(i32, String)</code> - ні.</li>
</ul>
<h3 id="Володіння-та-функції"><a class="header" href="#Володіння-та-функції">Володіння та функції</a></h3>
<p>Механіка передачі значень функції подібна до присвоювання значення змінній. Передача змінної функції є переміщенням чи копією, як і присвоювання. Блок коду 4-7 містить приклад з певними поясненнями, що розкривають, де змінні входять і виходять з області видимості.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!(&quot;{}&quot;, some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!(&quot;{}&quot;, some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
</code></pre></pre>
<p><span class="caption">Listing 4-3: Functions with ownership and scope annotated</span></p>
<p>Якби ми спробували використати <code>s</code> після виклику <code>takes_ownership</code>, Rust повідомив би про помилку часу компіляції. Ці статичні перевірки захищають нас від помилок. Спробуйте додати в <code>main</code> код, що використовує <code>s</code> та <code>x</code>, щоб побачити, де їх можна використовувати, а де правила володіння запобігають цьому.</p>
<h3 id="Повернення-значень-та-область-видимості"><a class="header" href="#Повернення-значень-та-область-видимості">Повернення значень та область видимості</a></h3>
<p>Повернення значень також передає володіння. Блок коду 4-4 містить приклад функції, що повертає значення, зі схожими на Блок коду 4-3 поясненнями.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from(&quot;hello&quot;);     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from(&quot;yours&quot;); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
</code></pre></pre>
<p><span class="caption">Блок коду 4-4: Передача володіння значенням, що повертається</span></p>
<p>Володіння змінними завше дотримується однакової схеми: присвоєння значення іншій змінній переміщує його. Коли змінна, що включає дані в купі, виходять з області видимості, якщо дані не були переміщені у володіння іншої змінної, значення буде очищене викликом <code>drop</code>.</p>
<p>Хоча так код працює, все ж взяття володіння і повернення володіння в кожній функції дещо втомлює. Що, як ми хочемо дозволити функції використати значення, але не брати володіння? Потреба повертати все, що ми передаємо в функції, щоб його можна було знову використовувати, разом із даними, утвореними в результаті роботи функції, дратує.</p>
<p>Можна повертати багато значень кортежем, як показано в Блоці коду 4-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
</code></pre></pre>
<p><span class="caption">Блок коду 4-5: Повернення володіння параметрами</span></p>
<p>Але це б давало забагато ритуальних рухів і зайвої роботи для концепції, що має бути загальновживаною. На щастя для нас, Rust має засіб для використання змінної без передачі володіння, що зветься <em>посиланнями</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Посилання-і-позичання"><a class="header" href="#Посилання-і-позичання">Посилання і позичання</a></h2>
<p>Проблема з кодом, що використовує кортежі, з Блоку коду 4-5 полягає в тому, що ми маємо повертати <code>String</code> у функцію, що викликає, щоб можна було використовувати <code>String</code> після виклику <code>calculate_length</code>, бо <code>String</code> переміщується до <code>calculate_length</code>. Натомість ми можемо надати посилання на значення <code>String</code>. <em>Посилання</em> - це як вказівник, тобто адреса, за якою можна перейти, щоб отримати дані, збережені за цією адресою; ці дані є володінням якоїсь іншої змінної. На відміну від вказівника, посилання гарантовано вказує на коректне значення певного типу весь час існування цього посилання.</p>
<p>Ось як ви маєте визначити і використовувати функцію <code>calculate_length</code>, що має параметром посилання на об'єкт замість перебирання володіння значенням:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>По-перше, зауважте, що весь код із кортежами при визначенні змінної та поверненні з функції зник. По-друге, зауважте, що ми передаємо <code>&amp;s1</code> у <code>calculate_length</code>, а у визначенні функції ми приймаємо <code>&amp;String</code> замість <code>String</code>. Ці амперсанди представляють <em>посилання</em>, і вони дозволяють нам посилатися на певне значення, не перебираючи володіння ним. Рисунок 4-5 описує цю концепцію.</p>
<p><img alt="Три таблиці: таблиця s містить лише вказівник на таблицю
для s1. Таблиця для s1 містить дані стеку для s1 і вказує на
стрічкові дані у купі." src="img/trpl04-05.svg" class="center" /></p>
<p><span class="caption">Рисунок 4-5: Діаграма, як <code>&amp;String s</code> вказує на <code>String s1</code></span></p>
<blockquote>
<p>Примітка: операція, зворотна до посилання <code>&amp;</code>, зветься <em>розіменуванням</em>, і виконується оператором розіменування <code>*</code>. Ми побачимо деякі застосування оператора розіменування в Розділі 8 і обговоримо подробиці розіменування у Розділі 15.</p>
</blockquote>
<p>Розглянемо детальніше виклик функції:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span></code></pre></pre>
<p>Запис <code>&amp;s1</code> створює посилання, що <em>посилається</em> на значення <code>s1</code>, але не володіє ним. Оскільки володіння немає, значення, на яке воно вказує, не буде знищене, коли посилання вийде з області видимості.</p>
<p>Так само, сигнатура функції використовує <code>&amp;</code>, щоб показати, що тип параметра <code>s</code> - посилання. Додамо трохи коментарів для пояснення:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;hello&quot;);
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, it is not dropped.
</code></pre></pre>
<p>Область видимості, де змінна <code>s</code> є коректною, така сама, як і у будь-якого параметра функції, але значення, на що вказує посилання, не припиняє свого існування коли <code>s</code> припиняє використовуватися, бо <code>s</code> ним не володіє. Коли функції мають параметри - посилання замість значень, нам не треба повертати значення, щоб повернути володіння, бо ми й не мали володіння.</p>
<p>Операція створення посилання зветься <em>позичанням</em>. Як і в справжньому житті, якщо особа володіє чимось, ви можете це позичити у неї , а коли річ вам стане не потрібна, треба її віддати. Бо вона вам не належить.</p>
<p>Що ж станеться, якщо ми спробуємо змінити щось, що ми позичили? Спробуйте запустити код з Блоку коду 4-6. Обережно, спойлер: він не працює!</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p><span class="caption">Блок коду 4-6: Спроба змінити позичене значення</span></p>
<p>Ось помилка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`
8 |     some_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Посилання, так само як і змінні, за умовчанням є немутабельними. Ми не можемо змінити щось, на що ми маємо посилання.</p>
<h3 id="Мутабельні-посилання"><a class="header" href="#Мутабельні-посилання">Мутабельні посилання</a></h3>
<p>We can fix the code from Listing 4-6 to allow us to modify a borrowed value with just a few small tweaks that use, instead, a <em>mutable reference</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>По-перше, треба змінити <code>s</code>, щоб він став <code>mut</code>. Потім ми створюємо мутабельне посилання за допомогою <code>&amp;mut s</code> там, де викликаємо функцію <code>change</code>, і змінюємо сигнатуру функції, щоб вона приймала мутабельне посилання за допомогою <code>some_string: &amp;mut String</code>. Це явно показує, що функція <code>change</code> змінить позичене значення.</p>
<p>Мутабельні посилання мають одне суттєве обмеження: якщо ви маєте мутабельне посилання на значення, то більше не можете мати інших посилань на це значення. Цей код, що намагається створити два мутабельні посилання на <code>s</code>, не спрацює:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre>
<p>Ось помилка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Помилка каже, що цей код некоректний, бо ми не можемо позичити <code>s</code> як мутабельне значення більш ніж один раз. Перше мутабельне позичання знаходиться в <code>r1</code> має існувати, доки не буде використане в <code>println!</code>, але між створенням цього мутабельного посилання і його використанням, ми намагалися створити ще одне мутабельне посилання в <code>r2</code>, що позичає ті ж дані, що й <code>r1</code>.</p>
<p>Це обмеження, що забороняє кілька мутабельних посилань на одні й ті самі дані в один час, дозволяє їх змінювати, але під пильним контролем. Це те, із чим борються початківці-растацеанці, бо більшість мов дозволяють вам змінювати дані коли завгодно. Перевага цього обмеження в тому, що Rust може запобігти гонитві даних під час компіляції. <em>Гонитва даних</em> подібна до стану гонитви й стається, коли мають місце такі три умови:</p>
<ul>
<li>Два чи більше вказівників мають доступ до одних даних у один і той самий час.</li>
<li>Щонайменше один зі вказівників використовується для запису даних.</li>
<li>Не застосовується жодних механізмів синхронізації доступу до даних.</li>
</ul>
<p>Гонитви даних викликають невизначену поведінку і їх може бути складно діагностувати та виправляти, коли ви намагаєтесь відстежити їх під час роботи програми; Rust запобігає проблемі, відмовляючись компілювати код з гонитвою даних!</p>
<p>As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not <em>simultaneous</em> ones:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<p>Rust застосовує схоже правило для змішування мутабельних і немутабельних посилань. Цей код призводить до помилки:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM

    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre>
<p>Ось помилка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Хух! Не виходить <em>також</em> мати мутабельне посилання, коли в нас є немутабельне посилання на це ж значення.</p>
<p>Користувачі немутабельного посилання не очікують, що його значення несподівано зміниться прямо під час використання. Втім, багато немутабельних посилань допустимі, бо жоден з тих, хто просто читає дані, не може вплинути на те, що інші теж читають ці ж дані.</p>
<p>Зверніть увагу, що область видимості посилання починається з місця його проголошення і продовжується до останнього разу, коли посилання використовується. Наприклад, цей код компілюється тому, що останнє використання немутабельних посилань у <code>println!</code> відбувається до проголошення мутабельного посилання:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    println!(&quot;{} and {}&quot;, r1, r2);
    // variables r1 and r2 will not be used after this point

    let r3 = &amp;mut s; // no problem
    println!(&quot;{}&quot;, r3);
<span class="boring">}
</span></code></pre></pre>
<p>Області видимості немутабельних посилань <code>r1</code> і <code>r2</code> завершуються після <code>println!</code>, де вони востаннє використані, тобто перед створенням мутабельного посилання <code>r3</code>. Ці області видимості не перекриваються, тож цей код є коректним: компілятор може сказати, що посилання більше не використовується, навіть якщо це місце до завершення області видимості.</p>
<p>Хоча ці помилки часом і дратують, пам'ятайте, що це компілятор Rust вказує на потенційний баг завчасно (під час компіляції замість часу виконання) і точно вказує, де полягає проблема , замість змушувати вас відстежувати, чому іноді ваші дані не такі, як ви очікували.</p>
<h3 id="Висячі-посилання"><a class="header" href="#Висячі-посилання">Висячі посилання</a></h3>
<p>У мовах із вказівниками легко можна помилково створити <em>висячий вказівник</em> - вказівник, що посилається на місце в пам'яті, що було виділене комусь іще - звільнивши пам'ять, але залишивши вказівник на цю пам'ять. У Rust натомість компілятор гарантує, що посилання ніколи не стануть висячими: якщо ви маєте посилання на певні дані, компілятор пересвідчиться, що дані не вийдуть з області видимості раніше за посилання на ці дані.</p>
<p>Let’s try to create a dangling reference to see how Rust prevents them with a compile-time error:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<p>Ось помилка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Це повідомлення про помилку посилається на особливість, про яку ми ще не розповідали: час існування. Ми обговоримо часи існування детальніше у Розділі 10. Але, якщо опустити частини про час існування, повідомлення містить ключ до того, чому цей код містить проблему:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from (тип, що повертає ця функція, містить позичене значення, але немає значення, яке воно може позичити)
</code></pre>
<p>Подивімося ближче, що саме відбувається на кожному кроці нашого коду <code>dangle</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle returns a reference to a String

    let s = String::from(&quot;hello&quot;); // s is a new String

    &amp;s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
</code></pre>
<p>Оскільки <code>s</code> було створено всередині <code>dangle</code>, коли код <code>dangle</code> завершується, <code>s</code> буде вивільнено. Але ми намагаємося повернути посилання на нього. Це означає, що це посилання буде вказувати на некоректний <code>String</code>. Так не можна! І Rust цього не допустить.</p>
<p>Рішення тут - повертати <code>String</code> безпосередньо:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
</code></pre></pre>
<p>Це працює без проблем. Володіння переміщується з функції, і нічого не звільняється.</p>
<h3 id="Правила-посилань"><a class="header" href="#Правила-посилань">Правила посилань</a></h3>
<p>Ще раз повторимо, що ми обговорили про посилання:</p>
<ul>
<li>У будь-який час можна мати <em>або</em> одне мутабельне посилання, <em>або</em> будь-яку кількість немутабельних посилань.</li>
<li>Посилання завжди мають бути коректними.</li>
</ul>
<p>Далі ми поглянемо на інший тип посилань: слайси.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Тип-даних-слайс"><a class="header" href="#Тип-даних-слайс">Тип даних слайс</a></h2>
<p><em>Слайси</em> дозволяють вам посилатися на неперервні послідовності елементів у колекції замість усієї колекції. Слайс - це посилання, тому він не володіє данними.</p>
<p>Ось проста задача з програмування: написати функцію, що приймає стрічку зі слів, розділених пробілами, і повертає перше слово, яке знаходиться в цій стрічці. Якщо функція не знайде пробіл у стрічці, це означає, що вся стрічка є одним словом і, відтак, функція має повернути всю стрічку.</p>
<p>Let’s work through how we’d write the signature of this function without using slices, to understand the problem that slices will solve:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>Ця функція, <code>first_word</code>, приймає параметром <code>&amp;String</code>. Нам не потрібне володіння, тому це нормально. Але що ми маємо повернути? У нас немає способу, що виразити <em>частину</em> стрічки. Однак ми можемо повернути індекс кінця слова, позначений пробілом. Спробуємо зробити це у Блоці коду 4-7.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 4-7: The <code>first_word</code> function that returns a byte index value into the <code>String</code> parameter</span></p>
<p>Оскільки нам треба пройти через <code>String</code> елемент за елементом і перевірити, чи значення є пробілом, ми перетворимо наш <code>String</code> на масив байтів за допомогою методу <code>as_bytes</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Далі ми створюємо ітератор по масиву байтів за допомогою методу <code>iter</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Ітератори будуть детальніше обговорені в <a href="ch13-02-iterators.html">Розділі 13</a><!-- ignore -->. Поки що достатньо знати, що <code>iter</code> - метод, що повертає кожен елемент у колекції, а метод <code>enumerate</code> обгортає результат <code>iter</code> у кортеж. Перший елемент кортежу, що його повертає <code>enumerate</code> - індекс, а другий - посилання на елемент. Це трохи зручніше, ніж обчислювати індекс самостійно.</p>
<p>Оскільки метод <code>enumerate</code> повертає кортеж, ми можемо скористатися шаблонами для деструктуризації цього кортежу. Ми ще будемо обговорювати шаблони в <a href="ch06-02-match.html#patterns-that-bind-to-values">Розділі 6</a><!-- ignore -->. В циклі <code>for</code> ми визначаємо шаблон, що складається з індексу <code>i</code> і байту <code>&amp;item</code> в кортежі. Оскільки ми отримуємо посилання на елемент від <code>.iter().enumerate()</code>, то використовуємо в шаблоні <code>&amp;</code>.</p>
<p>У циклі <code>for</code> ми шукаємо байт, що представляє пробіл, за допомогою байтового літералу. Коли знаходимо пробіл, ми повертаємо його індекс. Якщо цього не сталося, повертаємо довжину стрічки за допомогою методу <code>s.len()</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Тепер ми маємо спосіб знайти індекс кінця першого слова у стрічці, але є проблема. Ми повертаємо одне значення <code>usize</code>, але це значення має сенс лише в контексті нашої стрічки <code>&amp;String</code>. Іншими словами, оскільки це значення не пов'язане із зі стрічкою, немає гарантії, що воно буде коректним надалі. Розглянемо програму у Блоці коду 4-8, що використовує функцію <code>first_word</code> з Блоку коду 4-7.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to &quot;&quot;

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
</code></pre></pre>
<p><span class="caption">Блок коду 4-8: Збереження результату виклику функції <code>first_word</code> і наступна зміна вмісту стрічки</span></p>
<p>Ця програма компілюється без помилок, і також скомпілювалася б, якби ви використали <code>word</code> після виклику <code>s.clear()</code>. <code>word</code> ніяк не пов'язане зі станом <code>s</code>, і тому <code>word</code> міститиме значення <code>5</code>. Ми можемо використати це значення <code>5</code> зі змінною <code>s</code>, щоб спробувати видобути з неї перше слово, але це буде помилкою, бо вміст <code>s</code> змінився відколи ми зберегли <code>5</code> до <code>word</code>.</p>
<p>Необхідність дбати про актуальність індексу в <code>word</code> відносно даних в <code>s</code> нудна і може спровокувати помилки! Керування такими індексами стає ще більш ламким, якщо ми напишемо функцію <code>second_word</code>. Її сигнатура буде виглядати так:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Тепер ми відстежуємо початковий <em>і</em> кінцевий індекси, і ми маємо ще більше значень, обчислених з даних у конкретному стані, але ніяк не прив'язаних до цього стану. Тепер ми маємо три непов'язані змінні, підвішені в повітрі, які нам треба тримати синхронізованими.</p>
<p>На щастя, у Rust є розв'язання цієї проблеми: стрічкові слайси.</p>
<h3 id="Стрічкові-слайси"><a class="header" href="#Стрічкові-слайси">Стрічкові слайси</a></h3>
<p><em>Стрічковий слайс</em> - це посилання на частину <code>String</code>, і виглядає він так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<p>Замість того, щоб посилатися на всю <code>String</code>, <code>hello</code> посилається на частину <code>String</code>, указану у фрагменті <code>[0..5]</code>. Ми створюємо слайси за допомогою діапазону з квадратними дужками, вказуючи <code>[starting_index..ending_index]</code>, де <code>starting_index</code> - це перша позиція в слайсі, а <code>ending_index</code> - позиція на одну більша за останню позицію в слайсі. В середині структура даних слайсу насправді зберігає початкову позицію і довжину слайсу, що відповідає <code>ending_index</code> мінус <code>starting_index</code>. Тому в прикладі <code>let world = &amp;s[6..11];</code>, <code>world</code> буде слайсом, що складається зі вказівника на байт з індексом 6 у <code>s</code> і довжини <code>5</code>.</p>
<p>Рисунок 4-6 показує це у формі діаграми.</p>
<p><img alt="Три таблиці: таблиця, що відображає дані стеку з s, що вказує
на байт з індексом 0 у таблиці даних стрічки &quot;hellow world&quot; у
купі. Третій стіл представляє дані стеку слайсу world, який має значення
довжини 5 і вказує на байт 6 у таблиці даних купи."
src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Рисунок 4-6: стрічковий слайс, що посилається на частину <code>String</code></span></p>
<p>Синтаксис діапазонів <code>..</code> у Rust дозволяє, якщо ви хочете почати слайс на індексі 0, пропустити значення перед крапками. Іншими словами, ці рядки тотожні:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<p>Так само, якщо ваш слайс включає останній байт <code>String</code>, ви можете пропустити останнє число. Таким чином, ці рядки також тотожні:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<p>Також можна пропустити обидва значення, щоб взяти слайс з усієї стрічки. Це також тотожні рядки. Це також тотожні рядки:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Примітка: Індекси діапазону слайсу стрічки мають бути коректними границями символів UTF-8. Якщо ви спробуєте створити слайс стрічки посеред багатобайтового символу, ваша програма завершиться з помилкою. Заради ознайомлення зі слайсами стрічок, ми припускаємо в цьому розділі, що стрічка буде складатися лише з ASCII;  ретельніше обговорення обробки UTF-8 міститься в підрозділі <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“Зберігання тексту, кодованого в UTF-8, у стрічках”</a><!-- ignore --> Розділу 8.</p>
</blockquote>
<p>Враховуючи всю цю інформацію, перепишімо <code>first_word</code>, щоб вона повертала слайс. Тип, що позначає слайс стрічки, записується як <code>&amp;str</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Ми отримуємо індекс кінця слова тим же чином, що й у Блоці коду 4-7, пошуком першого стрічного пробілу. Коли ми знаходимо пробіл, ми повертаємо слайс стрічки за допомогою початку стрічки та індексу пробілу як початкового і кінцевого індексів.</p>
<p>Тепер при виклику <code>first_word</code> ми отримаємо одне значення, пов'язане з даними. Це значення складається з посилання на початкову точку слайсу і кількість елементів у ньому.</p>
<p>Повернення слайсу також спрацює для функції <code>second_word</code>:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Тепер ми маємо нехитрий API, з яким значно складніше потрапити в халепу, оскільки компілятор забезпечить коректність посилань на <code>String</code>. Пам'ятаєте помилку в програмі з Блоці коду 4-8, коли ми мали індекс кінця першого слова, але очистили стрічку, чим зробили наш індекс некоректним? Цей код мав логічну помилку, але не призводив до жодних негайних помилок. Проблеми з'явилися б надалі, якби ми спробували використовувати індекс першого слова з порожньою стрічкою. Слайси унеможливлюють цю помилку і дають знати про проблему в коді значно раніше. Використання слайсової версії <code>first_word</code> призведе до помилки під час компіляції:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!(&quot;the first word is: {}&quot;, word);
}
</code></pre>
<p>Ось текст помилки компілятора:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!(&quot;the first word is: {}&quot;, word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Пригадаємо, що за правилами позичання, якщо ми маємо немутабельне посилання на щось, ми не можемо робити мутабельне посилання на це ж. Оскільки <code>clear</code> має скоротити <code>String</code>, він намагається взяти мутабельне посилання. <code>println!</code> після виклику <code>clear</code> використовує посилання в <code>word</code>, так що немутабельне посилання все ще має бути активним в цій точці. Rust забороняє водночас мутабельне посилання в <code>clear</code> і немутабельне посилання у <code>word</code>, і компіляція зазнає невдачі. Rust не тільки робить наш API простішим у використанні, а ще й усуває під час компіляції цілий клас помилок!</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="string-literals-are-slices"></a></p>
<h4 id="Стрічкові-літерали-як-слайси"><a class="header" href="#Стрічкові-літерали-як-слайси">Стрічкові літерали як слайси</a></h4>
<p>Згадайте, що ми говорили про стрічкові літерали, збережені у двійковому файлі. Оскільки тепер ми вже знаємо про слайси, ми можемо як слід зрозуміти стрічкові літерали:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Типом <code>s</code> є <code>&amp;str</code>: це слайс, що вказує на конкретне місце у двійковому файлі. Це також є причиною, чому стрічкові літерали є немутабельними; <code>&amp;str</code> - немутабельне посиланням.</p>
<h4 id="Стрічкові-слайси-як-параметри"><a class="header" href="#Стрічкові-слайси-як-параметри">Стрічкові слайси як параметри</a></h4>
<p>Knowing that you can take slices of literals and <code>String</code> values leads us to one more improvement on <code>first_word</code>, and that’s its signature:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>A more experienced Rustacean would write the signature shown in Listing 4-9 instead because it allows us to use the same function on both <code>&amp;String</code> values and <code>&amp;str</code> values.</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of `String`s, whether partial or whole
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` also works on references to `String`s, which are equivalent
</span><span class="boring">    // to whole slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of string literals, whether partial or whole
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 4-9: Improving the <code>first_word</code> function by using a string slice for the type of the <code>s</code> parameter</span></p>
<p>Якщо у нас є слайс стрічки, ми можемо передати його прямо. Якщо у нас є <code>String</code>, ми можемо передати слайс цього <code>String</code> чи посилання на <code>String</code>. Ця гнучкість є можливою завдяки <em>приведенню при розіменуванні</em>, особливості, про яку ми розкажемо в підрозділі <a href="ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">“Неявні приведення при розіменуваннях у функціях та методах”</a><!--ignore--> Розділу 15.</p>
<p>Визначення функції, що приймає слайс стрічки замість посилання на <code>String</code> робить наш API більш загальним і корисним без втрати функціональності:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&amp;my_string);

    let my_string_literal = &quot;hello world&quot;;

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<h3 id="Інші-слайси"><a class="header" href="#Інші-слайси">Інші слайси</a></h3>
<p>Слайси стрічок, як можна зрозуміти, пов'язані зі стрічками. Але є також і більш загальний тип слайсів. Розгляньмо такий масив:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Так само як ми можемо захотіти послатися на частину стрічки, ми можемо захотіти послатися на частину масиву. Це робиться так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}
</span></code></pre></pre>
<p>Цей слайс має тип <code>&amp;[i32]</code>. Він працює тим же чином, що й слайси стрічок, зберігаючи посилання на перший елемент і довжину. Цей тип слайсів можна використовувати для всіх інших видів колекцій. Ми поговоримо про ці колекції детальніше, коли будемо обговорювати вектори в Розділі 8.</p>
<h2 id="Підсумок-3"><a class="header" href="#Підсумок-3">Підсумок</a></h2>
<p>Концепції власності, позичання і слайсів - це те, що гарантує безпеку роботи із пам'яттю в програмах на Rust під час компіляції. Мова Rust надає вам контроль над використанням пам'яті так само як і інші системні мови програмування, але те, що наявність власника даних автоматично призводить до очищення даних, коли власник виходить з області видимості, означає, що вам не треба писати і зневаджувати додатковий код, щоб отримати цей контроль.</p>
<p>Власність впливає на те, як працює велика кількість інших частин Rust, тому ми говоритимемо про ці концепції й надалі у цій книзі. Перейдімо далі до наступного розділу і погляньмо на групування окремих даних докупи в структури <code>struct</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Використання-struct-для-структурування-повязаних-даних"><a class="header" href="#Використання-struct-для-структурування-повязаних-даних">Використання struct для структурування пов'язаних даних</a></h1>
<p><em>struct</em>, або <em>структура</em> - це спеціальний тип даних, що дозволяє вам збирати в одну сутність зі спільною назвою декілька пов'язаних значень, що складають значущу групу. Якщо ви знайомі з якоюсь об'єктноорієнтованою мовою, <em>struct</em> - це як атрибути даних об’єкта. У цьому розділі ми порівняємо і покажемо різницю між кортежами та структурами, щоб було на що спертися у навчанні й продемонструємо, коли структури є кращим засобом для об'єднання даних.</p>
<p>Ми продемонструємо, як визначати і створювати структури. Ми обговоримо, як визначати асоційовані функції, особливо вид асоційованих функцій, що зветься <em>методами</em>, для визначення поведінки, пов’язаної із типом структури. Структури та енуми (про які йдеться в Розділі 6) є будівельними блоками для створення нових типів у вашій програмі, які дозволяють по повній скористатись перевіркою типів часу компіляції Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Визначення-і-створення-екземпляра-структури"><a class="header" href="#Визначення-і-створення-екземпляра-структури">Визначення і створення екземпляра структури</a></h2>
<p>Структури подібні до кортежів, про які ми говорили в підрозділі <a href="ch03-02-data-types.html#the-tuple-type">“Тип кортеж”</a><!--
ignore --> Розділу 3, бо обидва складаються з кількох пов'язаних значень. Як і у кортежах, частини структур можуть бути різних типів. На відміну від кортежів, у структурі ви називаєте кожен елемент даних, щоб було зрозуміло, що ці значення означають. Завдяки цим іменам структури гнучкіші за кортежі: ви не мусите покладатися на порядок даних, щоб визначати чи отримувати доступ до значень екземпляра.</p>
<p>Для визначення структури, ми вводимо ключове слово <code>struct</code> і називаємо всю структуру. Ім'я структури має описувати сенс групування цих елементів даних. Потім, у фігурних дужках, ми визначаємо імена і типи елементів даних, які звуться <em>полями</em>. Наприклад, Блок коду 5-1 показує структуру, що зберігає інформацію про обліковий запис користувача.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Блок коду 5-1: Визначення структури <code>User</code></span></p>
<p>Щоб скористатися структурою по визначенню, ми створюємо <em>екземпляр</em> цієї структури, визначаючи конкретні значення для кожного поля. Ми створюємо екземпляр, вказуючи назву структури, а потім додаємо фігурні дужки, що містять пари <em>ключ: значення</em>, де ключі - це імена полів, а значення - дані, які ми хочемо зберігати в цих полях. Поля не обов'язково вказувати у тому ж порядку, в якому вони були проголошені в структурі. Іншими словами, визначення структури - це загальний шаблон типу, а екземпляри заповнюють цей шаблон конкретними даними, щоб створити значення цього типу. Наприклад, ми можемо проголосити конкретного користувача, як показано в Блоці коду 5-2.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };
}
</code></pre></pre>
<p><span class="caption">Listing 5-2: Creating an instance of the <code>User</code> struct</span></p>
<p>Щоб отримати конкретне значення зі структури, використовують записом через точку. Якщо ми хочемо отримати адресу електронної пошти користувача, ми можемо написати <code>user1.email</code>. Якщо екземпляр є мутабельним, ми можемо змінити значення за допомогою запису через точку і присвоюванням конкретному полю. Блок коду 5-3 показує, як змінити значення поля <code>email</code> мутабельного екземпляра <code>User</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;anotheremail@example.com&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 5-3: Changing the value in the <code>email</code> field of a <code>User</code> instance</span></p>
<p>Зверніть увагу, що мутабельним має бути весь екземпляр; Rust не дозволяє позначати лише окремі поля як мутабельні. Як і з будь-яким виразом, ми можемо написати новий екземпляр останнім виразом у тілі функції, щоб неявно повернути цей новий екземпляр.</p>
<p>Блок коду 5-4 демонструє функцію <code>build_user</code>, що повертає екземпляр <code>User</code> зі встановленими адресою та ім'ям. Поле <code>active</code> отримує значення <code>true</code>, а <code>sign_in_count</code> - значення <code>1</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-4: A <code>build_user</code> function that takes an email and username and returns a <code>User</code> instance</span></p>
<p>Має сенс називати аргументи такої функції тими ж іменами, що й імена відповідних полів структури, але необхідність повторювати імена полів <code>email</code> та <code>username</code> утомлює. Якщо у структурі більше полів, повторення кожного імені дратує ще більше. На щастя, є зручне скорочення!</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a></p>
<h3 id="Скорочення-ініціалізації-полів"><a class="header" href="#Скорочення-ініціалізації-полів">Скорочення ініціалізації полів</a></h3>
<p>Оскільки назви параметрів та полів структури є абсолютно однаковими у Блоці коду 5-4, ми можемо використати синтаксис <em>скороченої ініціалізації полів</em> для переписування <code>build_user</code> так, щоб він поводився точно так само, але не містив повторення <code>username</code> і <code>email</code>, як показано у Блоці коду 5-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 5-5: функція <code>build_user</code>, що використовує скорочену ініціалізацію полів, бо параметри <code>username</code> і <code>email</code> мають такі самі назви, як і поля структури</span></p>
<p>Ми створюємо новий екземпляр структури <code>User</code>, яка має поле з назвою <code>email</code>. Ми хочемо встановити значення поля <code>email</code> у значення параметра <code>email</code> функції <code>build_user</code>. Оскільки поле <code>email</code> і параметр <code>email</code> мають одну назву, можна писати скорочено <code>email</code> замість <code>email: email</code>.</p>
<h3 id="Створення-екземплярів-з-інших-екземплярів-за-допомогою-синтаксису-оновлення-структур"><a class="header" href="#Створення-екземплярів-з-інших-екземплярів-за-допомогою-синтаксису-оновлення-структур">Створення екземплярів з інших екземплярів за допомогою синтаксису оновлення структур</a></h3>
<p>Часто буває корисним створити новий екземпляр структури, що бере більшу частину даних з екземпляра, що вже існує, проте деякі змінює. Ви можете зробити так за допомогою <em>синтаксису оновлення структури</em>.</p>
<p>Для початку, Блок коду 5-6 показує, як створити новий екземпляр <code>User</code>, що зветься <code>user2</code>, без синтаксису оновлення. Ми виставляємо нове значення поля <code>email</code>, проте решта полів використовує значення зі структури <code>user1</code>, створеної у Блоці коду 5-2.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from(&quot;another@example.com&quot;),
        sign_in_count: user1.sign_in_count,
    };
}
</code></pre></pre>
<p><span class="caption">Блок коду 5-6: Створення нового екземпляру <code>User</code> з деякими значеннями з <code>user1</code></span></p>
<p>Синтаксис оновлення структури дає той самий результат із меншою кількістю коду, як показано у Блоці коду 5-7. Запис <code>..</code> позначає, що решта полів, що їх не було явно виставлено, отримають ті значення, що були в заданому екземплярі.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        ..user1
    };
}
</code></pre></pre>
<p><span class="caption">Блок коду 5-7: використання синтаксису оновлення структури для встановлення нового значення <code>email</code> у екземплярі <code>User</code>, але використовуючи решту значень з <code>user1</code></span></p>
<p>Код у Блоці коду 5-7 також створює екземпляр <code>user2</code>, що має відмінне значення <code>email</code>, але має ті ж значення <code>username</code>, <code>active</code> та <code>sign_in_count</code>, що й <code>user1</code>. Запис <code>..user1</code> має бути останнім, щоб позначити, що решта полів отримають значення з відповідних полів у <code>user1</code>, але ми можемо зазначати значення для будь-якої кількості полів у будь-якому порядку, без урахування того, як вони йдуть у визначенні структури.</p>
<p>Зверніть увагу, що синтаксис оновлення структури використовує <code>=</code>, як при присвоєнні; це тому, що він переміщує дані, як показано в підрозділі <a href="ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move">&quot;Способи взаємодії змінних і даних: переміщення&quot;</a><!-- ignore --> . У цьому прикладі, ми більше не зможемо використовувати <code>user1</code> після створення <code>user2</code>, бо <code>String</code> з поля <code>username</code> структури <code>user1</code> було переміщено у <code>user2</code>. Якби ми надали <code>user2</code> нові значення типу <code>String</code> для обох <code>email</code> і <code>username</code> і таким чином використали тільки значення <code>active</code> і <code>sign_in_count</code> з <code>user1</code>, тоді <code>user1</code> все ще був би коректним після створення <code>user2</code>. Типи полів <code>active</code> і <code>sign_in_count</code> реалізовують трейт <code>Copy</code>, тому застосовується поведінка, яку ми обговорювали в підрозділі <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">&quot;Дані в стеку: копіювання&quot;</a><!-- ignore --> .</p>
<h3 id="Використання-структур-кортежів-без-названих-полів-для-створення-нових-типів"><a class="header" href="#Використання-структур-кортежів-без-названих-полів-для-створення-нових-типів">Використання структур-кортежів без названих полів для створення нових типів</a></h3>
<p>Rust також підтримує структури, які виглядають схожими на кортежі, що звуться <em>структури-кортежі</em> (tuple struct). Структури-кортежі надають значення структурі, бо мають назву, але не мають назв полів, тільки типи. Структури-кортежі корисні, коли ви хочете дати кортежу ім'я і зробити кортеж окремим типом, але називати кожне поле, як у звичайній структурі, буде надто багатослівним чи надмірним.</p>
<p>Щоб визначити структуру-кортеж, треба вказати ключове слово <code>struct</code> і ім'я структури, а потім типи в кортежі. Наприклад, ось визначення і приклади застосування двох структур-кортежів, що звуться <code>Color</code> і <code>Point</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
</code></pre></pre>
<p>Зауважте, що значення <code>black</code> та <code>origin</code> мають різні типи, бо вони є екземплярами різних структур-кортежів. Кожна визначена нами структура має свій власний тип, навіть якщо поля структур мають однакові типи. Наприклад, функція, що приймає параметр типу <code>Color</code>, не може прийняти аргументом <code>Point</code>, хоча обидва типи складаються з трьох значень <code>i32</code>. В іншому ж структури-кортежі поводяться як кортежі: ви можете деструктуризувати їх на окремі шматки, і ви можете використовувати <code>.</code> з індексом, щоб отримати доступ до окремого значення.</p>
<h3 id="Одинично-подібні-структури-без-полів"><a class="header" href="#Одинично-подібні-структури-без-полів">Одинично-подібні структури без полів</a></h3>
<p>Також можна визначати структури без жодних полів! Вони звуться <em>одинично-подібні структури</em> (unit-like struct), бо поводяться аналогічно до <code>()</code>, одничного типу, згаданого в підрозділі <a href="ch03-02-data-types.html#the-tuple-type">“Тип кортеж”</a><!-- ignore --> . Одинично-подібні структури можуть бути корисними в ситуаціях, коли вам потрібно реалізувати трейт на якомусь типі, але у вас немає потреби зберігати якісь дані в цьому типі. Про трейти ми поговоримо в Розділі 10. Ось приклад проголошення та створення одиничної структури під назвою <code>AlwaysEqual</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
</code></pre></pre>
<p>Щоб визначити <code>AlwaysEqual</code>, ми використовуємо ключове слово <code>struct</code>, назву структури та крапку з комою. Дужки не потрібні - ані звичайні, ані фігурні! Тоді ми можемо створити екземпляр з <code>AlwaysEqual</code> у змінній <code>subject</code> у схожий спосіб: використовуючи ім'я, яке ми визначили, без будь-яких - звичайних чи фігурних - дужок. Уявімо, що згодом ми реалізуємо поведінку для цього типу, так що кожен екземпляр <code>AlwaysEqual</code> завжди дорівнює будь-якому екземпляру будь-якого іншого типу, скажімо, щоб мати завжди відомий результат для тестування. Нам не потрібні жодні дані для реалізації такої поведінки! У Розділі 10 ви побачите, як визначити трейти і реалізувати їх на будь-якому типі, включно з одинично-подібними структурами.</p>
<blockquote>
<h3 id="Володіння-даними-структури"><a class="header" href="#Володіння-даними-структури">Володіння даними структури</a></h3>
<p>У структурі <code>User</code> з Блоку коду 5-1 ми використовували тип <code>String</code>, що має володіння, а не стрічковий слайс <code>&amp;str</code>. Це свідомий вибір, бо ми хочемо, щоб екземпляри цієї структури володіли всіма своїми даними і щоб ці дані були коректними, поки структури в цілому коректна.</p>
<p>Структура також може зберігати посилання на дані, якими володіє хтось інший, але це потребує використання <em>часу життя</em>, особливості Rust, що обговорюється у Розділі 10. Час життя гарантує, що дані, на які посилається структура, будуть коректними весь час існування структури. Наприклад, якщо ви спробуєте зберегти посилання у структурі без уточнення часу життя, ось так, то дістанете помилку:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: &quot;someusername123&quot;,
        email: &quot;someone@example.com&quot;,
        sign_in_count: 1,
    };
}
</code></pre>
<p>Компілятор поскаржиться, що потрібно зазначити час існування:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` due to 2 previous errors
</code></pre>
<p>In Chapter 10, we’ll discuss how to fix these errors so you can store references in structs, but for now, we’ll fix errors like these using owned types like <code>String</code> instead of references like <code>&amp;str</code>.</p>
</blockquote>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="Приклад-програми-що-використовує-структури"><a class="header" href="#Приклад-програми-що-використовує-структури">Приклад програми, що використовує структури</a></h2>
<p>Щоб зрозуміти, де можна використовувати структури, напишімо програму, що обчислює площу прямокутника. Почнемо з окремих змінних, а потім рефакторизуємо її так, щоб вона використовувала структури.</p>
<p>За допомогою Cargo створімо двійковий проєкт програми, що зветься <em>rectangles</em>, яка прийматиме ширину і висоту прямокутника в пікселях і обчислюватиме його площу. Блок коду 5-8 показує коротку очевидну програму, що робить саме те, що треба, у <em>src/main.rs</em> нашого проєкту.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre></pre>
<p><span class="caption">Listing 5-8: Calculating the area of a rectangle specified by separate width and height variables</span></p>
<p>Тепер запустимо програму командою <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
</code></pre>
<p>This code succeeds in figuring out the area of the rectangle by calling the <code>area</code> function with each dimension, but we can do more to make this code clear and readable.</p>
<p>Проблема в цьому коді очевидна, якщо поглянути на сигнатуру функції <code>area</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;The area of the rectangle is {} square pixels.&quot;,
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}
</span></code></pre>
<p>Функція <code>area</code> має обчислювати площу одного прямокутника, але функція, яку ми написали, приймає два параметри, і з коду зовсім не ясно, що ці параметри пов'язані. Для кращої читаності та керованості буде краще згрупувати ширину і висоту разом. Ми вже обговорювали один зі способів, як це зробити, у підрозділі <a href="ch03-02-data-types.html#the-tuple-type">&quot;Тип кортеж&quot;</a><!-- ignore --> Розділу 3: за допомогою кортежів.</p>
<h3 id="Рефакторизація-за-допомогою-кортежів"><a class="header" href="#Рефакторизація-за-допомогою-кортежів">Рефакторизація за допомогою кортежів</a></h3>
<p>Блок коду 5-9 показує версію нашої програми із кортежами.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<p><span class="caption">Listing 5-9: Specifying the width and height of the rectangle with a tuple</span></p>
<p>З одного боку, ця програма краща. Кортежі додають трохи структурованості, і тепер ми передаємо лише один аргумент. Але з іншого боку ця версія менш зрозуміла: кортежі не мають назв для своїх елементів, тому тепер доводиться індексувати частини кортежу, що робить наші обчислення менш очевидними.</p>
<p>Не має значення, якщо ми переплутаємо ширину і висоту при обчисленні площі, але якщо ми захочемо намалювати прямокутник на екрані, це матиме значення! Нам доведеться пам'ятати, що <code>ширина</code> має індекс <code>0</code> у кортежі, а <code>висота</code> має індекс <code>1</code>. Для когось іще буде ще складніше розібратися в цьому і пам'ятати, якщо він буде використовувати наш код. Оскільки ми не показали сенс наших даних у коді, тепер легше припускатися помилок.</p>
<h3 id="Рефакторизація-зі-структурами-додаємо-сенс"><a class="header" href="#Рефакторизація-зі-структурами-додаємо-сенс">Рефакторизація зі структурами: додаємо сенс</a></h3>
<p>Ми використовуємо структури, щоб додати сенс за допомогою &quot;ярликів&quot; до даних. Ми можемо перетворити наш кортеж на тип даних з іменами як для цілого, так і для частин, як показано в Блоці коду 5-10.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<p><span class="caption">Блок коду 5-10: визначення структури <code>Rectangle</code></span></p>
<p>Тут ми визначили структуру і назвали її <code>Rectangle</code>. Всередині фігурних дужок ми визначили поля <code>width</code> та <code>height</code>, обидва типу <code>u32</code>. Далі в <code>main</code> ми створюємо конкретний екземпляр <code>Rectangle</code> з шириною <code>30</code> і висотою <code>50</code>.</p>
<p>Наша функція <code>area</code> тепер має визначення з одним параметром, який ми назвали <code>rectangle</code>, тип якого - немутабельне позичення екземпляра структури <code>Rectangle</code>. Як ми вже казали в Розділі 4, ми можемо позичити структуру замість перебирати володіння ним. Таким чином <code>main</code> зберігає володіння і може продовжувати використовувати <code>rect1</code>, тому ми застосовуємо <code>&amp;</code> у сигнатурі функції та при її виклику.</p>
<p>Функція <code>area</code> звертається до полів <code>width</code> та <code>height</code> екземпляру <code>Rectangle</code> (зверніть увагу, що доступ до полів позиченого екземпляру структури не переміщує значення полів, ось чому ви часто бачитимете позичання структур). Сигнатура функції <code>area</code> тепер каже саме те, що ми мали на увазі: обчислити площу <code>Rectangle</code> за допомогою полів <code>width</code> та <code>height</code>. Це сповіщає, що ширина і висота пов'язані одна з іншою, і дає змістовні імена значенням замість індексів кортежу <code>0</code> та <code>1</code>. Це виграш для ясності.</p>
<h3 id="Додаємо-корисну-функціональність-успадкованими-трейтами"><a class="header" href="#Додаємо-корисну-функціональність-успадкованими-трейтами">Додаємо корисну функціональність успадкованими трейтами</a></h3>
<p>Було б непогано мати змогу виводити екземпляр нашого <code>Rectangle</code> при зневадженні програми та бачити значення його полів. Блок коду 5-11 намагається вжити <a href="../std/macro.println.html">макрос <code>println!</code></a><!-- ignore --> так само як це було в попередніх розділах. Але цей код не працює.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {}&quot;, rect1);
}
</code></pre>
<p><span class="caption">Listing 5-11: Attempting to print a <code>Rectangle</code> instance</span></p>
<p>Якщо скомпілювати цей код, ми дістанемо помилку із головним повідомленням:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>Макрос <code>println!</code> може виконувати багато різних видів форматувань, і за замовчанням фігурні дужки кажуть <code>println!</code> використати форматування, відоме як <code>Display</code>: вивести те, що призначене для читання кінцевим споживачем. Примітивні типи, з яким ми досі стикалися, реалізують <code>Display</code> за замовчанням, оскільки є лише один спосіб, яким можна показати <code>1</code> чи якийсь інший примітивний тип користувачу. Але зі структурами вже не настільки очевидно, як <code>println!</code> має форматувати вивід, оскільки є багато можливостей виведення: потрібні коми чи ні? Чи треба виводити фігурні дужки? Чи всі поля слід показувати? Через цю невизначеність, Rust не намагається відгадати, чого ми хочемо, і структури не мають підготовленої реалізації <code>Display</code>, яку можна було б використати у <code>println!</code> за допомогою заовнювача <code>{}</code>.</p>
<p>Якщо ми подивимося помилки далі, то знайдемо цю корисну примітку:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Спробуймо це зробити! Виклик макросу <code>println!</code> тепер виглядає так: <code>println!(&quot;rect1 = {:?}&quot;, rect1);</code>. Додавання специфікатора <code>:?</code> у фігурні дужки каже <code>println!</code>, що ми хочемо використати формат виведення, що зветься <code>Debug</code>. Трейт <code>Debug</code> дозволяє вивести нашу структуру у спосіб, зручний для розробників, щоб дивитися її значення під час зневадження коду.</p>
<p>Скомпілюймо змінений код. Трясця! Все одно помилка:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>Але знову компілятор дає нам корисну примітку:</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust <em>має</em> функціонал для виведення інформації для зневадження, та нам доведеться увімкнути його у явний спосіб, щоб зробити доступним для нашої структури. Щоб зробити це, додамо зовнішній атрибут <code>#[derive(Debug)]</code> прямо перед визначенням структури, як показано в Блоці коду 5-12.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">Listing 5-12: Adding the attribute to derive the <code>Debug</code> trait and printing the <code>Rectangle</code> instance using debug formatting</span></p>
<p>Now when we run the program, we won’t get any errors, and we’ll see the following output:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>Чудово! Це не найкрасивіший вивід, але він показує значення всіх полів цього екземпляру, що точно допоможе при зневадженні. Коли у нас будуть більші структури, корисно мати зручніший для читання вивід; в цих випадках, ми можемо використати <code>{:#?}</code> замість <code>{:?}</code> у стрічці <code>println!</code>. Якщо скористатися стилем <code>{:#?}</code> у цьому прикладі, вивід виглядатиме так:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Інший спосіб вивести значення у форматі <code>Debug</code> - скористатися <a href="../std/macro.dbg.html">макросом <code>dbg!</code></a><!-- ignore -->, який перебирає володіння виразом (на відміну від <code>println!</code>, що приймає посилання), виводить файл і номер рядка, де був у вашому коді викликаний макрос <code>dbg!</code> і обчислене значення виразу, і повертає володіння значенням.</p>
<blockquote>
<p>Примітка: виклик макроса <code>dbg!</code> виводить до стандартного потоку помилок у консолі (<code>stderr</code>), на відміну від <code>println!</code>, що виводить до стандартного потоку виводу консолі (<code>stdout</code>). Ми поговоримо більше про <code>stderr</code> і <code>stdout</code> у підрозділі <a href="ch12-06-writing-to-stderr-instead-of-stdout.html">&quot;Виведення повідомлень про помилки до стандартного потоку помилок замість стандартного вихідного потоку&quot; Розділу 12</a><!-- ignore -->.</p>
</blockquote>
<p>Here’s an example where we’re interested in the value that gets assigned to the <code>width</code> field, as well as the value of the whole struct in <code>rect1</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}
</code></pre></pre>
<p>Ми можемо написати <code>dbg!</code> навколо виразу <code>30 * scale</code> і, оскільки <code>dbg!</code> повертає володіння виразу, поле <code>with</code> отримає це саме значення, як ніби й не було виклику <code>dbg!</code>. Ми не хочемо, щоб <code>dbg!</code> перебирав володіння <code>rect1</code>, так що ми використовуємо посилання на <code>rect1</code> при наступному виклику. Ось як виглядає те, що виводить цей приклад:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>Ми бачимо що перший фрагмент був виведений з рядка 10 <em>src/main.rs</em>, де ми зневаджуємо вираз <code>30 * scale</code>, а його обчислене значення <code>60</code> (реалізація форматування <code>Debug</code> для цілих чисел виводить самі їхні значення). Виклик <code>dbg!</code> у рядку 14 <em>src/main. s</em> виводить значення <code>&amp;rect1</code>, яке дорівнює структурі <code>Rectangle</code>. Виведення використовує покращене форматування <code>Debug</code> для типу <code>Rectangle</code>. Макрос <code>dbg!</code> може бути дійсно корисним, коли ви намагаєтеся розібратися, що робить ваш код!</p>
<p>На додачу до трейту <code>Debug</code>, Rust надає нам ряд трейтів, що можна використовувати з атрибутом <code>derive</code>, які можуть додати корисну поведінку до наших власних типів. Ці трейти та їхня поведінка перераховані в <a href="appendix-03-derivable-traits.html">Додатку C</a><!--
ignore -->. Ми розглянемо, як реалізувати ці трейти з кастомізованою поведінкою і як створювати свої власні трейти в Розділі 10. Також існує багато атрибутів, відмінних від </p>
<p><code>derive</code>; для отримання додаткової інформації дивіться <a href="../reference/attributes.html">розділ &quot;Атрибути&quot; Довідника Rust</a>.</p>
<p>Функція <code>area</code> дуже конкретна: вона розраховує лише площу прямокутників. Було б корисно прив'язати цю поведінку до нашої структури <code>Rectangle</code>, оскільки вона не буде працювати з жодним іншим типом. Подивімося, як ми можемо продовжувати рефакторизовувати цей код, перетворивши функцію <code>area</code> на <em>метод</em> <code>area</code>, визначений на нашому типі <code>Rectangle</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Синтаксис-методів"><a class="header" href="#Синтаксис-методів">Синтаксис методів</a></h2>
<p><em>Методи</em> подібні до функцій: вони проголошуються ключовим словом <code>fn</code> і іменем, можуть мати параметри та повертати значення, і містять код, що виконується, коли їх викликають з іншого місця. На відміну від функцій, методи визначаються в контексті структури (або енума чи трейтового об'єкта, про які йтиметься в <a href="ch06-00-enums.html">Розділі 6</a><!-- ignore --> і <a href="ch17-02-trait-objects.html">Розділі 17</a><!-- ignore -->, відповідно), і їхній перший параметр - це завжди <code>self</code>, який представляє екземпляр структури, для якого викликається метод.</p>
<h3 id="Визначення-методів"><a class="header" href="#Визначення-методів">Визначення методів</a></h3>
<p>Let’s change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter and instead make an <code>area</code> method defined on the <code>Rectangle</code> struct, as shown in Listing 5-13.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p><span class="caption">Listing 5-13: Defining an <code>area</code> method on the <code>Rectangle</code> struct</span></p>
<p>Щоб визначити функцію в контексті <code>Rectangle</code>, ми починаємо блок <code>impl</code> (від implementation, &quot;реалізація&quot;) для <code>Rectangle</code>. Все в цьому блоці <code>impl</code> буде пов'язано з типом <code>Rectangle</code>. Потім ми переносимо функцію <code>area</code> до фігурних дужок після <code>impl</code> і замінюємо перший (а в цьому випадку єдиний) параметр на <code>self</code> у сигнатурі та повсюди в тілі. У <code>main</code>, де ми викликали функцію <code>area</code> і передавали аргументом <code>rect1</code>, тепер використаємо <em>синтаксис виклику метода</em>, щоб викликати метод <code>area</code> нашого екземпляра <code>Rectangle</code>. Синтаксис виклику методу записується після екземпляру: ми додаємо крапку, за якою - ім'я методу, дужки, і параметри, якщо такі є.</p>
<p>У сигнатурі <code>area</code> ми використовуємо <code>&amp;self</code> замість <code>rectangle: &amp;Rectangle</code>. <code>&amp;self</code> є насправді скороченням для <code>self: &amp;Self</code>. Усередині блоку <code>impl</code> тип <code>Self</code> є псевдонімом для типу, для якого призначено цей блок <code>impl</code>. Методи мусять мати перший параметр на ім'я <code>self</code> типу <code>Self</code>, тому Rust дозволяє вам скоротити це до лише імені <code>self</code> на місці першого параметра. Зверніть увагу, що нам все ще потрібно використовувати <code>&amp;</code> перед скороченням <code>self</code>, щоб вказати, що цей метод позичає екземпляр <code>Self</code>, так само як ми це зробили в <code>rectangle: &amp;Rectangle</code>. Методи можуть перебирати володіння над <code>self</code>, позичати <code>self</code> немутабельно, як у цьому випадку, чи позичати <code>self</code> мутабельно, як і будь-який інший параметр.</p>
<p>Ми обрали <code>&amp;self</code> з тих самих причин, що й <code>&amp;Rectangle</code> у версії з функцією: ми не хочемо брати володіння, ми хочемо просто читати дані структури, не писати їх. Якби ми хотіли змінити екземпляр, для якого викликали метод, десь у методі, то перший параметр мав би бути <code>&amp;mut self</code>. Методи, що беруть володіння над екземпляром за допомогою просто <code>self</code>, зустрічаються нечасто; ця техніка зазвичай використовується, коли метод перетворює <code>self</code> у щось інше і ми не хочемо, щоб оригінальний екземпляр використовувався після трансформації.</p>
<p>Основна перевага використання методів замість функцій, окрім використання синтаксису виклику метода та відсутності необхідності повторювати тип <code>self</code> у сигнатурі кожного метода - це організація коду. Ми збираємо все, що ми можемо зробити з екземпляром типа, в один блок <code>impl</code>, не примушуючи майбутніх користувачів нашого коду шукати можливостей використання <code>Rectangle</code> у різних місцях у нашій бібліотеці.</p>
<p>Зверніть увагу, що ми можемо вирішити назвати метод так само як зветься одне з полів структури. Наприклад, ми можемо визначити метод <code>Rectangle</code>, що також зватиметься <code>width</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(&quot;The rectangle has a nonzero width; it is {}&quot;, rect1.width);
    }
}
</code></pre></pre>
<p>Тут ми вирішили, що метод <code>width</code> має повертати <code>true</code>, якщо значення у полі екземпляра <code>width</code> більше за <code>0</code>, і <code>false</code>, якщо його значення <code>0</code>: ми можемо як завгодно використати поле в методі з тою самою назвою. У <code>main</code>, коли ми пишемо <code>rect1.width</code> з дужками, Rust знає, що ми маємо на увазі метод <code>width</code>. Коли ми не використовуємо дужки, Rust знає, що ми маємо на увазі поле <code>width</code>.</p>
<p>Часто, але не завжди, коли ми даємо методам ім'я, що має поле, ми хочемо, щоб цей метод лише повертав значення поля і більше нічого не робив. Такі методи називаються <em>ґеттерами</em>, і Rust не реалізує їх автоматично для полів структур, як деякі інші мови. Ґеттери є корисними, бо дозволяють зробити поле приватним, а метод публічним, і таким чином уможливити доступ лише для читання як частину публічного API цього типу. Ми поговоримо про публічне та приватне і як визначити поле чи метод публічим чи приватним у <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">Розділі 7</a><!-- ignore -->.</p>
<blockquote>
<h3 id="А-де-ж-оператор--"><a class="header" href="#А-де-ж-оператор--">А де ж оператор <code>-&gt;</code>?</a></h3>
<p>У C та C++ використовуються два різні оператори для виклику методів: <code>.</code>, якщо метод викликається для об'єкта безпосередньо, і <code>-&gt;</code>, якщо ви викликаєте метод для вказівника на об'єкт і спершу вказівник слід розіменувати. Іншими словами, якщо <code>object</code> - це вказівник, то <code>object-&gt;something()</code> робить те саме, що й <code>(*object).something()</code>.</p>
<p>Rust не має еквівалента оператора<code>-&gt;</code>; натомість, Rust має особливість, що зветься <em>автоматичне посилання і розіменування</em> (automatic referencing and dereferencing). Виклик методів - це одне з небагатьох місць у Rust з такою поведінкою.</p>
<p>Ось як це працює: коли ви викликаєте метод з  <code>object.something()</code>, Rust автоматично додає <code>&amp;</code>, <code>&amp;mut</code>, або <code>*</code>, щоб <code>object</code> відповідав сигнатурі методу. Іншими словами, наступними вирази означають одне й те саме:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>Але перший вираз є значно яснішим. Ці автоматичні посилання працюють, бо методи мають чітко заданого отримувача - тип  <code>self</code>. Знаючи отримувача і назву метода, Rust може однозначно з'ясувати, чи цей метод для читання  (<code>&amp;self</code>), змін (<code>&amp;mut self</code>) чи поглинання (<code>self</code>). Те, що Rust робить позичання неявним для отримувача метода є суттєвою частиною того, що робить володіння ергономічним на практиці.</p>
</blockquote>
<h3 id="Методи-з-більшою-кількістю-параметрів"><a class="header" href="#Методи-з-більшою-кількістю-параметрів">Методи з більшою кількістю параметрів</a></h3>
<p>Попрактикуймося використовувати методи, створивши другий метод для структури <code>Rectangle</code>. Цього разу ми хочемо, щоб екземпляр <code>Rectangle</code> прийняв інший екземпляр <code>Rectangle</code> і повернув <code>true</code>, якщо другий <code>Rectangle</code> може повністю поміститися в межах <code>self</code> (першого <code>Rectangle</code>); інакше він повинен повернути <code>false</code>. Тобто після визначення метода <code>can_hold</code>, ми хочемо мати можливість написати програму, показану в Блоці коду 5-14.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<p><span class="caption">Listing 5-14: Using the as-yet-unwritten <code>can_hold</code> method</span></p>
<p>Очікуване виведення буде виглядати наступним чином, оскільки обидва виміри <code>rect2</code> менші за розміри <code>rect1</code>, але <code>rect3</code> ширший, ніж <code>rect1</code>:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>Ми знаємо, що хочемо визначити метод, тож він буде написаний у блоці <code>impl  Rectangle</code>. Метод буде зватися <code>can_hold</code>, і буде приймати параметром немутабельне позичання іншого <code>Rectangle</code>. Ми можемо зрозуміти, якого типу буде параметр, подивившися на код, що викликає метод: <code>rect1.can_hold(&amp;rect2)</code> передає <code>&amp;rect2</code>`, тобто немутабельно позичає <code>rect2</code>, екземпляр <code>Rectangle</code>. Це зрозуміло, бо нам треба лише читати <code>rect2</code> (а не писати, бо тоді б було потрібне мутабельне позичання), і ми хочемо, щоб <code>main</code> залишав собі володіння <code>rect2</code>, щоб його можна було використовувати після виклику методі <code>can_hold</code>. Значення, що повертає <code>can_hold</code>, буде булевого типу, а реалізація перевірить, чи ширина та висота <code>self</code> більші за відповідно ширину та висоту іншого <code>Rectangle</code>. Додамо метод <code>can_hold</code> до блоку <code>impl</code> з Блоку коду 5-13, як показано в Блоці коду 5-15.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-15: Implementing the <code>can_hold</code> method on <code>Rectangle</code> that takes another <code>Rectangle</code> instance as a parameter</span></p>
<p>Коли ми запустимо цей код з функції <code>main</code> у Блоці коду 5-14, ми отримаємо вивід, який хотіли. Методи можуть приймати багато параметрів, які ми додаємо до сигнатури після параметру <code>self</code>, і ці параметри працюють так само як у функціях.</p>
<h3 id="Асоційовані-функції"><a class="header" href="#Асоційовані-функції">Асоційовані функції</a></h3>
<p>Усі функції, визначені в блоці <code>impl</code>, звуться <em>асоційованими функціями</em>, бо вони асоційовані з типом, названим після <code>impl</code>. Ми можемо визначити асоційовані функції, що не мають першим параметром <code>self</code> (і відтак не є методами), і вони не потребують екземпляра типа, щоб із ним працювати. Ми вже користалися такою асоційованою функцією, а саме функцією <code>String::from</code>, визначеною на типі <code>String</code>.</p>
<p>Асоційовані функції, що не є методами, часто використовуються як конструктори, що повертають новий екземпляр структури. Вони часто називаються <code>new</code>, але <code>new</code> не є спеціальним ім'ям і не вбудовано в мову. Наприклад, ми можемо написати асоційовану функцію <code>square</code>, що матиме один параметр розміру і використовуватиме його і як ширину, і як висоту, щоб створити таким чином квадратний <code>Rectangle</code>, не вказуючи одне й те саме значення двічі:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}
</span></code></pre></pre>
<p>The <code>Self</code> keywords in the return type and in the body of the function are aliases for the type that appears after the <code>impl</code> keyword, which in this case is <code>Rectangle</code>.</p>
<p>Щоб викликати асоційовану функцію, ми використовуємо запис <code>::</code> з іменем структури, наприклад <code>let sq = Rectangle::square(3);</code>. Ця функція включена до простору імен структури: запис <code>::</code> використовується і для асоційованих функцій, і для просторів імен, створених модулями. Ми будемо обговорювати модулі у <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">Розділі 7</a><!-- ignore -->.</p>
<h3 id="Кілька-однакових-блоків-impl"><a class="header" href="#Кілька-однакових-блоків-impl">Кілька однакових блоків <code>impl</code></a></h3>
<p>Кожна структура може мати кілька блоків <code>impl</code>. Наприклад, Блок коду 5-15 тотожний коду, показаному в Блоці коду 5-16, де кожен метод знаходиться у власному блоці <code>impl</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-16: Rewriting Listing 5-15 using multiple <code>impl</code> blocks</span></p>
<p>Тут немає підстав розділяти ці методи у декілька блоків <code>impl</code>, але це коректний синтаксис. Ми побачимо випадок, де кілька блоків <code>impl</code> можуть бути корисні, у Розділі 10, де ми поговоримо про узагальнені типи і трейти.</p>
<h2 id="Підсумок-4"><a class="header" href="#Підсумок-4">Підсумок</a></h2>
<p>Структури дозволяють вам створювати власні типи, що мають значення для предметної області програми. Використовуючи структури, ми можемо зберігати пов’язані між собою фрагменти даних разом і давати ім'я кожному фрагменту, щоб зробити наш код зрозумілим. У блоках <code>impl</code> ви можете визначити функції, асоційовані з вашим типом, а методи - це різновид асоційованих функцій, що дозволяють визначити поведінку, яку мають екземпляри ваших структур.</p>
<p>But structs aren’t the only way you can create custom types: let’s turn to Rust’s enum feature to add another tool to your toolbox.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Енуми-і-зіставлення-з-шаблоном"><a class="header" href="#Енуми-і-зіставлення-з-шаблоном">Енуми і зіставлення з шаблоном</a></h1>
<p>У цьому розділі ми розглянемо <em>перелічені типи</em> (enumeration), також відомі, як <em>енуми</em>. Енуми дозволяють вам визначити тип, перелічивши всі його можливі <em>варіанти</em>. Спершу ми визначимо і використаємо енум, щоб показати, як він кодує значення разом із даними. Далі, ми дослідимо особливо корисний енум, що зветься <code>Option</code>, який виражає, що значення може бути або чимось або нічим. Потім ми подивимося на те, як зіставлення з шаблоном у виразі <code>match</code> полегшує виконання різних кодів для різних значень енума. Нарешті, ми розкриємо, як конструкція <code>if let</code> зручно і дозволяє вам зручно та лаконічно використовувати енуми у вашому коді.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Визначення-enum-а"><a class="header" href="#Визначення-enum-а">Визначення enum-а</a></h2>
<p>Якщо структури надають спосіб групування пов'язаних полів і даних, як <code>Rectangle</code> з його <code>width</code> і <code>height</code>, то енуми дають вам спосіб виразити значення, що є одним з можливого набору значень. Скажімо, ми хочемо сказати, що <code>Rectangle</code> є однією з можливих фігур, які також включають <code>Circle</code>(круг) і <code>Triangle</code>(трикутник). Для цього Rust надає нам можливість закодувати ці варіанти у енум.</p>
<p>Розгляньмо ситуацію, яку ми можемо захотіти виразити в коді, і побачимо, чому енуми корисні і краще за структури підходять для цієї ситуації. Нехай нам потрібно працювати із IP-адресами. Наразі використовується два стандарти IP-адрес, четверта та шоста версії. Оскільки це єдині можливі IP-адреси, які наша програма може зустріти, ми можемо <em>перелічити</em> (enumerate) усі можливі варіанти, звідси й назва для енумів.</p>
<p>Будь-яка IP-адреса може бути або версії чотири, або версії шість, але не одночасно. Ця властивість IP-адрес робить енум відповідним засобом для вираження цієї ситуації, бо значення енума можуть бути лише одним із його варіантів. Адреси як четвертої, так і шостої версій засадничо є саме IP-адресами, і з ними можна працювати як з одним типом, коли код стосується ситуацій, де можуть використовуватися обидва види адрес.</p>
<p>Цю концепцію можна виразити, визначивши енум <code>IpAddrKind</code> і перерахувавши можливі види IP-адрес, <code>V4</code> та <code>V6</code>. Це зветься варіантами енума:</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p><code>IpAddrKind</code> тепер є користувацьким типом даних, яким ми можемо користуватися деінде в нашому коді.</p>
<h3 id="Значення-енума"><a class="header" href="#Значення-енума">Значення енума</a></h3>
<p>Ми можемо створити екземпляри обох варіантів <code>IpAddrKind</code> таким чином:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>Зверніть увагу, що варіанти енума знаходяться у просторі імен його ідентифікатора, і для з'єднання ми використовуємо подвійну двокрапку. Це корисно, бо значення <code>IpAddrKind::V4</code> і <code>IpAddrKind::V6</code> належать до одного типу <code>IpAddrKind</code>. Тепер можна, скажімо, визначити функцію, що приймає <code>IpAddrKind</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}
</code></pre></pre>
<p>І ми можемо викликати цю функцію для будь-якого з варіантів:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>Але використання enum-ів дає ще більше переваг. Наразі ми не маємо способу зберігати власне <em>дані</em> IP-адреси; ми знаємо лише її <em>вид</em>. Оскільки ви щойно дізналися про структури в Розділі 5, у вас може виникнути спокуса розв'язати цю проблему структурами, як показано у Блоці коду 6-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from(&quot;127.0.0.1&quot;),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from(&quot;::1&quot;),
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-1: Storing the data and <code>IpAddrKind</code> variant of an IP address using a <code>struct</code></span></p>
<p>Тут ми визначили структуру <code>IpAddr</code>, що має два поля: <code>kind</code> (вид) типу <code>IpAddrKind</code> (щойно визначений нами енум) та <code>address</code> типу <code>String</code>. Ми маємо два екземпляри цієї структури. Перший, <code>home</code>, має значення <code>IpAddrKind::V4</code> в полі <code>kind</code> і прив'язані дані адреси <code>127.0.0.1</code>. Другий екземпляр, <code>loopback</code>, має значенням поля <code>kind</code> інший варіант <code>IpAddrKind</code> - <code>V6</code>, і має прив'язану адресу <code>::1</code>. Ми використали структуру, щоб пов'язати значення <code>kind</code> та <code>address</code> разом, таким чином варіант тепер прив'язаний до значення.</p>
<p>Але цю концепцію можна представити у коротший спосіб за допомогою самого енума, а не енума всередині структури, розмістивши дані безпосередньо в кожному варіанті енума. Це нове визначення енума <code>IpAddr</code> каже, що обидва варіанти <code>V4</code> та <code>V6</code> мають прив'язані значення <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>Ми причепили дані безпосередньо до кожного варіанту енума, і тепер нема потреби в додатковій структурі. Тепер легше побачити ще одну деталь роботи енумів: назва кожного варіанту енума, визначеного нами, стає також функцією, що конструює екземпляр енума. Тобто <code>IpAddr::V4()</code> - це виклик функції, що приймає аргументом <code>String</code> і повертає екземпляр типу <code>IpAddr</code>. Ми автоматично отримуємо функцію-конструктор, визначену в результаті визначення енума.</p>
<p>Є ще одна перевага у використанні енума перед структурою: кожен варіант може мати різні типи та об'єм прив'язаних даних. IP-адреси четвертої версії завжди складаються з чотирьох числових компонентів зі значеннями між 0 та 255. Якби ми хотіли зберігати адреси <code>V4</code> як чотири значення <code>u8</code>, але все ще представляти <code>V6</code> як єдине значення типу <code>String</code>, то структурою ми б цього зробити не змогли. Натомість енуми легко впораються із цим:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>Ми представили кілька різних способів визначення структури даних для зберігання IP-адрес версій чотири та шість. Однак, як виявляється, бажання зберігати IP-адреси і кодувати їхній вид настільки поширене, що <a href="../std/net/enum.IpAddr.html">стандартна бібліотека вже містить визначення, яке можна використати!</a><!-- ignore --> Подивімося, як стандартна бібліотека визначає <code>IpAddr</code>: там є точно такий enum і варіанти, як і ті, що ми визначили, але дані адрес усередині варіантів представлені двома різними структурами, які визначені окремо для кожного варіанту:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<p>Цей код показує, що ми можемо помістити будь-який вид даних усередину варіанту енума: стрічки, числові типи, структури тощо. Можна навіть вкласти інший енум! Також типи стандартної бібліотеки часто не набагато складніші за те, що ви б могли самі придумати.</p>
<p>Зверніть увагу, що хоча стандартна бібліотека містить визначення <code>IpAddr</code>, ми можемо створити і користуватися нашим власним визначенням без конфлікту, бо ми не ввели визначення зі стандартної бібліотеки до області видимості програми. Ми ще поговоримо про введення до області видимості в Розділі 7.</p>
<p>Let’s look at another example of an enum in Listing 6-2: this one has a wide variety of types embedded in its variants.</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 6-2: A <code>Message</code> enum whose variants each store different amounts and types of values</span></p>
<p>Цей енум має чотири варіанти різних типів:</p>
<ul>
<li><code>Quit</code> (&quot;вийти&quot;) не має пов'язаних даних.</li>
<li><code>Move</code> (&quot;перейти&quot;) має всередині анонімний struct.</li>
<li><code>Write</code> (&quot;написати&quot;) включає один <code>String</code>.</li>
<li><code>ChangeColor</code> (&quot;змінити колір&quot;) включає три значення <code>i32</code>.</li>
</ul>
<p>Визначення енума з варіантами, схожими на наведені у Блоці коду 6-2, нагадує визначення різних видів структур, але енум не використовує ключового слова <code>struct</code> і всі варіанти згруповані разом в одному типі <code>Message</code>. Наступні структури могли б зберігати ті самі дані, що й варіанти попереднього енума:</p>
<pre><pre class="playground"><code class="language-rust">struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Але якби ми використали різні структури, кожна з яких має свій тип, ми не змогли визначити функцію, яка б приймала будь-який з цих типів повідомлень, як можна робити з енумом <code>Message</code>, визначеним у Блоці коду 6-2, що є одним типом.</p>
<p>Енуми та структури мають ще одну спільну рису: як за допомогою <code>impl</code> ми можемо оголошувати методи на структурах, ми можемо так само їх оголошувати на енумах. Ось метод, що зветься <code>call</code>, який можна визначити на нашому енумі <code>Message</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from(&quot;hello&quot;));
    m.call();
<span class="boring">}
</span></code></pre></pre>
<p>Тіло методу використає <code>self</code>, щоб отримати значення, для кого було викликано метод. У цьому прикладі ми створили змінну <code>m</code>, що має значення <code>Message::Write(String::from(&quot;hello&quot;))</code>, і саме цей <code>self</code> буде в тілі методу <code>call</code>, коли буде виконано <code>m.call()</code>.</p>
<p>Let’s look at another enum in the standard library that is very common and useful: <code>Option</code>.</p>
<h3 id="Енум-option-і-його-переваги-над-null-значеннями"><a class="header" href="#Енум-option-і-його-переваги-над-null-значеннями">Енум <code>Option</code> і його переваги над null-значеннями</a></h3>
<p>Цей підрозділ розглядає використання <code>Option</code>, ще одного енума, визначеного в стандартній бібліотеці. Тип <code>Option</code> кодує дуже поширену ситуацію, де значення може бути чи його може не бути.</p>
<p>Наприклад, якщо ви запитуєте перший елемент з непорожнього списку, ви отримаєте значення. Якщо ж ви запитаєте перший елемент порожнього списку, ви не отримаєте нічого. Те, що ця концепція виражена в системі типів, означає, що компілятор може перевірити, що ви обробили всі можливі варіанти, які потребують обробки; цей функціонал запобігає вкрай поширеним в інших мовах програмування вадам.</p>
<p>Дизайн мови програмування часто оцінюють за тим, який функціонал у ній є; але функціонал, який свідомо уникли, також важливий. Rust не має такої особливості, як null, що є в багатьох інших мовах. <em>Null</em> - це значення, що означає відсутність значення. У мовах із null змінні завжди можуть бути в одному з двох станів: null і не-null.</p>
<p>In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony Hoare, the inventor of null, has this to say:</p>
<blockquote>
<p>Я називаю це своєю помилкою на мільярд доларів. У той час я розробляв першу всеосяжну систему типів для посилань в об'єктноорієнтованій мові. Моєю метою було переконатися, що всі використання посилань будуть абсолютно безпечними, з автоматичною перевіркою компілятором. Але я не міг опиратися спокусі додати нульове посилання просто тому, що його було так легко реалізувати. Це призвело до незлічених помилок, вразливостей і системних збоїв, які, мабуть, коштували мільярд доларів болю і шкоди за останні 40 років.</p>
</blockquote>
<p>Проблема з null-значеннями полягає в тому, що якщо ви спробуєте використовувати значення, яке є null, ніби це не null, ви дістанете помилку. А оскільки ця властивість є поширеною, стає неймовірно просто помилитися таким чином.</p>
<p>However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.</p>
<p>Проблема насправді не в самій концепції, а в конкретній реалізації. Відтак Rust не має null-значень, але має енум, що представляє концепцію присутнього чи відсутнього значення. Цей енум - <code>Option&lt;T&gt;</code>, і він <a href="../std/option/enum.Option.html">визначений у стандартній бібліотеці</a><!-- ignore -->
ось так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
  None,
  Some(T),
}
<span class="boring">}
</span></code></pre></pre>
<p>Enum <code>Option&lt;T&gt;</code> настільки корисний, що він включений у прелюдію; вам не потрібно явно вводити його в область видимості програми. Його варіанти також введені у прелюдію: ви можете використовувати <code>Some</code> та <code>None</code> напряму без префіксу <code>Option::</code>. Утім <code>Option&lt;T&gt;</code> - це лише звичайний енум, а <code>Some(T)</code> та <code>None</code> - лише варіанти типу <code>Option&lt;T&gt;</code>.</p>
<p>Запис <code>&lt;T&gt;</code> - особливість Rust, про яку ми ще не говорили. Це параметр узагальненого типу, і детальніше ми розглянемо узагальнення в Розділі 10. Поки що все, що вам слід знати - що <code>&lt;T&gt;</code> означає, що варіант <code>Some</code> енума <code>Option</code> може вміщати одне значення даних будь-якого типу, і що конкретний тип, підставлений на місце <code>T</code>, робить весь вираз <code>Option&lt;T&gt;</code> окремим типом. Ось деякі приклади використання значень <code>Option</code> для зберігання числових типів і стрічкових типів:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p>Тип <code>some_number</code> - <code>Option&lt;i32&gt;</code>. Типом <code>some_char</code> є <code>Option&lt;char&gt;</code>, тобто інший тип. Rust може вивести ці типи, бо ми вказали значення всередині варіанту <code>Some</code>. А для <code>absent_number</code> Rust вимагає, щоб ми анотували весь тип <code>Option</code>: компілятор не може вивести тип відповідного варіанту <code>Some</code>, що міститиме значення, за самим лише значенням <code>None</code>. Тут ми вказуємо Rust, що хочемо, аби <code>absent_number</code> мав тип <code>Option&lt;i32&gt;</code>.</p>
<p>Коли у нас є значення <code>Some</code>, ми знаємо, що значення наявне, і значення зберігається в варіанті <code>Some</code>. Коли є значення <code>None</code>, у певному сенсі, це означає те саме, що й null: ми не маємо придатного значення. То чим же <code>Option&lt;T&gt;</code> кращий за значення null?</p>
<p>Одним словом, оскільки <code>Option&lt;T&gt;</code> і <code>T</code> (де <code>T</code> може бути будь-яким типом) - різні типи, компілятор не дозволить нам використовувати значення <code>Option&lt;T&gt;</code> так, ніби ми маємо коректне значення. Наприклад, цей код не скомпілюється, бо він намагається додати <code>i8</code> до <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}
</span></code></pre>
<p>Якщо ми запустимо цей код, ми дістанемо повідомлення про помилку на кшталт цього:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
</code></pre>
<p>Сильно! Насправді це повідомлення про помилку означає, що Rust не розуміє, як додати <code>i8</code> та <code>Option&lt;i8&gt;</code>, оскільки вони різних типів. Коли у нас у Rust є значення типу на кшталт <code>i8</code>, компілятор гарантує, що у нас завжди є коректне значення. Ми можемо діяти впевнено без потреби у перевірці на null перш ніж використовувати це значення. Тільки тоді, коли у нас є <code>Option&lt;i8&gt;</code> (або будь-який тип чи значення, з яким ми працюємо), ми маємо турбуватися про те, що, можливо, значення не буде, і компілятор переконається, що ми обробляємо цей випадок, перш ніж використовувати значення.</p>
<p>Іншими словами, перед тим, як виконувати операції, які можна робити з <code>T</code>, треба перетворити значення <code>Option&lt;T&gt;</code> на <code>T</code>. В цілому це допомагає перехопити одну з найпоширеніших проблем із null - припущення, що щось не є null, коли насправді воно null.</p>
<p>Відсутність потреби турбуватися про некоректне припущення про не-null значення допомагає вам бути певнішим у власному коді. Щоб значення могло бути null, вам треба явно це вказати зробивши тип цього значення <code>Option&lt;T&gt;</code>. Потім, коли ви використовуєте це значення, від вас вимагається явно обробити випадок, коли це значення null. Всюди, де значення має тип, відмінний від <code>Option&lt;T&gt;</code>, ви <em>можете</em> безпечно припустити, що це значення не null. Це свідоме рішення при розробці Rust для обмеження передавання null і збільшення безпеки коду Rust.</p>
<p>Але як же отримати значення <code>T</code> з варіанту <code>Some</code>, коли ви маєте значення типу <code>Option&lt;T&gt;</code>, щоб його використати? Енум <code>Option&lt;T&gt;</code> має велику кількість методів, зручних у різноманітних ситуаціях; ви можете подивитися їх у <a href="../std/option/enum.Option.html"> документації</a><!-- ignore -->. Ознайомлення з методами <code>Option&lt;T&gt;</code> буде вкрай корисним для вашого вивчення Rust.</p>
<p>В цілому, щоб скористатися значенням <code>Option&lt;T&gt;</code>, ми хочемо мати код, що обробить обидва варіанти. Ми хочемо, щоб певний код виконувався лише для значень <code>Some(T)</code>, і цей код міг використовувати внутрішнє <code>T</code>. І ми хочемо, щоб інший код виконувався лише коли ми маємо значення <code>None</code>, і цей код не має доступу до значення <code>T</code>. Вираз <code>match</code> - це конструкція управління, що саме це й робить, коли використовується з енумами: воно виконає різний код залежно від варіанту енума, і цей код може використовувати дані всередині відповідного значення.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="the-match-control-flow-operator"></a></p>
<h2 id="Конструкція-управління-match"><a class="header" href="#Конструкція-управління-match">Конструкція управління <code>match</code></a></h2>
<p>Rust має вкрай потужну конструкцію управління, що зветься <code>match</code>, яка дозволяє нам порівнювати значення із кількома шаблонами та потім виконати код, виходячи з того, який шаблон відповідає цьому значенню. Шаблони можуть складатися з літералів, імен змінних, символів узагальнення і багатьох інших речей; <a href="ch18-00-patterns.html">Розділ 18</a><!-- ignore --> розповідає про всі різні види шаблонів і що вони роблять. Потужність <code>match</code> походить від виразності шаблонів і того факту, що компілятор перевіряє, щоб усі можливі ситуації були оброблені.</p>
<p>Вираз <code>match</code> можна уявити собі як сортувальну машину для монет: монети ковзають жолобом з отворами різних розмірів, і кожна монета падає крізь перший отвір, в який вона проходить. Так само значення проходить крізь кожен шаблон в <code>match</code>, і на першому шаблоні, якому воно відповідає, значення &quot;провалюється&quot; в пов'язаний блок коду, де може бути використане при його виконанні.</p>
<p>Оскільки ми згадали монети, використаємо їх як приклад використання <code>match</code>! Ми можемо написати функцію, що приймає невідому монету США і, так само як і лічильна машина, визначає, яка це монета і повертає її значення в центах, як показано в Блоці коду 6-3.</p>
<pre><pre class="playground"><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 6-3: An enum and a <code>match</code> expression that has the variants of the enum as its patterns</span></p>
<p>Розберімо <code>match</code> у функції <code>value_in_cents</code>. По-перше, ми пишемо ключове слово <code>match</code>, за яким іде вираз, у цьому випадку - значення <code>coin</code>. Це дуже схоже на вираз, що використовується в <code>if</code>, але є велика відмінність: в <code>if</code> вираз має повертати булеве значення, а тут значення може бути будь-якого типу. Тип <code>coin</code> у цьому прикладі - енум <code>Coin</code>, який ми визначили у першому рядку.</p>
<p>Далі йдуть рукави <code>match</code>. Рукав має дві частини: шаблон і код. Перший рукав має шаблон, що є значенням <code>Coin::Penny</code>, після чого оператор <code>=&gt;</code> відокремлює шаблон і код, що буде виконано. Код у цьому випадку - просто значення <code>1</code>. Кожен рукав відокремлений від наступного комою.</p>
<p>Коли виконується вираз <code>match</code>, значення по черзі порівнюється із шаблоном кожного рукава. Якщо шаблон відповідає значенню, виконується пов'язаний із цим шаблоном код. Якщо шаблон не відповідає значенню, виконання передається наступному рукаву, як монетка в сортувальній машині. Рукавів може бути стільки, скільки нам потрібно: у Блоці коду 6-3 <code>match</code> має чотири рукави.</p>
<p>Код, пов'язаний з кожним рукавом, є виразом, і кінцеве значення виразу у відповідному рукаві є значенням, яке повертається для всього виразу <code>match</code>.</p>
<p>Фігурні дужки зазвичай не використовуються, якщо код рукава match невеликий, як у Блоці коду 6-3, де кожен рукав просто повертає значення. Якщо ви хочете виконати багато рядків коду у рукаві match, то маєте скористатися фігурними дужками, кома після яких в такому разі не обов'язкова. Наприклад, наступний код виводитиме “Lucky penny!” кожного разу, коли метод викличуть для <code>Coin::Penny</code>, але також поверне останнє значення блоку, тобто <code>1</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3 id="Шаблони-які-привязуються-до-значень"><a class="header" href="#Шаблони-які-привязуються-до-значень">Шаблони, які прив’язуються до значень</a></h3>
<p>Інша корисна властивість рукавів match полягає в тому, що вони можуть зв'язуватися з частинами значення, що відповідає шаблону. Таким чином ми можемо дістати значення з варіантів енумів.</p>
<p>Наприклад, змінімо один з варіантів енума, щоб він мав дані усередині. З 1999 по 2008 роки Сполучені Штати карбували четвертаки з різними дизайнами для кожного з 50 штатів на одному боці. Інші монети не мають окремих дизайнів для штатів, тому лише четвертаки мають таке додаткове значення. Ми можемо додати цю інформацію до нашого <code>енума</code>, змінивши варіант <code>Quarter</code>, аби він містив у собі значення <code>UsState</code>, що й зроблено в Блоці коду 6-4.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 6-4: A <code>Coin</code> enum in which the <code>Quarter</code> variant also holds a <code>UsState</code> value</span></p>
<p>Уявімо, що наш друг намагається зібрати всі 50 четвертаків різних штатів. Сортуючи дріб'язок по типах монет, ми також будемо називати назви штатів, пов'язаних з кожним четвертаком, щоб, якщо такого наш друг такого не має, він зміг би додати його до своєї колекції.</p>
<p>У виразі match у цьому коді ми додаємо змінну, що зветься <code>state</code> до шаблону, що відповідає значенню варіанту <code>Coin::Quarter</code>. Коли шаблон <code>Coin::Quarter</code> буде відповідним до виразу, змінна <code>state</code> зв'яжеться зі значенням штату цього четвертака. Тоді ми можемо використати <code>state</code> у коді цього рукава, ось так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}
</span></code></pre></pre>
<p>Якщо ми викличемо <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, значення <code>coin</code> буде <code>Coin::Quarter(UsState::Alaska)</code>. Коли ми порівняємо це значення з усіма рукавами, то не підійде жоден, поки ми не дістанемося <code>Coin::Quarter(state)</code>. У цьому місці <code>state</code> буде зв'язане зі значенням <code>UsState::Alaska</code>. Ми зможемо тоді скористатися цим зв'язуванням у виразі <code>println!</code>, отримавши таким чином внутрішнє значення штату з енума <code>Coin</code> для варіанту <code>Quarter</code>.</p>
<h3 id="Зіставлення-з-optiont"><a class="header" href="#Зіставлення-з-optiont">Зіставлення з <code>Option&lt;T&gt;</code></a></h3>
<p>У попередньому підрозділі ми хотіли дістати внутрішнє значення типу <code>T</code> з варіанту <code>Some</code>, коли працювали з <code>Option&lt;T&gt;</code>; з <code>Option&lt;T&gt;</code> ми теж можемо скористатися конструкцією <code>match</code>, так само як робили з енумом <code>Coin</code>! Замість монет ми порівнюватимемо варіанти <code>Option&lt;T&gt;</code>, але вираз <code>match</code> при цьому працює тим самим чином.</p>
<p>Хай, скажімо, ми хочемо написати функцію, що приймає <code>Option&lt;i32&gt;</code>, і якщо він містить значення, додає один до цього значення. А якщо там немає значення всередині, функція має повертати значення <code>None</code> і не намагатися виконати жодних дій.</p>
<p>This function is very easy to write, thanks to <code>match</code>, and will look like Listing 6-5.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-5: A function that uses a <code>match</code> expression on an <code>Option&lt;i32&gt;</code></span></p>
<p>Розгляньмо детальніше перше виконання <code>plus_one</code>. Коли ми викликаємо <code>plus_one(five)</code>, змінна <code>x</code> у тілі <code>plus_one</code> матиме значення <code>Some(5)</code>. Далі ми порівнюємо це значення з кожним рукавом match:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p>Значення <code>Some(5)</code> не відповідає шаблону <code>None</code>, тому ми переходимо до наступного рукава:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p>Чи відповідає <code>Some(5)</code> шаблону <code>Some(i)</code>? Так! Ми маємо той самий варіант. Змінна <code>i</code> зв'язується зі значенням, що міститься в <code>Some</code>, тобто <code>i</code> набуває значення <code>5</code>. Далі виконується код у рукаві match, тобто додається один до значення <code>i</code> і створюється нове значення <code>Some</code> із результатом <code>6</code> всередині.</p>
<p>Тепер розгляньмо другий виклик <code>plus_one</code> у Блоці коду 6-5, де <code>x</code> дорівнює <code>None</code>. Ми входимо в <code>match</code> і порівнюємо перший рукав:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p>Підходить! Немає значення, до якого треба додавати, і програма зупиняється і повертає значення <code>None</code>, що стоїть праворуч від <code>=&gt;</code>. Оскільки перший рукав відповідає значенню, решта рукавів не перевіряються.</p>
<p>Комбінування <code>match</code> і енумів корисне в багатьох ситуаціях. Ви часто бачитимете цей шаблон у коді Rust: <code>match</code> із енумом, зв'язування змінної з даними усередині, і виконання коду відповідно до цього. Це спершу трохи мудровано, але щойно ви звикнете до цього, то бажатимете мати таку конструкцію в усіх мовах. Ця конструкція - незмінний улюбленець користувачів Rust.</p>
<h3 id="match-вимагає-вичерпності"><a class="header" href="#match-вимагає-вичерпності">Match вимагає вичерпності</a></h3>
<p>Є ще один бік <code>match</code>, що ми маємо обговорити: шаблони рукавів мають покривати всі можливості. Розгляньте таку версію нашої функції <code>plus_one</code>, в якій є вада і вона не скомпілюється:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p>Ми не обробили варіанту <code>None</code>, тому цей код призводить до вади. На щастя, Rust знає, як виявляти такі вади. Якщо ми спробуємо скомпілювати цей код, то отримаємо таке повідомлення про помилку:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
note: `Option&lt;i32&gt;` defined here
    = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
    |
4   ~             Some(i) =&gt; Some(i + 1),
5   ~             None =&gt; todo!(),
    |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
</code></pre>
<p>Rust знає, що ми не покрили усі можливі випадки, і навіть знає, який саме шаблон ми забули! Match в Rust <em>вичерпні</em>: ми маємо вичерпати всі можливі ситуації, щоб код був коректним. Особливо у випадку з <code>Option&lt;T&gt;</code>, коли Rust, запобігаючи тому, щоб ми забули явно обробити випадок <code>None</code>, захищає нас від припущення, що ми маємо значення, коли ми можемо мати null, таким чином припускаючись помилки на мільярд доларів, про яку ми говорили вище.</p>
<h3 id="Шаблони-для-всіх-випадків-і-заповнювач-_"><a class="header" href="#Шаблони-для-всіх-випадків-і-заповнювач-_">Шаблони для всіх випадків і заповнювач <code>_</code></a></h3>
<p>При роботі з енумами нам може знадобитися особлива дія для кількох конкретних значень, а для всіх інших значень - одна дія за замовчуванням. Уявіть, що ми розробляємо гру, де, якщо ви викинули 3 на кубику, ваш гравець не рухається, а отримує нового модного капелюха. Якщо ви викинете 7, ваш гравець втратить модного капелюха. Для всіх інших значень, ваш гравець рухається на цю кількість клітинок на ігровому полі. Ось <code>match</code>, що реалізовує цю логіку, де результат кидання кубика жорстко задано замість випадкового значення, і решта логіки представлена функціями без тіл, бо ми насправді реалізуємо їх поза областю видимості цього прикладу:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}
</span></code></pre></pre>
<p>У перших двох рукавів шаблони - літерали зі значеннями <code>3</code> і <code>7</code>. У останнього рукава, що покриває всі інші можливі значення. шаблон - це змінна, яку ми вирішили назвати <code>other</code>. Код, що виконується в цьому рукаві, використовує змінну <code>other</code>, передаючи її у функцію <code>move_player</code>.</p>
<p>Цей код компілюється, хоча ми не перерахували усі можливі значення, яких може набути <code>u8</code>, бо останній шаблон відповідає всім значенням, які не були вказані окремо. Цей шаблон для всіх випадків задовольняє вимозі вичерпності <code>match</code>. Зверніть увагу, що шаблон для всіх випадків розміщується останнім, бо шаблони обчислюються послідовно. Якщо ми розмістимо рукав для всіх випадків раніше, решта рукавів ніколи не запустяться, тому Rust попередить нас, якщо ми після нього додамо ще рукави!</p>
<p>Rust також має шаблон, яким можна скористатися, коли нам потрібно обробити всі випадки, але ми не хочемо <em>використовувати</em> значення у шаблоні для всіх випадків: <code>_</code> є спеціальним шаблоном, що відповідає будь-якому значенню і не зв'язується із цим значенням. Це каже Rust, що ми не збираємося використовувати це значення, і тому він не попереджатиме про невикористану змінну.</p>
<p>Змінімо правила гри: тепер, якщо ви викинете щось, крім 3 чи 7, то маєте кидати кубик знову. Нам більше не потрібне значення для всіх випадків, тож ми можемо змінити наш код і скористатися <code>_</code> замість змінної на ім'я <code>other</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}
</span></code></pre></pre>
<p>This example also meets the exhaustiveness requirement because we’re explicitly ignoring all other values in the last arm; we haven’t forgotten anything.</p>
<p>Нарешті, змінимо правила гри ще раз, так щоб нічого не ставалося на вашому ході, якщо ви викинули щось інше, крім 3 чи 7. Це можна виразити одиничним значенням (тип порожнього кортежу, який ми згадували у підрозділі <a href="ch03-02-data-types.html#the-tuple-type">“Тип кортеж”</a><!-- ignore --> ) у коді, що знаходиться у рукаві <code>_</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}
</span></code></pre></pre>
<p>Here, we’re telling Rust explicitly that we aren’t going to use any other value that doesn’t match a pattern in an earlier arm, and we don’t want to run any code in this case.</p>
<p>Більш детально про шаблони і зіставлення з ними йдеться у <a href="ch18-00-patterns.html">Розділі 18</a><!-- ignore -->. Ну а поки що ми перейдемо до конструкції <code>if let</code>, яка може бути корисною в ситуаціях, де вираз <code>match</code> буде надто багатослівним.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Лаконічний-контроль-виконання-конструкцією-if-let"><a class="header" href="#Лаконічний-контроль-виконання-конструкцією-if-let">Лаконічний контроль виконання конструкцією <code>if let</code></a></h2>
<p>Конструкція <code>if let</code> дозволяє вам комбінувати <code>if</code> та <code>let</code> менш багатослівно, щоб обробляти значення, що відповідають одному шаблону, і ігнорувати інші. Розглянемо програму у Блоці коду 6-6, що працює зі значенням <code>Option&lt;u8&gt;</code> у змінній <code>config_max</code>, але хоче виконувати код лише коли значення є варіантом <code>Some</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    match config_max {
        Some(max) =&gt; println!(&quot;The maximum is configured to be {}&quot;, max),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-6: A <code>match</code> that only cares about executing code when the value is <code>Some</code></span></p>
<p>Якщо значення є <code>Some</code>, ми виводимо значення у варіанті <code>Some</code>, зв'язавши у шаблоні це значення зі змінною <code>max</code>. Ми не хочемо нічого робити зі значенням <code>None</code>. Щоб задовольнити вираз <code>match</code>, нам доводиться додати <code>_ =&gt;()</code> після обробки лише одного варіанту, що є набридливо надлишковим.</p>
<p>Натомість ми можемо записати це коротше за допомогою <code>if let</code>. Наступний код робить те саме, що й <code>match</code> з Блоку коду 6-6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!(&quot;The maximum is configured to be {}&quot;, max);
    }
<span class="boring">}
</span></code></pre></pre>
<p>Конструкція <code>if let</code> бере шаблон і вираз, розділені знаком рівності. Вона працює так само як і <code>match</code>, де вираз стоїть після <code>match</code>, а шаблон є його першим рукавом. У цьому випадку шаблоном буде <code>Some(max)</code>, і <code>max</code> зв'язується зі значенням всередині <code>Some</code>. Тепер ми можемо використати <code>max</code> у тілі блоку <code>if let</code> так само як ми використали <code>max</code> у відповідному рукаві <code>match</code>. Код у блоці <code>if let</code> не буде виконано, якщо значення не відповідає шаблону.</p>
<p>Використання <code>if let</code> означає, що вам треба менше друкувати, менше ставити відступів і писати менше зайвого коду. Разом з тим, ми втрачаємо перевірку на вичерпність, до якої зобов'язує <code>match</code>. Вибір між <code>match</code> та <code>if let</code> залежить від того, що ви робите у конкретній ситуації та чи лаконічність варта втрати перевірки на вичерпність.</p>
<p>In other words, you can think of <code>if let</code> as syntax sugar for a <code>match</code> that runs code when the value matches one pattern and then ignores all other values.</p>
<p>У <code>if let</code> можна також додати <code>else</code>. Блок, що іде після <code>else</code> - це той самий блок, що був би у випадку <code>_</code> у виразу <code>match</code>, еквівалентному нашому <code>if let</code> та <code>else</code>. Згадаємо визначення енума <code>Coin</code> у Блоці коду 6-4, де варіант <code>Quarter</code> також включав значення <code>UsState</code>. Якби ми захотіли полічити усе, крім четвертаків, і водночас виводити штат з четвертаків, ми могли б зробити це за допомогою десь такого виразу <code>match</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
        _ =&gt; count += 1,
    }
<span class="boring">}
</span></code></pre></pre>
<p>Або ж ми могли б скористатися виразом <code>if let</code> та <code>else</code> ось таким чином:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!(&quot;State quarter from {:?}!&quot;, state);
    } else {
        count += 1;
    }
<span class="boring">}
</span></code></pre></pre>
<p>If you have a situation in which your program has logic that is too verbose to express using a <code>match</code>, remember that <code>if let</code> is in your Rust toolbox as well.</p>
<h2 id="Підсумок-5"><a class="header" href="#Підсумок-5">Підсумок</a></h2>
<p>Ми щойно розібрали, як використовувати енуми для створення власних типів, які можуть набувати одне з множини перелічених значень. Ми показали, як тип <code>Option&lt;T&gt;</code> зі стандартної бібліотеки допомагає використовувати систему типів для уникання помилок. Коли значення енума мають дані всередині, можна скористатися <code>match</code> чи <code>if let</code>, щоб витягти та використати ці значення, залежно від того, скільки різних варіантів вам треба обробити.</p>
<p>Ваші програми Rust тепер можуть виражати концепції з проблемної області за допомогою структур та енумів. Створення власних типів для використання у вашому API гарантує безпеку типів: компілятор забезпечить, що ваші функції отримають лише значення тих типів, на які ці функції очікують.</p>
<p>In order to provide a well-organized API to your users that is straightforward to use and only exposes exactly what your users will need, let’s now turn to Rust’s modules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Керування-проєктами-що-зростають-за-допомогою-пакетів-крейтів-та-модулів"><a class="header" href="#Керування-проєктами-що-зростають-за-допомогою-пакетів-крейтів-та-модулів">Керування проєктами, що зростають, за допомогою пакетів, крейтів та модулів</a></h1>
<p>Що більші програми ви пишете, то більшого значення набуває організація коду. Групуючи повʼязаний функціонал і розділяючи код з не повʼязаними функціями, ви вносите ясність, де шукати код, що реалізовує певний функціонал, і де вносити зміни до нього.</p>
<p>Програми, які ми написали раніше, поки знаходилися в одному модулі в єдиному файлі. У міру зростання проєкту вам слід організовувати код, розбиваючи його на кілька модулів і декілька файлів. Пакет може містити багато двійкових крейтів і, можливо, один бібліотечний крейт. Зі зростанням пакета ви можете виділяти його частини в окремі крейти, що стають зовнішніми залежностями. Цей розділ висвітлює усі ці техніки. Для дуже великих проєктів, які містять взаємоповʼязані пакети, що розвиваються разом, Cargo надає <em>робочі простори</em>, які будуть висвітлені у підрозділі <a href="ch14-03-cargo-workspaces.html">&quot;Робочі простори Cargo&quot;</a><!-- ignore --> у Розділі 14.</p>
<p>Ми також обговоримо інкапсуляцію деталей реалізації, що дозволяє повторно використовувати код на більш високому рівні: щойно ви реалізували операцію, інший код може викликати ваш код через публічний інтерфейс, навіть не знаючи деталей реалізації. Ваш підхід до написання коду визначає, які частини програми є публічними для використання іншим кодом, а які є приватними, деталі реалізації яких ви б хотіли приховати. Це ще один спосіб обмеження кількості деталей, які вам потрібно тримати в голові.</p>
<p>Повʼязане поняття - область видимості (scope): вкладений контекст, у якому написаний код, має набір назв, про які кажуть, що вони &quot;в області видимості.&quot; При читанні, написанні і компілюванні коду, програмісти та компілятори мають знати, чи певна назва в певному місці стосується змінної, функції, структури, енуму, модулю, константи або іншого елементу і що саме цей елемент означає. Ви можете створювати області видимості та визначати, які імена належать до них, а які ні. Але не можна мати два елементи з однаковою назвою в одній області видимості. Існують інструменти для вирішення конфліктів імен.</p>
<p>Rust має ряд функцій, що дозволяють керувати організацією коду, як-от тим, які деталі робити публічними, які приватними, і які імена будуть в кожній області видимості вашої програми. Ці функції, які інколи називають <em>модульною системою</em>, охоплюють:</p>
<ul>
<li><strong>Пакети:</strong> функціонал Cargo, що дозволяє збирати, тестувати і поширювати крейти</li>
<li><strong>Крейти:</strong> дерево модулів, що створює бібліотеку або виконуваний файл</li>
<li><strong>Модулі</strong> та <strong>use:</strong> дозволяють керувати організацією, областю видимості та приватністю шляхів</li>
<li><strong>Шляхи:</strong> спосіб іменування елемента, як-то структура, функція або модуль</li>
</ul>
<p>У цьому розділі ми розглянемо весь цей функціонал, подивимось, як він взаємодіє і пояснимо, як його використовувати для керування областю видимості. В результаті у вас має бути ґрунтовне розуміння модульної системи та здатність працювати з областями видимості на рівні професіоналів!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Пакети-та-крейти"><a class="header" href="#Пакети-та-крейти">Пакети та крейти</a></h2>
<p>Першими частинами модульної системи, які ми охопимо, будуть пакети та крейти.</p>
<p><em>Крейт</em> - це найменша кількість коду, яку компілятор Rust розглядає за один раз. Навіть, якщо ви запускаєте <code>rustc</code>, а не <code>cargo</code> і передаєте єдиний файл з вихідним кодом (як ми це робили у секції &quot;Написання і запуск програми на Rust&quot; Розділу 1), компілятор розглядає цей файл як крейт. Крейти можуть містити модулі, і модулі можуть бути визначені в інших файлах, які компілюються з крейтом, як ми побачимо у наступних підрозділах.</p>
<p>Крейт може бути представленим у двох формах: двійковий крейт або бібліотечний крейт. <em>Двійкові крейти</em> - це програми, які ви можете скомпілювати у виконувані файли, що можна запустити, такі як, наприклад, програму командного рядка чи сервер. Кожен з них має містити функцію із назвою <code>main</code>, яка визначає, що відбувається, коли виконуваний файл запускається. Усі крейти, що ми поки що створили, є двійковими.</p>
<p><em>Бібліотечні крейти</em> не мають функції <code>main</code> і вони не компілюються у виконуваний файл. Замість цього вони визначають функціонал, призначений для спільного використання у кількох проєктах. Наприклад, крейт <code>rand</code>, який ми використовували у <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">Розділі 2</a>,<!-- ignore --> забезпечує функціонал, що генерує рандомні числа. У більшості випадків, коли Растаціанці говорять &quot;крейт&quot;, вони мають на увазі саме бібліотечний крейт, і вони використовують &quot;крейт&quot; взаємозамінно із загальною концепцією програмування &quot;бібліотека&quot;.</p>
<p><em>Корінь крейта</em> - це вихідний файл, з якого компілятор Rust розпочинає роботу і створює кореневий модуль вашого крейта (про модулі ми розкажемо детальніше у підрозділі <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">“Визначення модулів для контролю області видимості та приватності”</a><!-- ignore -->
).</p>
<p><em>Пакети</em> - це набір одного або більше крейтів, які забезпечують набір функціоналів. Пакет містить файл <em>Cargo.toml</em>, який описує, як зібрати ці крейти. Cargo - це, по суті, пакет, який містить двійковий крейт для інструменту командного рядка, який ви вже використовували для збірки вашого коду. Пакет Cargo також містить бібліотечний крейт, від якого залежить двійковий крейт. Інші проєкти також можуть залежати від бібліотечного крейта Cargo, щоб використовувати таку ж саму логіку, яку використовують інструмент командного рядка Cargo.</p>
<p>Пакет може містити стільки двійкових крейтів, скільки ви захочете, проте не більше одного бібліотечного. Пакет повинен містити принаймні один крейт, бібліотечний чи двійковий.</p>
<p>Розгляньмо, що відбувається, коли ми створюємо пакет. Спочатку ми вводимо команду <code>cargo new</code>:</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>Після того, як ми запустили <code>cargo new</code>, ми використовуємо <code>ls</code> для того, щоб побачити, що Cargo створює. У каталозі проєкту знаходиться файл <em>Cargo.toml</em>, який дає нам пакет. Також, є ще каталог <em>src</em>, який містить <em>main.rs</em>. Відкрийте <em>Cargo.toml</em>у вашому текстовому редакторі й зверніть увагу, що там немає жодної згадки про <em>src/main.rs</em>. Cargo слідує домовленості, що <em>src/main.rs</em> є коренем двійкового крейта із тою ж самою назвою, що має пакунок. Окрім цього, Cargo знає, що якщо каталог пакунків містить <em>src/lib.rs</em>, пакунок містить бібліотечний крейт із тою ж назвою, що й пакунок, і <em>src/lib.rs</em> є коренем цього крейта. Cargo передає файли кореня крейта до <code>rustc</code> для збірки бібліотеки чи двійкового файлу.</p>
<p>Отже, ми маємо пакет, який містить лише <em>src/main.rs</em>, що означає, що тут міститься тільки двійковий крейт з назвою <code>my-project</code>. Якщо пакет містить <em>src/main.rs</em> і <em>src/lib.rs</em>, він складається з двох крейтів: двійкового і бібліотечного, обидва із такою ж назвою, як і пакет. У пакеті можна мати кілька двійкових крейтів, розмістивши файли у каталозі <em>src/bin</em>: кожен файл буде окремим двійковим крейтом.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Визначення-модулів-для-контролю-області-видимості-та-приватності"><a class="header" href="#Визначення-модулів-для-контролю-області-видимості-та-приватності">Визначення модулів для контролю області видимості та приватності</a></h2>
<p>В цьому розділі ми поговоримо про модулі та інші частини модульної системи, а саме: про <em>шляхи</em>, що дозволяють іменувати елементи; про ключове слово <code>use</code>, яке додає шлях в область видимості; та про ключове слово <code>pub</code>, що робить елементи публічними. Ми також розглянемо ключове слово <code>as</code>, зовнішні пакети та оператор glob.</p>
<p>Ми почнемо з переліку правил, до яких вам було б зручно повертатися в якості довідки в майбутньому при організації коду. Потім ми детально пояснимо кожне з правил.</p>
<h3 id="Шпаргалка-по-модулям"><a class="header" href="#Шпаргалка-по-модулям">Шпаргалка по модулям</a></h3>
<p>В цьому місці ми дамо короткий огляд того, як модулі, шляхи, ключові слова <code>use</code> та <code>pub</code> працюють в компіляторі, та як більшість розробників організовують свій код. В цьому розділі ми також розберемо приклади кожного з цих правил. Цей розділ буде прекрасним місцем, куди варто звертатися для нагадування про те, як працюють модулі.</p>
<ul>
<li><strong>Починайте з кореня крейту</strong>: Компілюючи крейт, компілятор спочатку дивиться в кореневий файл крейту в пошуках коду для компіляції. Зазвичай це <em>src/lib.rs</em> для бібліотечного крейту або <em>src/main.rs</em> для бінарного.</li>
<li><strong>Оголошення модулів</strong>: Ви можете оголошувати нові модулі в кореневому файлі крейту. Скажімо, ви хочете оголосити модуль &quot;garden&quot; як <code>mod garden;</code>. Компілятор шукатиме код даного модуля в наступних місцях:
<ul>
<li>Локально в цьому файлі всередині фігурних дужок, які заміняють крапку з комою після <code>mod garden</code></li>
<li>У файлі <em>src/garden.rs</em></li>
<li>У файлі <em>src/garden/mod.rs</em></li>
</ul>
</li>
<li><strong>Оголошення підмодулів</strong>: Ви можете оголошувати підмодулі в будь якому файлі, не лише в корені крейту. Наприклад, ви можете оголосити <code>mod vegetables;</code> в <em>src/garden.rs</em>. Компілятор шукатиме код підмодуля в теці з іменем батьківського модуля в наступних місцях:
<ul>
<li>Локально в цьому файлі, одразу після <code>mod vegetables</code>, всередині фігурних дужок замість крапки з комою</li>
<li>У файлі <em>src/garden/vegetables.rs</em></li>
<li>У файлі <em>src/garden/vegetables/mod.rs</em></li>
</ul>
</li>
<li><strong>Шляхи до коду в модулях</strong>: Після того як модуль став частиною вашого крейту, ви можете звертатися до його коду з будь-якого місця даного крейту за допомогою шляху до коду, якщо дозволяють правила приватності. Наприклад, тип <code>Asparagus</code> в модулі garden vegetables буде знайдений за шляхом <code>crate::garden::vegetables::Asparagus</code>.</li>
<li><strong>Приватність або публічність</strong>: Код всередині модуля є приватним від його батьківських модулів за замовчуванням. Аби зробити модуль публічним, оголосіть його за допомогою <code>pub mod</code> замість <code>mod</code>. Аби зробити елементи всередині публічного модуля публічними також, використовуйте <code>pub</code> перед їх оголошенням.</li>
<li><strong>Ключове слово <code>use</code></strong>: Всередині області видимості ключове слово <code>use</code> створює псевдоніми для елементів аби прибрати необхідність повторювати довгі шляхи. В будь якій області видимості, де необхідно звертатися до <code>crate::garden::vegetables::Asparagus</code> ви можете створити псевдонім <code>use crate::garden::vegetables::Asparagus;</code> і після цього просто писати <code>Asparagus</code> для використання цього типу в даній області видимості.</li>
</ul>
<p>Аби продемонструвати ці правила, створимо бінарний крейт <code>backyard</code>. Тека крейту, яка також називається <code>backyard</code>, містить такі файли та теки:</p>
<pre><code class="language-text">backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
</code></pre>
<p>Кореневий файл крейту в цьому випадку це <em>src/main.rs</em>. Його вміст:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust noplayground ignore">use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!(&quot;I'm growing {:?}!&quot;, plant);
}
</code></pre>
<p>Рядок <code>pub mod garden;</code> каже компілятору підключити код, який знайдений в <em>src/garden.rs</em>:</p>
<p><span class="filename">Файл: src/garden.rs</span></p>
<pre><code class="language-rust noplayground ignore">pub mod vegetables;
</code></pre>
<p>Тут <code>pub mod vegetables;</code> означає, що код в <em>src/garden/vegetables.rs</em> також буде підключений. Цей код:</p>
<pre><code class="language-rust noplayground ignore">#[derive(Debug)]
pub struct Asparagus {}
</code></pre>
<p>Тепер давайте розглянемо ці правила детальніше і продемонструємо їх в роботі!</p>
<h3 id="Групування-повʼязаного-коду-в-модулі"><a class="header" href="#Групування-повʼязаного-коду-в-модулі">Групування повʼязаного коду в модулі</a></h3>
<p><em>Модулі</em> дозволяють організувати код в крейті для читабельності та простоти повторного використання. Модулі також дозволяють контролювати <em>приватність</em> елементів, оскільки код всередині модуля є приватним за замовчуванням. Приватні елементи являють собою внутрішні деталі реалізації, недоступні для використання ззовні. Ми можемо зробити модулі і елементи всередині них публічними, що дозволить сторонньому коду використовувати їх і залежати від них.</p>
<p>В якості прикладу давайте напишемо бібліотечний крейт, що реалізує функціонал ресторану. Ми визначимо сигнатури функцій, проте залишимо їх вміст пустим для того, щоб сконцентруватися на організації коду, а не на деталях імплементації ресторану.</p>
<p>В ресторанній справі вирізняють такі частини ресторану як <em>внутрішня кухня (back of house)</em> та <em>зал (front of house)</em>. Зал це те, де сидять відвідувачі. Тут знаходяться місця для клієнтів, офіціанти приймають замовлення і оплату, а бармени роблять напої. Внутрішня кухня - це те, де шеф-кухарі і повари працюють на кухні, посудомийники миють посуд, а менеджери виконують адміністративну роботу.</p>
<p>Для того аби структурувати наш крейт правильним чином, можемо організувати його функції у вкладених модулях. Створіть нову бібліотеку з іменем <code>restaurant</code>, виконавши <code>cargo new restaurant --lib</code>; тоді наберіть код з Лістинга 7-1 в <em>src/lib.rs</em> аби визначити деякі модулі та сигнатури функцій. Далі йде секція для зали:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre>
<p><span class="caption">Блок коду 7-1: Модуль <code>front_of_house</code>, що містить інші модулі, які своєю чергою містять функції</span></p>
<p>Ми визначаємо модуль за допомогою ключового слова <code>mod</code>, після якого йде назва модуля (в цьому випадку <code>front_of_house</code>). Тіло модуля розміщається всередині фігурних дужок. Модулі можуть містити інші модулі, як в нашому випадку це зроблено з модулями <code>hosting</code> та <code>serving</code>. Також в модулях можуть знаходитися визначення інших елементів, таких як структури, переліки, константи, трейти, і - як у Блоці коду 7-1 - функції.</p>
<p>Використовуючи модулі, ми можемо групувати повʼязані визначення між собою і показувати, чому саме вони повʼязані. Програмісти, що використовують цей код, можуть орієнтуватись в коді на рівні функцій замість того, аби бути змушеними читати всі визначення в коді. Це робить задачу пошуку необхідних елементів набагато простішою. Додаючи новий функціонал до коду, програмісти знають де розмістити певний код аби підтримувати порядок і організацію в програмі.</p>
<p>Раніше ми згадували, що <em>src/main.rs</em> та <em>src/lib.rs</em>називаються коренями крейту. Причина такого іменування в тому, що вміст будь-якого з цих двох файлів утворює модуль з іменем <code>crate</code> в корені структури модуля крейту, яка також відома як <em>дерево модулів</em>.</p>
<p>Блок коду 7-2 демонструє дерево модулів для структури з Блоку коду 7-1.</p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">Блок коду 7-2: дерево модулів для коду в Блоці коду 7-1</span></p>
<p>Це дерево показує, як одні модулі вкладені в інші. Наприклад, <code>hosting</code>вкладений в <code>front_of_house</code>. Дерево також показує, що деякі модулі є <em>братами (siblings)</em> один для одного, що означає, що вони визначені в одному модулі. <code>hosting</code> та <code>serving</code> є братами, визначеними всередині <code>front_of_house</code>. Якщо модуль A міститься всередині модуля B, ми кажемо, що модуль A є <strong>нащадком (child)</strong> модуля B і що модуль B є <em>батьком (parent)</em> модуля A. Зверніть увагу, що батьком усього дерева модулів є неявний модуль з назвою <code>crate</code>.</p></p>
<p>Дерево модулів може нагадувати вам дерево тек і файлів файлової системи на вашому компʼютері. Це дуже влучне порівняння! Ви можете використовувати модулі для організації коду точно так само, як ви використовуєте теки у файловій системі. І так само, як у випадку з файлами в теці, нам потрібен спосіб пошуку необхідних модулів.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Шлях-для-доступу-до-елементів-у-дереві-модулів"><a class="header" href="#Шлях-для-доступу-до-елементів-у-дереві-модулів">Шлях для доступу до елементів у дереві модулів</a></h2>
<p>Щоб вказати Rust, де шукати елемент у дереві модулів, ми використовуємо шляхи так само як ми використовуємо шляхи для навігації по файловій системі. Щоб викликати функцію, ми повинні знати її шлях.</p>
<p>Шлях може приймати дві форми:</p>
<ul>
<li><em>Aбсолютний шлях</em> це повний шлях, що починається в кореневій директорії крейту; для коду від зовнішнього крейту, абсолютний шлях починається з назви крейту, і для коду з поточного ящика починається з рядка <code>crate</code>.</li>
<li><em>Відносний шлях</em> починається у поточному модулі і використовує <code>self</code>, <code>super</code> чи ідентифікатор поточного модуля.</li>
</ul>
<p>І абсолютні, і відносні шляхи складаються з одного чи кількох ідентифікаторів, розділених подвійною двокрапкою (<code>::</code>).</p>
<p>Повернімося до Блоку коду 7-1. Скажімо, ми хочемо викликати функцію <code>add_to_waitlist</code>. Це те саме, що й запитати: який шлях до функції <code>add_to_waitlist</code>? Блок коду 7-3 містить Блок коду 7-1, але деякі з модулів та функцій прибрані.</p>
<p>Ми покажемо два способи викликати функцію <code>add_to_waitlist</code> з нової функції <code>eat_at_restaurant</code>, визначеної в корені крейта. Ці шляхи є правильними, але залишилася інша проблема, яка перешкоджає компілюванню цього прикладу &quot;як є&quot;. Ми пояснимо, чому, трохи пізніше.</p>
<p>Функція <code>eat_at_restaurant</code> є частиною публічного API нашого бібліотечного крейта, тому ми позначимо її ключевим словом <code>pub</code>. Детальніше про <code>pub</code> йтиметься у підрозділі <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">&quot;Надання доступу до шляхів за допомогою ключового слова &lt;1&gt;pub&lt;/1&gt;</a><!-- ignore --> .</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Блок коду 7-3: виклик функції <code>add_to_waitlist</code> за допомогою абсолютного та відносного шляхів</span></p>
<p>Коли ми вперше ми викликаємо функцію <code>add_to_waitlist</code> в <code>eat_at_restaurant</code>, то використовуємо абсолютний шлях. Функція <code>add_to_waitlist</code> визначена у тому ж крейті, що й <code>eat_at_restaurant</code>, тобто ми можемо використати ключове слово <code>crate</code> на початку абсолютного шляху. Потім ми додаємо кожен з вкладених модулів, доки не не вкажемо весь шлях до <code>add_to_waitlist</code>. Уявіть собі файлову систему з такою ж структурою: ми повинні вказати шлях <code>/front_of_house/hosting/add_to_waitlist</code>, щоб запустити програму <code>add_to_waitlist</code>; використання назви <code>crate</code>, щоб почати з кореня, схожий на використання <code>/</code>, щоб почати шлях з кореня файлової системи у вашій оболонці.</p>
<p>Коли ми вдруге викликаємо <code>add_to_waitlist</code> у <code>eat_at_restaurant</code>, то використовуємо відносний шлях. Шлях починається з <code>front_of_house</code>, назви модуля, визначеного на тому ж рівні дерева модулів, що й <code>eat_at_restaurant</code>. Тут аналогом з файлової системи буде використання шляху <code>front_of_house/hosting/add_to_waitlist</code>. Початок з назви модуля означає, що шлях є відносним.</p>
<p>Рішення, використовувати відносний або абсолютний шлях, вам доведеться робити, виходячи з від вашого проєкту, і залежить від того, чи код, що визначає елемент, окремо від коду, що використовує його, чи разом. Наприклад, якщо ми перемістимо модуль <code>front_of_house</code> і функцію <code>eat_at_restaurant</code> у модуль <code>customer_experience</code>, нам знадобиться оновити абсолютний шлях до <code>add_to_waitlist</code>, але відносний шлях усе ще буде коректним. Однак, якби ми перенесли функцію <code>eat_at_restaurant</code> окремо до модуля з назвою <code>dining</code>, абсолютний шлях до виклику <code>add_to_waitlist</code> залишаться таким самим, але відносний шлях треба буде оновити. Загалом, ми вважаємо за краще вказувати абсолютні шляхи, тому що з більшою ймовірністю ми захочемо перемістити код визначення та виклики елементів незалежно один від одного.</p>
<p>Спробуймо скомпілювати Блок коду 7-3 і дізнатися, чому він досі не компілюється! Помилка, що ми отримуємо, показана у Блоці коду 7-4.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<p><span class="caption">Блок коду 7-4: помилки компілятора при збірці коду в Блоці коду 7-3</span></p>
<p>Повідомлення про помилки кажуть, що модуль <code>hosting</code> є приватним. Іншими словами, ми маємо коректні шляхи для модуля <code>hosting</code> і функції <code>add_to_waitlist</code>, але Rust не дозволяє нам використовувати їх, бо немає доступу до приватних частин. У Rust усі елементи (функції, методи, структури, енуми, модулі і константи) за замовчуванням є приватними в батьківських модулях. Якщо ви хочете зробити елемент на кшталт функції чи структури приватним, то розміщуєте його у модулі.</p>
<p>Елементи батьківського модуля не можуть використовувати приватні елементи дочірніх модулів, але елементи дочірніх модулів можуть використовувати елементи у модулях-предках. Так зроблено, щоб дочірні модулі огортали і ховали деталі своєї реалізації, але дочірні модулі можуть бачити контекст, у якому їх визначено. Щоб розвинути нашу метафору, уявіть собі правила приватності як бек-офіс ресторану: те, що там відбувається, недоступно для клієнтів ресторану, але менеджери можуть бачити і робити все у ресторані, яким вони керують.</p>
<p>У Rust вирішено зробити модульну систему, де деталі реалізації є прихованими за замовчуванням. Таким чином, ви знаєте, які частини внутрішнього коду ви можете змінити, не зламавши зовнішній код. Однак Rust надає вам можливість виставити внутрішні частини коду дочірніх модулів для зовнішніх модулів-предків за допомогою ключового слова <code>pub</code>, щоб зробити елемент публічним.</p>
<h3 id="Надання-доступу-до-шляхів-за-допомогою-ключового-слова-pub"><a class="header" href="#Надання-доступу-до-шляхів-за-допомогою-ключового-слова-pub">Надання доступу до шляхів за допомогою ключового слова <code>pub</code></a></h3>
<p>Повернімося до помилки у Блоці коду 7-4, яка каже нам, що модуль <code>hosting</code> є приватним. Ми хочемо, щоб функція <code>eat_at_restaurant</code> в батьківському модулі мала доступ до функції <code>add_to_waitlist</code> в дочірньому модулі, тож ми позначили модуль <code>hosting</code> за допомогою ключового слова <code>pub</code>, як показано в Блоці коду 7-5.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Блок коду 7-5: проголошення модуля <code>hosting</code> як <code>pub</code>, щоб використовувати його з <code>eat_at_restaurant</code></span></p>
<p>На жаль, код у Блоці коду 7-5 все ще призводить до помилки, як це показано в Блоці коду 7-6.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<p><span class="caption">Блок коду 7-6: помилки компілятора від збірки коду у Блоці коду 7-5</span></p>
<p>Що сталося? Додавання ключового слова <code>pub</code> перед <code>mod hosting</code> робить модуль публічним. Після цієї зміни, якщо ми маємо доступ <code>front_of_house</code>, ми можемо отримати доступ до <code>hosting</code>. Але <em>вміст</em> <code>hosting</code> все ще є приватним; зробивши модуль публічним, ми робимо публічним його вміст. Ключове слово <code>pub</code> для модуля дозволяє коду в модулях-предках тільки посилатися на нього, а не мати доступ до його внутрішнього коду. Оскільки модулі є контейнерами, ми багато не зробимо, лише зробивши модуль публічним; ми маємо піти далі і також зробити ще один або більше елементів модуля публічними.</p>
<p>Помилки у Блоці коду 7-6 кажуть, що функція <code>add_to_waitlist</code> є приватною. Правила приватності  застосовуються до структур, енумів, функцій і методів, як і до модулів.</p>
<p>Також зробімо публічною функцію <code>add_to_waitlist</code>, додавши ключове слово <code>pub</code> перед її визначенням, як у Блоці коду 7-7.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Блок коду 7-7: Додавання ключового слова <code>pub</code> до <code>mod hosting</code> і <code>fn add_to_waitlist</code> дозволяє нам викликати функцію з <code>eat_at_restaurant</code></span></p>
<p>Тепер код скомпілюється! Щоб побачити, чому додавання ключового слова <code>pub</code> дозволяє нам використовувати ці шляхи у <code>add_to_waitlist</code> відповідно до правил приватності, розгляньмо абсолютні та відносні шляхи.</p>
<p>Абсолютний шлях ми починаємо з <code>crate</code>, кореня дерева модулів нашого крейта. Модуль <code>front_of_house</code> визначено в корені крейта. Оскільки функція <code>eat_at_restaurant</code> визначена в тому ж модулі, що й <code>front_of_house</code> (тобто, <code>eat_at_restaurant</code> та <code>front_of_house</code> є сестрами), то поки <code>front_of_house</code> не є публічним, ми можемо посилатися на <code>front_of_house</code> лише з <code>eat_at_restaurant</code>. Наступний модуль <code>hosting</code> позначений як <code>pub</code>. Ми маємо доступ до батьківського модуля <code>hosting</code>, тож маємо доступ до <code>hosting</code>. Нарешті, функція <code>add_to_waitlist</code> позначена як <code>pub</code> і ми маємо доступ до її батьківського модуля, тож виклик функції працює!</p>
<p>У відносному шляху логіка така ж сама як і в абсолютному, окрім першого кроку: замість починати з кореня крейта, шлях починається з <code>front_of_house</code>. Модуль <code>front_of_house</code> визначено в тому ж модулі, що й <code>eat_at_restaurant</code>, тому відносний шлях, що починається з модуля, в якому визначено <code>eat_at_restaurant</code>, працює. Потім, оскільки <code>hosting</code> і <code>add_to_waitlist</code> позначені як <code>pub</code>, решта шляху працює, і цей виклик функції - коректний!</p>
<p>Якщо ви плануєте поділитися своєю бібліотекою, щоб інші проєкти могли використовувати ваш код, ваш публічний API - це ваш контракт з користувачами вашого крейта, який визначає, як вони можуть взаємодіяти з вашим кодом. Існує багато міркувань щодо управління змінами у вашому публічному API для полегшення залежності від Вашого крейта. Ці міркування не лежать за межами цієї книжки; якщо вам цікава ця тема, дивіться <a href="https://rust-lang.github.io/api-guidelines/">Керівництво з API Rust</a>.</p>
<blockquote>
<h4 id="Кращі-практики-для-пакунків-з-двійковим-крейтом-і-бібліотекою"><a class="header" href="#Кращі-практики-для-пакунків-з-двійковим-крейтом-і-бібліотекою">Кращі практики для пакунків з двійковим крейтом і бібліотекою</a></h4>
<p>Ми згадували, що пакунок може містити одночасно корінь як двійкового крейта <em>src/main.rs</em>, так і корінь бібліотечного крейта <em>src/lib.rs</em>, і обидва крейти матимуть за замовчуванням назву пакету. Зазвичай, пакунки, створені за таким шаблоном, з бібліотекою і двійковим крейтом, матимуть у двійковому крейті лише код, потрібний для запуску виконуваного коду з бібліотечного крейта. Це дозволяє іншим проєктам отримувати максимум функціоналу, який надає пакунок, бо бібліотечний крейт можна використовувати спільно.</p>
<p>Дерево модулів має бути визначеним в <em>src/lib.rs</em>. Тоді будь-які публічні елементи можна використовувати у двійковому крейті, починаючи шлях з назви пакунку. Двійковий крейт стає таким самим користувачем бібліотечного крейта, як і абсолютно зовнішній крейт, що використовує бібліотечний крейт: він може користуватися лише публічним API. Це допомагає вам розробити хороший API; ви не лише його автор, але також і користувач!</p>
<p>У <a href="ch12-00-an-io-project.html">Розділі 12</a><!-- ignore -->ми покажемо цю практику організації крейта у програмі командного рядка, що міститиме як двійковий крейт, так і бібліотечний крейт.</p>
</blockquote>
<h3 id="Початок-відносних-шляхів-з-super"><a class="header" href="#Початок-відносних-шляхів-з-super">Початок відносних шляхів з <code>super</code></a></h3>
<p>Ми можемо створювати відносні шляхи, які починаються в батьківському модулі, а не в поточному чи корені крейта, застосувавши <code>super</code> на початку шляху. Це схоже на <code>..</code> на початку шляху в файловій системі. За допомогою <code>super</code> ми можемо посилатися на елемент, що, як ми знаємо, знаходиться в батьківському модулі, що спрощує зміну дерева модулів, коли модуль є тісно пов'язаним із батьком, але батьківський елемент може бути переміщений в інше місця дерева модулів.</p>
<p>Розглянемо код у Блоці коду 7-8, який моделює ситуацію, в якій шеф-кухар виправляє неправильне замовлення і особисто приносить його клієнту. Функція <code>fix_incorrect_order</code>, визначена у модулі <code>back_of_house</code> викликає функцію <code>deliver_order</code>, визначену в батьківському модулі, вказавши шлях до <code>deliver_order</code>, починаючи з <code>super</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
</code></pre>
<p><span class="caption">Блок коду 7-8: виклик функції за допомогою відносного шляху, що починається з <code>super</code></span></p>
<p>Функція <code>fix_incorrect_order</code> знаходиться в модулі <code>back_of_house</code>, тож ми можемо використатися <code>super</code>, щоб перейти до батьківсього модуля <code>back_of_house</code>, який у цьому випадку є коренем, <code>crate</code>. Звідси ми шукаємо <code>deliver_order</code> і знаходимо її. Успіх! Ми гадаємо, що модуль <code>back_of_house</code> і функція <code>deliver_order</code> найімовірніше залишатимуться у такому відношенні одне до одного і будуть переміщені разом, якщо ми вирішимо реорганізувати дерево модулів крейта. Таким чином, ми скористалися <code>super</code>, щоб мати менше місць, де треба буде для оновлювати код у майбутньому, якщо цей код перемістять в інший модуль.</p>
<h3 id="Робимо-структури-і-енуми-публічними"><a class="header" href="#Робимо-структури-і-енуми-публічними">Робимо структури і енуми публічними</a></h3>
<p>Також ми можемо використовувати <code>pub</code> для визначення структур та енумів публічними, але є додаткові особливості використання <code>pub</code> зі структурами та енумами. Якщо ми використовуємо <code>pub</code> перед визначенням структури, ми робимо структуру публічною, але поля структури все одно будуть приватними. Ми можемо зробити публічним чи ні кожне поле окремо в кожному конкретному випадку. У Блоці коду 7-9 ми визначили публічну структуру <code>back_of_house::Breakfast</code> з публічним полем <code>toast</code>, але приватним полем <code>seasonal_fruit</code>. Це моделює ситуацію в ресторані, коли покупець може обрати тип хліба, що додається до їжі, але кухар вирішує, які фрукти йдуть до їжі залежно від сезону і наявності. Доступні фрукти швидко змінюються, тому клієнти не можуть вибрати фрукти і навіть побачити, які фрукти вони отримають.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;peaches&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);
    // Change our mind about what bread we'd like
    meal.toast = String::from(&quot;Wheat&quot;);
    println!(&quot;I'd like {} toast please&quot;, meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from(&quot;blueberries&quot;);
}
</code></pre>
<p><span class="caption">Блок коду 7-9: структура, деякі поля якої є публічними, а деякі приватними</span></p>
<p>Оскільки поле <code>toast</code> у структурі <code>back_of_house::Breakfast</code> є публічним, у <code>eat_at_restaurant</code> ми можемо писати та читати поле <code>toast</code>, використовуючи точку. Зверніть увагу, що ми не можемо використовувати поле <code>seasonal_fruit</code> у <code>eat_at_restaurant</code>, тому що <code>seasonal_fruit</code> є приватним. Спробуйте розкоментувати рядок, що змінює значення поля <code>seasonal_fruit</code>, щоб подивитися, яку помилку ви отримуєте!</p>
<p>Крім того, зауважте, що оскільки <code>back_of_house::Breakfast</code> має приватне поле, структура має надавати публічну асоційовану функцію, що створює екземпляр <code>Breakfast</code> (тут ми назвали її <code>summer</code>). Якби <code>Breakfast</code> не мав такої функції, ми не могли б створити екземпляр <code>Breakfast</code> у <code>eat_at_restaurant</code>, бо не могли б виставити значення приватного поля <code>seasonal_fruit</code> у <code>eat_at_restaurant</code>.</p>
<p>На відміну від цього, якщо ми робимо енум публічним, усі його варіанти є публічними. Потрібно лише одне ключове слово <code>pub</code> перед <code>enum</code>, як показано в Блоці коду 7-10.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
</code></pre>
<p><span class="caption">Блок коду 7-10: позначення енума публічним робить публічними усі його варіанти</span></p>
<p>Оскільки ми зробили енум <code>Appetizer</code> публічним, то можемо використовувати варіанти <code>Soup</code> та <code>Salad</code> у <code>eat_at_restaurant</code>.</p>
<p>Енуми не дуже корисні, коли їхні варіанти не є публічними; було б набридливим анотувати всі варіанти енуму як <code>pub</code> у будь-якому випадку, то за замовчуванням варіанти переліку є публічними. Структури часто є корисними без публічних полів, тож поля структур слідують загальному правилу, що все є приватним за замовчуванням, якщо не анотовано як <code>pub</code>.</p>
<p>Є ще одна ситуація, пов’язана з <code>pub</code>, про яку ми не розповіли, і це остання деталь системи модулів: ключове слово <code>use</code>. Ми спершу розповімо про <code>use</code>, а потім покажемо, як комбінувати <code>pub</code> і <code>use</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Підключення-шляхів-до-області-видимості-за-допомогою-ключового-слова-use"><a class="header" href="#Підключення-шляхів-до-області-видимості-за-допомогою-ключового-слова-use">Підключення шляхів до області видимості за допомогою ключового слова <code>use</code></a></h2>
<p>Необхідність переписувати шляхи для виклику функцій може здатися незручною та повторюваною. У Блоці коду 7-7 незалежно від того, чи ми вказували абсолютний чи відносний шлях до функції <code>add_to_waitlist</code>, для того, щоб її викликати, ми кожного разу мали також вказувати <code>front_of_house</code> та <code>hosting</code>. На щастя, існує спосіб спростити цей процес: достатньо один раз створити ярлик (shortcut) для шляху за допомогою ключового слова <code>use</code> і потім використовувати коротке імʼя будь-де в області видимості.</p>
<p>У Блоці коду 7-11 ми підключаємо модуль <code>crate::front_of_house::hosting</code> до області видимості функції <code>eat_at_restaurant</code>, отже нам лишається лише вказати <code>hosting::add_to_waitlist</code> для виклику функції <code>add_to_waitlist</code> всередині <code>eat_at_restaurant</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Listing 7-11: Bringing a module into scope with <code>use</code></span></p>
<p>Додання <code>use</code> та шляху до області видимості схоже на створення символічного посилання (symbolic link) у файловій системі. При додаванні <code>use crate::front_of_house::hosting</code> в корені крейта, <code>hosting</code> стає коректним імʼям в цій області видимості, так як би модуль ``hosting<code>був визначений в корені крейта. Шляхи, додані до області видимості за допомогою</code>use`, також перевіряються на приватність, як і будь-які інші.</p>
<p>Зауважте, що <code>use</code> лише створює ярлик для конкретної області видимості, в якій знаходиться цей самий <code>use</code>. Лістинг 7-12 переносить функцію <code>eat_at_restaurant</code> до нового дочірнього модуля <code>customer</code>, що має відмінну від <code>use</code> область видимості, а отже, тіло фінкції зкомпільовано не буде:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
</code></pre>
<p><span class="caption">Listing 7-12: A <code>use</code> statement only applies in the scope it’s in</span></p>
<p>Помилка компілятора показує, що даний ярлик більше не дійсний в модулі <code>customer</code>:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` due to previous error; 1 warning emitted
</code></pre>
<p>Зверніть увагу також на попередження компілятора, що <code>use</code> не використовується у власній області видимості! Для вирішення цієї проблеми треба перемістити <code>use</code> до модуля <code>customer</code>, або послатися на його ярлик у батьківському модулі за допомогою <code>super::hosting</code> всередині дочірнього модуля<code>customer</code>.</p>
<h3 id="Створення-ідіоматичних-шляхів-use"><a class="header" href="#Створення-ідіоматичних-шляхів-use">Створення ідіоматичних шляхів <code>use</code></a></h3>
<p>У Блоці коду 7-11 у вас могло виникнути питання, чому ми вказали <code>use crate::front_of_house::hosting</code> і потім викликали <code>hosting::add_to_waitlist</code> в <code>eat_at_restaurant</code> замість вказання в <code>use</code> повного шляху до функції <code>add_to_waitlist</code> для отримання того самого результату, що й у Блоці коду 7-13.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}
</code></pre>
<p><span class="caption">Блок коду 7-13: Додання функції <code>add_to_waitlist</code> до області видимості за допомогою <code>use</code>, що не є ідіоматичним способом</span></p>
<p>Хоча Блоки коду 7-11 та 7-13 і виконують одну й ту саму задачу, Блок коду 7-11 є ідіоматичним способом додавання функції до області видимості за допомогою <code>use</code>. Щоб додати батьківський модуль функції до області видимості з <code>use</code> треба його вказати при виклику функції. Вказання батьківського модуля при виклику функції явно показує, що функція не оголошена локально, але разом з тим це зводить до мінімуму необхідність повторень повного шляху. З коду в Блоці коду 7-13 не ясно, де саме визначено <code>add_to_waitlist</code>.</p>
<p>З іншого боку при додаванні структур, переліків та інших елементів за допомогою <code>use</code>, вказання повного шляху є ідіоматичним. Блок коду 7-14 демонструє ідіоматичний спосіб для додавання стандартної структури з бібліотеки <code>HashMap</code>` до області видимості бінарного крейту.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<p><span class="caption">Listing 7-14: Bringing <code>HashMap</code> into scope in an idiomatic way</span></p>
<p>За цією ідіомою немає якоїсь вагомої причини: це просто згода серед програмістів на Rust, які звикли писати і читати код саме таким чином.</p>
<p>Винятком з цієї ідіоми є випадок, коли треба підключити два елементи з однаковими іменами до області видимості з оператором <code>use</code>, оскільки Rust не дозволяє зробити це. Лістинг 7-15 демонструє як підключити до області видимості два типи <code>Result</code>, що мають однакове імʼя, але різні батьківські модулі, та як до них звертатися.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}
</code></pre>
<p><span class="caption">Блок коду 7-15: Підключення до області видимості двох типів з одним імʼям вимагає вказання їх батьківських модулів.</span></p>
<p>Як ви можете бачити, використання батьківських модулів розрізняє дви типа <code>Result</code>. Якщо б натомість ми вказали <code>use std::fmt::Result</code> та <code>use std::io::Result</code>, ми б мали два типи <code>Result</code> в одній області видимості та Rust не знав би, який з них ми маємо на увазі, пишучи <code>Result</code>.</p>
<h3 id="Впровадження-нових-імен-за-допомогою-ключового-слова-as"><a class="header" href="#Впровадження-нових-імен-за-допомогою-ключового-слова-as">Впровадження нових імен за допомогою ключового слова <code>as</code></a></h3>
<p>Існує також інше рішення проблеми використання двох типів з одним імʼя в одній області видимості з <code>use</code>: після шляху можна вказати <code>as</code> та нове локальне імʼя, або <em>аліас</em> для даного типу. Лістинг 7-16 показує інший спосіб написання коду з Лістинга 7-15, перейменувавши один з двох типів <code>Result</code> за допомогою <code>as</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}
</code></pre>
<p><span class="caption">Блок коду 7-16: Перейменування типу при його додаванні до області видимості з ключовим словом <code>as</code></span></p>
<p>У другому операторі <code>use</code>ми вказали нове імʼя <code>IoResult</code>для типу ``std::io::Result<code>, що не конфліктуватиме з типом </code>Result<code>з</code>std::fmt`, що ми ойго також додали до області видимості. Підходи з Блоків коду 7-15 та 7-16 вважаються ідіоматичними. Отже, вибір за вами!</p>
<h3 id="Реекспорт-імен-із-pub-use"><a class="header" href="#Реекспорт-імен-із-pub-use">Реекспорт імен із <code>pub use</code></a></h3>
<p>При внесенні імені до області видимості із ключовим словом <code>use</code>, імʼя, доступне в новій області видимості, є приватним. Аби код міг посилатися на це імʼя так, ніби воно визначене в його області видимості, ми можемо комбінувати <code>pub</code> та <code>use</code>. Ця техніка називається <em>re-exporting</em>. тому що ми не лише додаємо елемент до області видимості, а ще й робимо його доступним для підключення в інші області видимості.</p>
<p>Блок коду 7-17 показує код з Блока коду 7-11, в якому <code>use</code> в кореневому модулі замінено на <code>pub use</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Блок коду 7-17: Робимо назву доступною для використання будь-яким кодом з нової області видимості за допомогою <code>pub use</code></span></p>
<p>До цієї заміни зовнішній код повинен був викликати функцію <code>add_to_waitlist</code>, використовуючи шлях <code>restaurant::front_of_house::hosting::add_to_waitlist()</code>. Тепер, коли використання <code>pub use</code> дозволило реекспортувати модуль <code>hosting</code> з кореневого модуля, зовнішній код може натомість використовувати шлях <code>restaurant::hosting::add_to_waitlist()</code>.</p>
<p>Реекспорт є корисним, коли внутрішня структура коду відрізняється від того, як програмісти, що викликають ваш код, думають про предметну область. Наприклад, в нашій ресторанній метафорі люди, що керують рестораном, сприймають його як внутрішню кухню та зал В той час як відвідувачі ресторану, можливо, не сприймають ресторан в таких само термінах. Із <code>pub use</code> ми можемо писати код у вигляді однієї структури, проте виставляти його назовні у вигляді іншої. Завдяки цьому наша бібліотека лишається добре організованою для програмістів, які будуть з нею працювати. Ми також розглянемо інший приклад використання <code>pub use</code> і як це впливає на вашу документацію крейту в частині <a href="ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use">“Експорт зручного публічного API із <code>pub use</code>”</a><!-- ignore --> розділу 14.</p>
<h3 id="Використання-зовнішніх-пакетів"><a class="header" href="#Використання-зовнішніх-пакетів">Використання зовнішніх пакетів</a></h3>
<p>У Розділі 2 ми написали гру у вгадування чисел, яка використовувала зовнішній пакет під назвою <code>rand</code> для отримання випадкових чисел. Для використання <code>rand</code> в нашому проекті ми додали наступний рядок до <em>Cargo.toml</em>:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<p>Adding <code>rand</code> as a dependency in <em>Cargo.toml</em> tells Cargo to download the <code>rand</code> package and any dependencies from <a href="https://crates.io/">crates.io</a> and make <code>rand</code> available to our project.</p>
<p>Потім, для того щоб додати <code>rand</code> до області видимості нашого пакету, ми додали рядок <code>use</code>, що починався з імені крейту <code>rand</code> та перелічили елементи, які ми хочемо додати до області видимості. Згадайте, що в секції <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">“Генерація випадкового числа”</a><!-- ignore --> розділу 2 ми додали трейт <code>Rng</code> до області видимості і викликали функцію <code>rand::thread_rng</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span>}
</code></pre>
<p>Члени Rust спільноти зробили доступними багато пакетів, які доступні на <a href="https://crates.io/">crates.io</a>, і додання будь-якого з них до вашого пакету вимагає тих самих кроків: вказання їх у файлі <em>Cargo.toml</em> вашого пакету та використання <code>use</code> для додання елементів з їх крейтів до області видимості.</p>
<p>Зверніть увагу, що стандартна бібліотека <code>std</code> є також крейтом, щщо є зовнішнім по відношенню до нашого пакету. Оскільки стандартна бібліотека поставляється в комплекті з мовою Rust, нам не портібно змінювати <em>Cargo.toml</em> для додання <code>std</code>. Але нам потрібно вказати її за допомогою <code>use</code> для того щоб додати її елементи до області видимості нашого пакету. Наприклад, для <code>HashMap</code> ми б використовували такий рядок:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}
</span></code></pre></pre>
<p>This is an absolute path starting with <code>std</code>, the name of the standard library crate.</p>
<h3 id="Використаня-вкладенних-шляхів-для-зменшення-величезних-переліків-use"><a class="header" href="#Використаня-вкладенних-шляхів-для-зменшення-величезних-переліків-use">Використаня вкладенних шляхів для зменшення величезних переліків <code>use</code></a></h3>
<p>Якщо нам треба використовувати багато елементів, визначених в тому самому крейті або модулі, вказання кожного з них на окремому рядку займає багато вертикального простору в файлах. Наприклад, ці два оголошення <code>use</code> ми використовували у грі вгадування чисел в Блоці коду 2-4 для додавання до області видимості елементів з <code>std</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Натомість, ми можемо використовувати вкладені шляхи для того щоб додати ці елементи до області видимості лише одним рядком. Для цього ми вказуємо спільну частину шляху, за якою йдуть дві двокрапки, а потім фігурні дужки навколо переліку частин шляхів, що відрізняються, як показано в Лістінгу 7-18.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::{cmp::Ordering, io};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 7-18: Вказання вкладених шляхів для додання до області видимості елементів з однаковими префіксами</span></p>
<p>У більших програмах додання багатьох елементів до області видимості з одного крейту або модулю за допомогою вкладених шляхів може значно скоротити кількість необхідних використань <code>use</code>!</p>
<p>Ми можемо використовувати вкладені шляхи будь-якого рівня вкладеності, що є корисним при комбінуванні двох виразів <code>use</code>, що мають спільну частину шляху. Наприклад, Блок коду 7-19 демонструє два оператори <code>use</code>: один додає до області видимості <code>std::io</code> і один, що додає <code>std::io::Write</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;
</code></pre>
<p><span class="caption">Блок коду 7-20: Комбінування шляхів з Блока коду 7-19 в одному операторі <code>use</code></span></p>
<p>Цей рядок додає <code>std::io</code> та <code>std::io::Write</code> до області видимості.</p>
<h3 id="Глобальний-оператор-"><a class="header" href="#Глобальний-оператор-">Глобальний оператор (*)</a></h3>
<p>Якщо ми хочемо додати до області видимості <em>всі</em> публічні елементи, визначені за певним шляхом, ми можемо вказати шлях, за яким йтиме глобальний оператор <code>*</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<p>Цей оператор <code>use</code> додає до області видимості всі публічні елементи, визначені в <code>std::collections</code>. Будьте обережні, використовуючи глобальний оператор! Це може ускладнити сприйняття коду, оскільки стає важче визначити, які імена є в області видимості і де саме було визначено певне імʼя, що використовується у вашій програмі.</p>
<p>Лобальний оператор часто використовується при тестуванні для включення до області видимості всіх елементів з модуля <code>tests</code>. Ми поговоримо про це пізніше у секції <a href="ch11-01-writing-tests.html#how-to-write-tests">“Як писати тести”</a><!-- ignore --> розділу 11. Глобальний оператор також інколи використовується як частина патерну Прелюдія (prelude): див. <a href="../std/prelude/index.html#other-preludes">документацію по стандартній бібліотеці</a><!-- ignore -->
для отримання додаткової інформації по цьому патерну.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Розподіл-модулів-на-різні-файли"><a class="header" href="#Розподіл-модулів-на-різні-файли">Розподіл модулів на різні файли</a></h2>
<p>Поки що всі приклади в цій главі визначали декілька модулів у одному файлі. Коли модулі стають великими, ви можете захотіти перемістити їх визначення в окремі файли, щоб спростити навігацію по коду.</p>
<p>Наприклад, почнімо з коду із Лістинга 7-17, у якому було декілько модулів ресторану. Ми будемо вилучати модулі у файли замість того, щоб визначати всі модулі в кореневому модулі крейта. У нашому випадку кореневий модуль крейта - <em>src/lib.rs</em>, але цей розподіл також працює з бінарними крейтами, у яких кореневий модуль крейта - <em>src/main.rs</em>.</p>
<p>Спочатку ми вилучимо модуль <code>front_of_house</code> в свій власний файл. Видаліть код всередині фігурних дужок для модуля <code>front_of_house</code>, залишив тільки визначення <code>mod front_of_house;</code> так щоб тепер <em>src/lib.rs</em> містив код, показаний в Блоці коду 7-21. Зверніть увагу, що цей варіант не скомпілюється, поки ми не створимо файл <em>src/front_of_house.rs</em> з Лістинга 7-22.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Блок коду 7-21: Визначення модуля <code>front_of_house</code> чий вміст буде у <em>src/front_of_house.rs</em></span></p>
<p>Далі, розмістимо код, котрий був у фігурних дужках, у новий файл з ім'ям <em>src/front_of_house.rs</em>, як показано у Блоці коду 7-22. Компілятор знає, що потрібно шукати у цьому файлі, тому що він натрапив у кореневому модулі крейту на визначення модуля з ім'ям <code>front_of_house</code>.</p>
<p><span class="filename">Файл: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre>
<p><span class="caption">Блок коду 7-22: Визначення вмісту модуля <code>front_of_house</code> у файлі <em>src/front_of_house.rs</em></span></p>
<p>Зверніть увагу, що вам потрібно тільки <code>один</code> раз завантажити файл за допомогою оголошення <em>mod</em> у вашому дереві модулів. Як тільки компілятор дізнається, що файл є частиною проекта (та дізнається, де в дереві модулей знаходиться код за допомогою того, де ви розмістили оператор <code>mod</code>), інші файли у вашому проекті повинні посилатися на код завантаженого файлу, використовуючи шлях до місця, де він був оголошений, як описано у секції <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">Шляхи для посилання на елемент у дереві модулів</a><!-- ignore --> . Іншими словами, <code>mod</code> - це <em>не</em> операція “включення”, яку ви могли бачати в інших мовах програмування.</p>
<p>Далі ми вилучимо модуль <code>hosting</code> в його власний файл. Процес трохи відрізняється, тому що <code>hosting</code> є дочірнім модулем для <code>front_of_house</code>, а не кореневого модуля. Ми помістимо файл для <code>hosting</code> в нову директорію, який буде іменований на ім'я його предка в дереві модулів, у цьому випадку це <em>src/front_of_house/</em>.</p>
<p>Щоб почати перенесення <code>hosting</code>, ми змінюєм <em>src/front_of_house.rs</em> таким чином, щоб він одержав тільки визначення модуля <code>hosting</code>:</p>
<p><span class="filename">Файл: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting;
</code></pre>
<p>Далі ми створюємо директорію <em>src/front_of_house</em> та файл <em>hosting.rs</em>, у якому будуть визначення у модулі <code>hosting</code>:</p>
<p><span class="filename">Файл: src/front_of_house/hosting.rs</span></p>
<pre><code class="language-rust ignore">pub fn add_to_waitlist() {}
</code></pre>
<p>Якщо замість цього ми розмістимо <em>hosting.rs</em> у директорію <em>src</em>, компілятор буде думати, що код в <em>hosting.rs</em> це модуль <code>hosting</code>, визначений у корні крейта, а не визначений як дочірній модуль <code>front_of_house</code>. Правила компілятору для перевірки того, які файли містять код яких модулів, припускають, що директорії та файли точно відповідають дереву модулів.</p>
<blockquote>
<h3 id="Альтернативні-шляхи-до-файлів"><a class="header" href="#Альтернативні-шляхи-до-файлів">Альтернативні шляхи до файлів</a></h3>
<p>Досі ми розглядали найбільш ідіоматичні шляхи до файлів, які використовуються компілятором Rust, але Rust також підтримує старий стиль шляхів до файлу. Для модуля з ім'ям <code>front_of_house</code> визначеного в кореневому модулі крейту, компілятор буде шукати код модуля в:</p>
<ul>
<li><em>src/front_of_house.rs</em> (стиль, що ми розглядали)</li>
<li><em>src/front_of_house/mod.rs</em> (старий стиль, який все ще підтримується)</li>
</ul>
<p>Для модуля з ім'ям <code>hosting</code>, який є підмодулем <code>front_of_house</code>, компілятор буде шукати код модуля в:</p>
<ul>
<li><em>src/front_of_house/hosting.rs</em> (стиль, що ми розглядали)</li>
<li><em>src/front_of_house/hosting/mod.rs</em> (старий стиль, який все ще підтримується)</li>
</ul>
<p>Якщо ви використовуєте обидва стилі для одного й того ж модуля, ви отримаєте помилку компілятора. Використання суміші обох стилів для різних модулів у одному проекті дозволено, але це може збивати з пантелику людей, що переміщаються по вашому проекту.</p>
<p>Основним недоліком стиля, в якому використовуються файли з іменами <em>mod.rs</em> є те, що у вашому проєкті можуть опинитися багато файлів з іменами  <em>mod.rs</em>, що можуть призвести до плутанини, якщо ви одночасно відкриєте їх в редакторі.</p>
</blockquote>
<p>Ми перенесли код кожного модуля в окремий файл, а дерево модулів залишилось без змін. Виклики функцій в <code>eat_at_restaurant</code> будуть працювати без яких-небудь змін, не дивлячись на те, що визначення знаходяться у різних файлах. Цей метод дозволяє переміщати модулі в нові файли в міру збільшення їх розмірів.</p>
<p>Зверніть увагу, що оператор <code>pub use crate::front_of_house::hosting</code> у <em>src/lib.rs</em> також не змінився, та <code>use</code> не впливає на те, які файли компілюються як частина крейта. Ключове слово <code>mod</code> визначає модулі, і Rust шукає в файлі з таким же ім'ям, що й у модуля, який входить у цей модуль.</p>
<h2 id="Підсумок-6"><a class="header" href="#Підсумок-6">Підсумок</a></h2>
<p>Rust дозволяє розбити пакет на декілька крейтів, та крейт - на модулі, таким чином ви маєте змогу посилатися на елементи, визначенні в одному модулі, з іншого модуля. Це можна робити за допомогою вказання абсолютних чи відносних шляхів. Ці шляхи можна додати в область видимості оператором <code>use</code>, тому ми можете користуватися коротшими шляхами для багаторазового використання елементів у цій області видимості. Код модуля за замовчуванням є приватним, але можна зробити визначення загальнодоступними, додавши ключове слово <code>pub</code>.</p>
<p>У наступній главі ми подивимося деякі колекції структур данних із стандартної бібліотеки, які ви можете використовувати в своєму охайно організованому коді.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Звичайні-колекції"><a class="header" href="#Звичайні-колекції">Звичайні колекції</a></h1>
<p>Стандартна бібліотека Rust містить декілька дуже корисних структур даних, що звуться <em>колекції</em>. Більшість інших типів даних представляють одне певне значення, але колекції можуть містити багато значень. На відміну від вбудованих типів масив і кортеж, дані, на які вказують ці колекції, зберігаються на купі, тобто кількість даних не має бути обов'язково відомою під час компіляції і може збільшуватися або скорочуватися під час виконання програми. Кожен вид колекції має різні можливості і недоліки, і вибір відповідної колекції для поточної ситуації - це вміння, що ви розвиваєте з часом. У цьому розділі ми обговоримо три колекції, які дуже часто використовуються в програмах Rust:</p>
<ul>
<li><em>Вектор</em> дозволяє зберігати змінну кількість значень поруч одне з одним.</li>
<li><em>Стрічка</em> є колекцією символів. Ми вже згадували тип <code>String</code>, але в цьому розділі ми поговоримо про нього глибше.</li>
<li><em>Геш-таблиця</em> дозволяє пов’язати значення з певним ключем. Це конкретна реалізація більш загальної структури даних, що називається <em>відображенням</em> (&lt;0&gt;map&lt;/0&gt;).</li>
</ul>
<p>Щоб дізнатися про інші види колекцій, надані стандартною бібліотекою, див. <a href="../std/collections/index.html">документацію</a>.</p>
<p>Ми обговоримо, як створювати та оновлювати вектори, стрічки, геш-таблиці, а також те, що робить їх особливими.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Зберігання-списків-значень-у-векторах"><a class="header" href="#Зберігання-списків-значень-у-векторах">Зберігання списків значень у векторах</a></h2>
<p>Перший тип колекцій, який ми розглянемо - це <code>Vec&lt;T&gt;</code>, також відомий як <em>вектор</em>. Вектори дозволять вам зберігати більше одного значення в єдиній структурі даних, що розташовує ці значення поруч один з одним у пам'яті. Вектор може зберігати лише значення одного типу. Вони корисні, коли ви маєте список предметів, наприклад рядки тексту у файлі або ціни на товари у кошику.</p>
<h3 id="Створення-нового-вектора"><a class="header" href="#Створення-нового-вектора">Створення нового вектора</a></h3>
<p>Щоб створити новий порожній вектор, ми викликаємо <code>Vec:new</code>, як показано в Блоці коду 8-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-1: створення нового порожнього вектора для зберігання значень типу <code>i32</code></span></p>
<p>Зауважте, що тут ми додали анотації типу. Оскільки ми не вставляємо жодного значення в цей вектор, Rust не знає, які елементи ми маємо намір зберігати. Це важлива деталь. Вектори реалізовані за допомогою узагальнень; ми розкажемо, як використовувати узагальнення з вашими власними типами в Розділі 10. Наразі треба знати лише, що тип <code>Vec&lt;T&gt;</code>, наданий стандартною бібліотекою, може містити будь-який тип. Коли ми створюємо вектор, що міститиме певний тип, ми можемо зазначити тип у кутових дужках. У Блоці коду 8-1 ми кажемо Rust, що <code>Vec&lt;T&gt;</code> у <code>v</code> міститиме елементи типу <code>i32</code>.</p>
<p>Зазвичай ви створюватимете <code>Vec&lt;T&gt;</code> з початковими значеннями, і Rust виведе тип значень, які ви хочете зберігати, тож вам нечасто буде потрібно додавати таку анотацію типу. Rust для зручності надає макрос <code>vec!</code>, який створює новий вектор, який містить ваші значення. Блок коду 8-2 створює новий <code>Vec&lt;i32&gt;</code>, що містить значення <code>1</code>, <code>2</code>, і <code>3</code>. Тип цілих - <code>i32</code>, бо це тип цілих за замовчуванням, як ми вже говорили в підрозділі <a href="ch03-02-data-types.html#data-types">“Типи даних”</a><!-- ignore --> Розділу 3.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-2: створення нового вектора, що містить значення</span></p>
<p>Оскільки ми надали початкові значення <code>i32</code>, Rust може вивести, що типом <code>v</code> є <code>Vec&lt;i32&gt;</code> і анотація типу тут не потрібна. Далі ми поглянемо, як змінити вектор.</p>
<h3 id="Оновлення-вектора"><a class="header" href="#Оновлення-вектора">Оновлення вектора</a></h3>
<p>Щоб створити вектор і додати до нього елементи ми можемо використати метод <code>push</code>, як показано в Блоці коду 8-3.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-3: використання методу <code>push</code> для додавання значень у вектор</span></p>
<p>Як і для будь-якої змінної, якщо ми хочемо змінювати її значення, ми повинні зробити його мутабельним за допомогою ключового слова <code>mut</code>, як говорилося в Розділі 3. Числа, як ми розміщуємо у векторі, мають тип <code>i32</code>, і Rust виводить це з даних, тож нам не потрібна анотація <code>Vec&lt;i32&gt;</code>.</p>
<h3 id="Читання-елементів-векторів"><a class="header" href="#Читання-елементів-векторів">Читання елементів векторів</a></h3>
<p>Існує два способи послатися на значення, що зберігається у векторі: через індексацію або використовуючи метод <code>get</code>. У наступних прикладах ми анотували типи значень, які повертаються з цих функцій, для додаткової ясності.</p>
<p>Блок коду 8-4 показує обидва методи доступу до значення у векторі - синтаксис індексування і метод <code>get</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!(&quot;The third element is {}&quot;, third);

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!(&quot;The third element is {}&quot;, third),
        None =&gt; println!(&quot;There is no third element.&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-4: використання синтаксису індексів або методу <code>get</code> для доступу до елементів вектора</span></p>
<p>Зверніть тут увагу на декілька деталей. Ми використовуємо значення індексу <code>2</code>, щоб отримати третій елемент, бо вектори індексуються числами, починаючи з нуля. Використання <code>&amp;</code> і <code>[]</code> надає нам посилання на елемент за значенням індексу. Коли ми використовуємо метод <code>get</code> з індексом, переданим аргументом, то отримуємо <code>Option&lt;&amp;T&gt;</code>, який ми можемо використати у <code>match</code>.</p>
<p>Rust надає ці два способи посилання на елемент, щоб ви могли вибрати, як програма поводиться при спробі використовувати значення індексу поза діапазоном наявних елементів. Як приклад, подивімося, що станеться, коли ми матємо вектор з п'яти елементів, а потім спробуємо отримати доступ до елемента з індексом 100 за допомогою кожної техніки, як показано в Блоці коду 8-5.</p>
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-5: спроба доступу до елементу з індексом 100 у векторі, що містить п'ять елементів</span></p>
<p>Коли ми запустимо цей код, перший метод <code>[]</code> призведе до паніки програми через те, що він посилається на елемент, якого не існує. Цей метод найкраще використовувати, коли ви хочете, щоб програма аварійно завершилася, якщо сталася спроба отримати доступ до елемента за кінцем вектора.</p>
<p>Коли методу <code>get</code> передається індекс, що знаходиться поза вектором, він повертає <code>None</code> без паніки. Цей метод краще використовувати, якщо доступ до елемента за межами вектора може ставатися час від часу за нормальних умов. Ваш код тоді міститиме логіку обробки як <code>Some(&amp;element)</code>, так і <code>None</code>, як пояснюється в Розділі 6. Наприклад, індекс може бути отримано від людини, що вводить число. Якщо хтось випадково введе завелике число і програма отримає значення <code>None</code>, чи можете повідомити користувачеві, скільки елементів є у векторі надати йому ще одну спробу ввести коректне значення. Це буде більш дружньо до користувача, ніж аварійне завершення програми через хибодрук!</p>
<p>Коли у програми є посилання, borrow checker забезпечує правила володіння і позичання (про які йдеться у Розділі 4), забезпечуючи, що це посилання та будь-які інші посилання на вміст вектора залишаються коректними. Згадайте правило, яке каже, що не можна мати мутабельні і немутабельні посилання в одній області видимості. Це правило застосовується в Блоці коду 806, де ми тримаємо немутабельне посилання на перший елемент вектора і намагаємося додати елемент у кінець. Ця програма не спрацює, якщо ми спробуємо звернутися до цього елемента пізніше у функції:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!(&quot;The first element is: {}&quot;, first);
<span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 8-6: спроба додати елемент до вектора, тримаючи посилання на його елемент</span></p>
<p>Компіляція цього коду завершиться з такою помилкою:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;The first element is: {}&quot;, first);
  |                                          ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
</code></pre>
<p>Код у Блоці коду 8-6, можливо, має вигляд, ніби він повинен працювати: чому посилання на перший елемент має турбуватися про зміни в кінці вектора? Ця помилка відбувається через те, як працюють вектори: оскільки вектори тримають значення поруч одне з одним у пам'яті, додавання нового елемента в кінець вектора може вимагати виділення нової пам'яті та копіювання старих елементів у нове місце, якщо там, де наразі зберігається вектор, недостатньо місця, щоб тримати всі елементи один біля одного. У такому разі посилання на перший елемент вказуватиме на звільнену пам'ять. Правила позичання перешкоджають програмі опинитися в такій ситуації.</p>
<blockquote>
<p>Примітка: Для деталей імплементації типу <code>Vec&lt;T&gt;</code> дивіться <a href="../nomicon/vec/vec.html">&quot;Растономікон&quot;</a>.</p>
</blockquote>
<h3 id="Ітерування-по-значеннях-у-векторі"><a class="header" href="#Ітерування-по-значеннях-у-векторі">Ітерування по значеннях у векторі</a></h3>
<p>Для доступу до кожного елемента вектора по черзі ми ітеруємо по всіх елементах замість використання індексів для доступу по одному за раз. Блок коду 8-7 показує, як використовувати цикл <code>for</code>, щоб отримати немутабельні посилання на кожен елемент вектора значень <code>i32</code> і вивести їх.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{}&quot;, i);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-7: виведення кожного елементу вектора ітеруванням по елементах у циклі <code>for</code></span></p>
<p>Ми також можемо ітерувати по мутабельних посиланнях на кожен елемент у мутабельному векторі, щоб змінити всі елементи. Цикл <code>для</code> у Блоці коду 8-8 додасть <code>50</code> до кожного елемента.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-8: Ітерування по мутабельних посиланнях на елементи у векторі</span></p>
<p>Щоб змінити значення, на яке посилається мутабельне посилання, нам потрібно скористатися оператором розіменування <code>*</code> для отримання значення в <code>і</code> до того, як ми зможемо використовувати оператор <code>+=</code>. Ми поговоримо більше про оператора розіменування у підрозділі <a href="ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">&quot;Перехід за вказівником до значення&quot;</a><!-- ignore -->
Розділу 15.</p>
<p>Ітерування по вектору, мутабельне чи немутабельне, є безпечним завдяки правилам borrow checker. Якби ми спробували вставити або видалити елементи в циклі <code>for</code> у Блоці коду 8-7 і Блоці коду 8-8, то отримали б помилку компілятора, схожу на той, що ми отримали з кодом у Блоці коду 8-6. Посилання на вектор, яке тримає цикл <code>for</code>, запобігає одночасній зміні усього вектора.</p>
<h3 id="Використання-енума-для-зберігання-декількох-типів"><a class="header" href="#Використання-енума-для-зберігання-декількох-типів">Використання енума для зберігання декількох типів</a></h3>
<p>Вектор може зберігати лише значення одного типу. Це може бути незручно; точно існують випадки, коли є потреба у зберіганні списку елементів різних типів. На щастя, варіанти енума визначені як один тип, тож коли нам потрібен один тип для представлення елементів різних типів, ми можемо визначити і використовувати енум!</p>
<p>Наприклад, нехай ми хочемо отримати значення з рядка в таблиці, у якій деякі стовпці в рядку містять цілі числа, деякі — числа з рухомими точками, а деякі — рядки. Ми можемо визначити енум, варіанти якого будуть містити різні типи значень, і всі варіанти енума будуть вважатися одним і тим же типом — енумом. Тоді ми можемо створити вектор, який міститиме цей енум і, зрештою, міститиме різні типи. Ми продемонстрували це у Блоці коду 8-9.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-9: Визначення <code>enum</code> для зберігання значень різних типів у одному векторі</span></p>
<p>Rust має знати, які типи будуть у векторі, під час компіляції, щоб знати, скільки саме пам'яті у купі буде потрібно для зберігання кожного елемента. Ми також маємо явно зазначити, які типи можуть бути в цьому векторі. Якби Rust дозволив вектору містити будь-який тип, була б імовірність, що один або кілька з типів призведуть до помилок при виконанні операцій на елементах вектора. Використання енуму і виразу <code>match</code> означає, що Rust гарантує під час компіляції, що умі можливі випадки буде оброблено, як обговорювалося в Розділі 6.</p>
<p>Якщо ви не маєте вичерпного списку типів, з якими програма працюватиме під час виконання для зберігання у векторі, техніка енумів не спрацює. Натомість ви можете скористатися трейтовими об'єктами, про які йдеться у Розділі 17.</p>
<p>Тепер, коли ми обговорили деякі найпоширеніші способи використання векторів, обов'язково подивитися <a href="../std/vec/struct.Vec.html">документацію API </a><!-- ignore --> щоб дізнатися про багато інших корисних методів, визначених для <code>Vec&lt;T&gt;</code> у стандартній бібліотеці. Наприклад, на додачу до методу <code>push</code>, метод <code>pop</code> видаляє і повертає останній елемент.</p>
<h3 id="Очищення-вектора-очищує-його-елементи"><a class="header" href="#Очищення-вектора-очищує-його-елементи">Очищення вектора очищує його елементи</a></h3>
<p>Як і будь-яка інша <code>struct</code>, вектор вивільняється, коли виходить з області видимості, як підписано в Блоці коду 8-10.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // &lt;- v goes out of scope and is freed here
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-10: демонстрація, де саме вектор і його елементи очищуються</span></p>
<p>Коли вектор очищуються, також очищується і його вміст, тобто цілі числа, які він містить, будуть очищені. Borrow checker гарантує, що будь-які посилання на вміст вектора використовуються лише поки сам вектор є коректним.</p>
<p>Перейдімо до наступного типу колекцій: <code>String</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Зберігання-тексту-у-кодуванні-utf-8-в-стрічках"><a class="header" href="#Зберігання-тексту-у-кодуванні-utf-8-в-стрічках">Зберігання тексту у кодуванні UTF-8 в стрічках</a></h2>
<p>Ми говорили про стрічки в Розділі 4, але тепер ми розглянемо їх глибше. Нові растацеанці зазвичай застрягають на стрічках через поєднання трьох причин: схильність Rust до виявлення можливих помилок, стрічки є складнішою структурою даних, ніж вважають багато програмістів, та UTF-8. Ці фактори комбінуються таким чином, що може здатися вам складним, коли ви переходите з інших мов програмування.</p>
<p>Ми обговорюємо стрічки в контексті колекцій, оскільки стрічки реалізовані як колекція байтів, плюс деякі методи для надання корисної функціональності, коли ці байти розглядаються як текст. У цьому підрозділі ми поговоримо про операції на <code>String</code>, які має кожен тип колекцій, такі як створення, змінна та читання. Ми також обговоримо, чим <code>String</code> відрізняється від інших колекцій, а саме чому індексування <code>String</code> ускладнене відмінністю між тим, як люди і комп'ютери розглядають дані у <code>String</code>.</p>
<h3 id="Що-таке-стрічка"><a class="header" href="#Що-таке-стрічка">Що таке стрічка?</a></h3>
<p>Спочатку ми визначимо те, що ми маємо на увазі під терміном <em>стрічка</em>. Rust має лише один стрічковий тип у ядрі мови, а саме стрічковий слайс <code>str</code>, який зазвичай буває у запозиченій формі <code>&amp;str</code>. У Розділі 4 ми говорили про <em>стрічкові слайси</em>, які є посиланням на деякі дані, закодовані в UTF-8, які зберігаються деінде. Наприклад, стрічкові літерали зберігаються в двійковому файлі програми і, отже, є стрічковими слайсами.</p>
<p>Тип <code>String</code>, який надається стандартною бібліотекою Rust, а не закодовано в ядро мови, може зростати, бути мутабельним, володіє своїми даними і кодований в UTF-8. Коли растцеанці посилається на &quot;стрічки&quot; в Rust, то можуть посилатись або на тип <code>String</code>, або на стрічковий слайс <code>&amp;str</code>, а не лише один із цих типів. Хоча цей розділ багато в чому стосується <code>String</code>, обидва типи щедро використовуються в стандартній бібліотеці Rust, і як <code>String</code>, так і стрічкові слайси мають кодування UTF-8.</p>
<h3 id="Створення-нової-стрічки"><a class="header" href="#Створення-нової-стрічки">Створення нової стрічки</a></h3>
<p>Багато операцій, доступних для <code>Vec&lt;T&gt;</code>, також доступні для <code>String</code>, тому що <code>String</code> фактично реалізований як обгортка навколо вектора байтів з деякими додатковими гарантіями, обмеженнями і можливостями. Приклад функції, яка працює однаково як і з <code>Vec&lt;T&gt;</code> і <code>String</code>, це функція <code>new</code>, що створює екземпляр, як показано в Блоці коду 8-11.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-11: Створення нової порожньої <code>String</code></span></p>
<p>Цей рядок створює нову порожню стрічку, що називається <code>s</code>, в яку ми надалі можемо завантажити дані. Часто ми матимемо деякі початкові дані, які ми хочемо одразу розмістити в стрічці. Для цього ми використовуємо метод <code>to_string</code>, який доступний для будь-якого типу, що реалізує трейт <code>Display</code>, як, зокрема, стрічкові літерали. Блок коду 8-12 показує два приклади.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let data = &quot;initial contents&quot;;

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = &quot;initial contents&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-12: використання методу <code>to_string</code> для створення <code>String</code> зі стрічкового літерала</span></p>
<p>Цей код створює стрічку, що містить <code>початковий вміст</code>.</p>
<p>Також ми можемо скористатися функцією <code>String::from</code>, щоб створити <code>String</code> зі стрічкового літерала. Код у Блоці коду 8-13 еквівалентний коду зі Блоку коду 8-12, який використовує <code>to_string</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;initial contents&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-13: використання функції <code>String::from</code> для створення <code>String</code> зі стрічкового літерала</span></p>
<p>Оскільки стрічки використовуються для великої кількості речей, ми можемо використати багато різних узагальнених API для стрічок, що надають нам багато варіантів. Деякі з них можуть здатись надлишковими, але всі вони мають своє власне місце! У цьому випадку <code>String::from</code> і <code>to_string</code> роблять те саме, тому, що ви оберете є питанням стилю і читабельності.</p>
<p>Пам'ятайте, що стрічки мають кодування UTF-8, тож ми можемо включити у них будь-які правильно закодовані дані, як показано в Блоці коду 8-14.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let hello = String::from(&quot;السلام عليكم&quot;);
    let hello = String::from(&quot;Dobrý den&quot;);
    let hello = String::from(&quot;Hello&quot;);
    let hello = String::from(&quot;שָׁלוֹם&quot;);
    let hello = String::from(&quot;नमस्ते&quot;);
    let hello = String::from(&quot;こんにちは&quot;);
    let hello = String::from(&quot;안녕하세요&quot;);
    let hello = String::from(&quot;你好&quot;);
    let hello = String::from(&quot;Olá&quot;);
    let hello = String::from(&quot;Здравствуйте&quot;);
    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-14: збереження вітань різними мовами у стрічках</span></p>
<p>Усе це коректні значення <code>String</code>.</p>
<h3 id="Зміна-стрічок"><a class="header" href="#Зміна-стрічок">Зміна стрічок</a></h3>
<p><code>String</code> може зростати і її вміст може змінюватися, як вміст <code>Vec&lt;T&gt;</code>, якщо ви додасте у неї ще дані. На додачу, ви можете для зручності використовувати оператор <code>+</code> чи макрос <code>format!</code> для конкатенації значень <code>String</code>.</p>
<h4 id="Додавання-до-string-методами-push_str-і-push"><a class="header" href="#Додавання-до-string-методами-push_str-і-push">Додавання до String методами <code>push_str</code> і <code>push</code></a></h4>
<p>Ми можемо збільшити <code>String</code> за допомогою методу <code>push_str</code>, додавши стрічковий слайс, як показано в Блоці коду 8-15.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-15: додавання стрічкового слайсу до <code>String</code> за допомогою методу <code>push_str</code></span></p>
<p>Після цих двох рядків <code>s</code> міститиме <code>foobar</code>. Метод <code>push_str</code> приймає стрічковий слайс, бо ми не обов'язково хочемо приймати володіння параметром. Наприклад, у коді з Блоку коду 8-16, ми хочемо мати змогу використовувати <code>s2</code> після додавання його вмісту до <code>s1</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 is {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-16: використання стрічкового слайсу після додавання його вмісту до <code>String</code></span></p>
<p>Якби метод <code>push_str</code> взяв володіння <code>s2</code>, ми б не змогли вивести його значення в останньому рядку. Але цей код працює, як ми очікуємо!</p>
<p>Метод <code>push</code> приймає параметром один символ і додає його до <code>String</code>. Блок коду 8-17 додає букву &quot;l&quot; до <code>String</code> за допомогою методу <code>push</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-17: Додавання одного символу до значення <code>String</code> за допомогою <code>push</code></span></p>
<p>У результаті, <code>s</code> міститиме <code>lol</code>.</p>
<h4 id="Конкатенація-за-допомогою-оператора--і-макроса-format"><a class="header" href="#Конкатенація-за-допомогою-оператора--і-макроса-format">Конкатенація за допомогою оператора <code>+</code> і макроса <code>format!</code></a></h4>
<p>Часто вам треба поєднати дві стрічки. Один зі способів зробити це - використати оператор <code>+</code>, як показано в Блоці коду 8-18.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hello, &quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-18: використання оператора <code>+</code> для об'єднання двох значень <code>String</code> у нову <code>String</code></span></p>
<p>Стрічка <code>s3</code> міститиме <code>Hello, world!</code>. Причина, чому <code>s1</code> більше не дійсна після додавання, і причина, чому ми використовували посилання на <code>s2</code>, стосується сигнатури методу, викликаного, коли ми скористалися оператором <code>+</code>. Оператор <code>+</code> використовує метод <code>add</code>, сигнатура якого виглядає приблизно так:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>У стандартній бібліотеці ви побачите <code>add</code>, визначений за допомогою узагальнених і асоційованих типів. Тут ми підставили конкретні типи, що й стається, коли ми викликаємо цей метод зі значеннями <code>String</code>. Узагальнені типи ми обговоримо у Розділі 10. Ця сигнатура дає нам підказки, потрібні для розуміння тонких місць оператора <code>+</code>.</p>
<p>По-перше, <code>s2</code> має <code>&amp;</code>, що означає, що ми додаємо <em>посилання</em> на другу стрічку до першої стрічки. Так зроблено через параметр <code>s</code> у функції <code>add</code>: ми можемо лише додати <code>&amp;str</code> до <code>String</code>; ми не можемо скласти разом два значення <code>String</code>. Але чекайте — типом <code>&amp;s2</code> є <code>&amp;String</code>, а не <code>&amp;str</code>, як зазначено в другому параметрі <code>add</code>. То чому ж Блок коду 8-18 компілюється?</p>
<p>Причина, з якої ми можемо використовувати <code>&amp;s2</code> у виклику <code>add</code> полягає в тому, що компілятор може <em>привести</em> аргумент <code>&amp;String</code> до <code>&amp;str</code>. Коли ми викликаємо метод <code>add</code>, Rust використовує <em>приведення розіменування</em>, що тут перетворює <code>&amp;s2</code> у <code>&amp;s2[..]</code>. Ми обговоримо приведення розіменування глибше в Розділі 15. Оскільки <code>add</code> не перебирає володіння параметром <code>s</code>, <code>s2</code> все ще буде коректною <code>String</code> після цієї операції.</p>
<p>По-друге, як ми бачимо в сигнатурі, <code>add</code> бере володіння над <code>self</code>, бо <code>self</code> <em>не</em> має <code>&amp;</code>. Це означає, що <code>s1</code> у Блоці коду 8-18 буде перенесено у виклику <code>add</code> і після цього більше не буде дійсним. Таким чином, хоч <code>let s3 = s1 + &amp;s2;</code> виглядає, ніби він копіює обидві стрічки і створює нову, ця інструкція насправді бере володіння <code>s1</code>, додає копію вмісту <code>s2</code>, а потім повертає володіння результатом. Іншими словами, він виглядає, ніби створює багато копій, але насправді ні; реалізація ефективніша за копіювання.</p>
<p>Якщо нам потрібно об'єднати декілька стрічок, поведінка оператора <code>+</code> стає громіздкою:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<p>У цьому місці <code>s</code> буде <code>tic-tac-toe</code>. За усіма цими символами <code>+</code> і <code>&quot;</code> стає важко побачити, що відбувається. Для складнішого комбінування стрічок ми можемо замість цього скористатися макросом <code>format!</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<p>Цей код також надає <code>s</code> значення <code>tic-tac-toe</code>. Макрос <code>format!</code> працює подібно до <code>println!</code>, але замість виведення на екран, повертає <code>String</code> з відповідним вмістом. Версію коду, що використовує <code>format!</code>, значно простіше читати, і код, що згенеровано макросом <code>format!</code>, використовує посилання, тому цей виклик не перебирає володіння жодним зі своїх параметрів.</p>
<h3 id="Індексація-стрічок"><a class="header" href="#Індексація-стрічок">Індексація стрічок</a></h3>
<p>У багатьох інших мовах програмування доступ до окремих символів у стрічці за допомогою індексу є припустимою і поширеною операцією. Однак, якщо ви спробуєте отримати шматки <code>String</code> за допомогою синтаксису індексів у Rust, то отримаєте помилку. Розглянемо неправильний код у Блоці коду 8-19.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let h = s1[0];
<span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 8-19: спроба використати синтаксис індексів для String</span></p>
<p>Цей код призведе до наступної помилки:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
</code></pre>
<p>Помилка і примітка кажуть самі за себе: стрічки у Rust не підтримують індексацію. Але чому ні? Щоб відповісти на це запитання, нам потрібно обговорити, як Rust зберігає стрічки в пам'яті.</p>
<h4 id="Внутрішнє-представлення"><a class="header" href="#Внутрішнє-представлення">Внутрішнє представлення</a></h4>
<p><code>String</code> є обгорткою <code>Vec&lt;u8&gt;</code>. Подивімося на деякі зразки правильно кодованих у UTF-8 стрічок з Блоку коду 8-14. Спершу, цей:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;السلام عليكم&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobrý den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;שָׁלוֹם&quot;);
</span><span class="boring">    let hello = String::from(&quot;नमस्ते&quot;);
</span><span class="boring">    let hello = String::from(&quot;こんにちは&quot;);
</span><span class="boring">    let hello = String::from(&quot;안녕하세요&quot;);
</span><span class="boring">    let hello = String::from(&quot;你好&quot;);
</span><span class="boring">    let hello = String::from(&quot;Olá&quot;);
</span><span class="boring">    let hello = String::from(&quot;Здравствуйте&quot;);
</span>    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>У цьому випадку <code>len</code> буде 4, це означає, що вектор, що зберігає стрічку &quot;Hola&quot;, має довжину 4 байти. Кожна з цих літер займає 1 байт в кодуванні в UTF-8. Однак наступний рядок може вас здивувати.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;السلام عليكم&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobrý den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;שָׁלוֹם&quot;);
</span><span class="boring">    let hello = String::from(&quot;नमस्ते&quot;);
</span><span class="boring">    let hello = String::from(&quot;こんにちは&quot;);
</span><span class="boring">    let hello = String::from(&quot;안녕하세요&quot;);
</span><span class="boring">    let hello = String::from(&quot;你好&quot;);
</span><span class="boring">    let hello = String::from(&quot;Olá&quot;);
</span><span class="boring">    let hello = String::from(&quot;Здравствуйте&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hola&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>Якщо вас спитати, якої довжини стрічка, ви можете сказати 6. Насправді Rust відповість, що 12 - це число байтів, потрібних, щоб закодувати &quot;Привіт&quot; у UTF-8, оскільки кожен скалярне значення Unicode у цій стрічці займає 2 байти пам'яті. Таким чином, індекс по байтах стрічки не завжди буде співвідноситися з припустимим скалярним значенням Unicode. Для демонстрації, розгляньмо цей некоректний код Rust:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = &quot;Привіт&quot;;
let answer = &amp;hello[0];
</code></pre>
<p>Ви вже знаєте, що <code>answer</code> не буде <code>П</code>, першою літерою. У кодуванні UTF-8 перший байт <code>П</code> буде <code>208</code>, а другий <code>159</code>, тож здається, що <code>answer</code> має бути <code>208</code>, але <code>208</code> сам по собі не є допустимим символом. Швидше за все, користувач, що запитує першу літеру у стрічці, не хоче отримати <code>208</code>; однак за індексом 0 Rust має лише ці дані. Користувачі, як правило, не хочуть отримувати значення байтів, навіть якщо стрічка містить лише латинські літери: якби <code>&amp;&quot;hello&quot;[0]</code> було коректним кодом, що повертає значення байта, він усе одно поверне <code>104</code>, а не <code>h</code>.</p>
<p>Отже, відповідь полягає в тому, щоб уникнути повертання неочікуваного значення, що спричинить помилки, які можуть не бути виявлені негайно, і Rust узагалі не компілює цей код, запобігаючи непорозумінням на ранньому етапі процесу розробки.</p>
<h4 id="Байти-скалярні-значення-і-кластери-графем-Божечки"><a class="header" href="#Байти-скалярні-значення-і-кластери-графем-Божечки">Байти, скалярні значення і кластери графем! Божечки!</a></h4>
<p>Ще одна особливість UTF-8 полягає у тому, що насправді існує три способи поглянути на стрічки з точки зору Rust: як на байти, скалярні значення та графеми кластери (найближче до того, що ми називаємо <em>літерами</em>).</p>
<p>Скажімо, слово мовою Гінді “नमस्ते”, записане письмом деванаґарі, зберігається як вектор значень <code>u8</code>, що виглядає ось так:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Це 18 байтів і так комп'ютери кінець-кінцем зберігають ці дані. Якщо ми подивимося на них як на скалярні значення Unicode, тобто те, чим є тип <code>char</code> у Rust, ці байти виглядають наступним чином:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Тут є шість значень <code>char</code>, але четвертий і шостий — не літери: це діакритичні знаки, які самостійно не мають жодного сенсу. Нарешті, якщо ми подивимось на них як на кластери графем, то отримаємо те, що людина назвала б чотирма літерами, які складають слово на Гінді:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust надає різні способи інтерпретації необроблених даних стрічок, збережених комп'ютером, щоб кожна програма могла обрати потрібну їй інтерпретацію, неважливо якою людською мовою є ці дані.</p>
<p>Останньою причиною, чому Rust не дозволяє нам індексувати <code>String</code> для отримання символу, є те, що очікується, що операція індексації завжди займає постійний час (O(1)). Але неможливо гарантувати таку продуктивність для <code>String</code>, тому що Rust повинен проглянути вміст з початку до індексу, щоб визначити, скільки там було валідних символів.</p>
<h3 id="Слайси-зі-стрічок"><a class="header" href="#Слайси-зі-стрічок">Слайси зі стрічок</a></h3>
<p>Індексація стрічки часто є поганою ідеєю, бо не зрозуміло, яке значення має повертати операція індексування: байт, символ, кластер графем чи стріковий слайс. Тому, якщо вам дійсно треба використати індекси для створення стрічкових слайсів, Rust просить вас бути більш конкретним.</p>
<p>Замість індексування за допомогою <code>[]</code> з одним числом, ви можете використовувати <code>[]</code> з діапазоном, щоб створити стрічковий слайс, що містить певні байти:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Привіт&quot;;

let s = &amp;hello[0..4];
<span class="boring">}
</span></code></pre></pre>
<p>Тут <code>s</code> буде <code>&amp;str</code>, що містить перші 4 байти стрічки. Раніше ми згадували, що кожен з цих символів має 2 байти, а це означає, що <code>s</code> буде <code>Пр</code>.</p>
<p>Якби ми спробували створити слайс з частини байтів символу чимось на кшталт <code>&amp;hello[0..1]</code>, то Rust запанікував би під час виконання, так само, якби ми задали неправильний індекс для доступу до вектора:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', library/core/src/str/mod.rs:127:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Ви маєте використовувати діапазони для створення стрічкових слайсів з обережністю, тому що так може зламати програму.</p>
<h3 id="Методи-для-ітерації-по-стрічках"><a class="header" href="#Методи-для-ітерації-по-стрічках">Методи для ітерації по стрічках</a></h3>
<p>Найкращий спосіб оперувати фрагментами стрічкок - це чітко визначити, потрібні вам символи чи байти. Для роботи з окремими скалярними значеннями Unicode використовуйте метод <code>chars</code>. Виклик <code>chars</code> для “Пр&quot; виділяє і повертає два значення типу <code>char</code>, і ви можете ітерувати результатом для доступу до кожного елемента:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;Пр&quot;.chars() {
    println!(&quot;{c}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Цей код виводить на екран наступне:</p>
<pre><code class="language-text">П
р
</code></pre>
<p>Альтернатива, метод <code>bytes</code> повертає кожен необроблений байт, що може бути більш придатним для вашої задачі:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;Пр&quot;.bytes() {
    println!(&quot;{b}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Цей код виведе чотири байти, з яких складається ця стрічка:</p>
<pre><code class="language-text">208
159
209
128
</code></pre>
<p>Але не забувайте, що припустимі скалярні значення Unicode можуть бути складені з більш ніж 1 байту.</p>
<p>Отримання кластерів графем зі стрічок, як у письмі деванагарі, є складним, тому ця функціональність не надається стандартною бібліотекою. На <a href="https://crates.io/">crates.io</a> є відповідні крейти,<!-- ignore --> якщо ви потребуєте такого функціонала.</p>
<h3 id="Стрічки-не-такі-прості"><a class="header" href="#Стрічки-не-такі-прості">Стрічки не такі прості</a></h3>
<p>Підсумуємо: стрічки є складними. Різні мови програмування роблять різні вибори стосовно того, як представити цю складність програмісту. Rust обрав коректну обробку даних у <code>String</code> поведінкою за замовчуванням для всіх програм Rust, що означає, що програмісти повинні краще продумувати заздалегідь обробку даних UTF-8. Цей компроміс розкриває більшу частину складності стрічок, ніж зазвичай в інших мовах програмування, але це убезпечує вас від помилок із символами поза межами ASCII пізніше у життєвому циклі розробки.</p>
<p>Доброю новиною є те, що стандартна бібліотека пропонує велику кількість функціонала, побудованого на типах <code>String</code> і <code>&amp;str</code>, щоб допомогти правильно впоратися з цими складними ситуаціями. Обов'язково перевірте документацію про корисні методи, такі як <code>contains</code> для пошуку в стрічці і <code>replace</code> на заміну частин стрічки на іншу стрічку.</p>
<p>Перейдемо на щось менш складне: хеш-відображення!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Зберігання-ключів-і-повязаних-значень-у-хешмапах"><a class="header" href="#Зберігання-ключів-і-повязаних-значень-у-хешмапах">Зберігання ключів і пов'язаних значень у хешмапах</a></h2>
<p>Остання з поширених колекцій - це <em>хешмапа</em>. Тип <code>HashMap&lt;K, V&gt;</code> зберігає відображення ключів типу <code>K</code> на значення типу <code>V</code>, використовуючи <em>функцію хешування</em>, яка визначає, як розмістити ці ключі та значення у пам'яті. Багато мов програмування підтримують таку структуру даних, але часто використовують іншу назву, таку як хеш, відображення, хеш-таблиця, словник або асоціативний масив, це тільки декілька назв.</p>
<p>Хешмапи є корисними, коли ви хочете шукати дані не за індексом, як у векторах, а за допомогою ключа довільного типу. Наприклад, у грі ви можете відстежувати результат кожної команди за хешмапою, у якій кожен ключ є назвою команди, а значення є її рахунком. Маючи назву команди, ви можете отримати її рахунок.</p>
<p>У цьому розділі ми пройдемося базовим API хешмап, але багато інших корисностей ховаються у функціях, визначених на <code>HashMap&lt;K, V&gt;</code> у стандартній бібліотеці. Як завжди, зверніться до документації стандартної бібліотеки для додаткової інформації.</p>
<h3 id="Створення-нової-хешмапи"><a class="header" href="#Створення-нової-хешмапи">Створення нової хешмапи</a></h3>
<p>Один зі способів створення порожньої хешмапи - це застосувати <code>new</code> і додати елементи за допомогою <code>insert</code>. У Блоці коду 8-20 ми відстежуємо рахунки двох команд, що називаються <em>Синя</em> та <em>Жовта</em>. Синя команда починає з 10 очками, а Жовта - з 50.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-20: Створення нової хешмапи і вставлення деяких ключів та значень</span></p>
<p>Зверніть увагу, що нам, по-перше, треба зробити <code>use</code> для <code>HashMap</code> з розділу колекцій стандартної бібліотеки. З трьох наших загальних колекцій ця використовується найрідше, тож вона не включена до функціонала, який автоматично додається до області видимості у прелюдії. Хешмапи також мають меншу підтримку від стандартної бібліотеки; скажімо, не існує вбудованого макросу для їхнього конструювання.</p>
<p>Так само як і вектори, хешмапи зберігають свої дані у купі. Цей <code>HashMap</code> має ключі типу <code>String</code> і значення типу <code>i32</code>. Як і вектори, хешмапи є однорідними: усі ключі мають бути одного і того ж самого типу, і всі значення мають бути одного типу.</p>
<h3 id="Доступ-до-значень-у-хешмапі"><a class="header" href="#Доступ-до-значень-у-хешмапі">Доступ до значень у хешмапі</a></h3>
<p>Ми можемо отримати значення з хешмари, надавши її ключ методу <code>get</code>, як показано у Блоці коду 8-21.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    let team_name = String::from(&quot;Blue&quot;);
    let score = scores.get(&amp;team_name);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-21: доступ до рахунку Синьої команди, що зберігається у хешмапі</span></p>
<p>Тут <code>score</code> буде мати значення, пов'язане з Синьою командою, і результат буде <code>10</code>. Метод <code>get</code> повертає <code>Option&lt;&amp;V&gt;</code>; якщо у хешмапі для цього ключа немає відповідного значення, <code>get</code> поверне <code>None</code>. Ця програма обробляє <code>Option</code> викликом <code>copied</code>, отримуючи <code>Option&lt;i32&gt;</code>, а не <code>Option&lt;&amp;i32&gt;</code>, а тоді <code>unwrap_or</code>, щоб встановити <code>score</code> у нуль, якщо <code>scores</code> не має запису для цього ключа.</p>
<p>Ми можемо ітерувати по кожній парі ключ/значення в хешмапі схожим чином, як ми робимо з векторами, використовуючи цикл <code>for</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    for (key, value) in &amp;scores {
        println!(&quot;{}: {}&quot;, key, value);
    }
<span class="boring">}
</span></code></pre></pre>
<p>Цей код виведе кожну пару в довільному порядку:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="Хешмапи-і-володіння"><a class="header" href="#Хешмапи-і-володіння">Хешмапи і володіння</a></h3>
<p>Для типів, які реалізують трейт <code>Copy</code>, наприклад <code>i32</code>, значення копіюються до хешмапи. Для значень, які мають володіння, таких як <code>String</code>, значення будуть переміщені і хешмапа буде володіти цими значеннями, як це показано у Блоці коду 8-22.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from(&quot;Favorite color&quot;);
    let field_value = String::from(&quot;Blue&quot;);

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name and field_value are invalid at this point, try using them and
    // see what compiler error you get!
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-22: демонстрація, що ключі та значення є у володінні хешмапи після додавання</span></p>
<p>Ми не можемо використовувати змінні <code>field_name</code> і <code>field_value</code> після переміщення в хешмапу за допомогою виклику <code>insert</code>.</p>
<p>Якщо ми вставляємо посилання на значення до хешмапи, ці значення не будуть переміщені до хешмапи. Значення, на які вказують посилання, мають бути коректними щонайменше стільки ж, скільки існує хешмапа. Ви поговоримо більше про ці справи у підрозділі <a href="">&quot;Перевірка коректності посилань за допомогою часів існування&quot;</a><!-- ignore --> Розділу 10.</p>
<h3 id="Оновлення-хешмапи"><a class="header" href="#Оновлення-хешмапи">Оновлення хешмапи</a></h3>
<p>Хоча кількість пар ключів і значень зростає, кожен унікальний ключ може мати тільки одне значення, пов’язане з ним, в кожен момент (але не навпаки: наприклад, команда Синя і Жовта могли мати значення 10, збережене в хешмапі <code>scores</code>).</p>
<p>Коли ви хочете змінити дані в хешмапі, вам необхідно вирішити, як обробляти випадок, коли ключ уже має присвоєне значення. Ви можете замінити старе значення на нове значення, повністю проігнорувавши старе значення. Ви можете зберегти старе значення і проігнорувати нове значення, і лише коли ключ <em>не має</em> значення, додавати нове. Або ж ви можете поєднати старе значення і нове значення. Подивімося, як зробити кожен варіант!</p>
<h4 id="Перезапис-значення"><a class="header" href="#Перезапис-значення">Перезапис значення</a></h4>
<p>Якщо ми вставляємо ключ і значення до хешмапи і тоді вставляємо той самий ключ із іншим значенням, то значення, асоційоване з цим ключем, буде замінено. Попри те, що код у Блоці коду 8-23 викликає <code>insert</code> двічі, хешмапа міститиме лише одну пару ключ/значення, оскільки ми обидва рази вставляємо значення для ключа Синьої команди.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Blue&quot;), 25);

    println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-23: заміна значення, збереженого з певним ключем</span></p>
<p>Цей код виведе <code>{&quot;Blue&quot;: 25}</code>. Початкове значення <code>10</code> було перезаписане.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="only-inserting-a-value-if-the-key-has-no-value"></a></p>
<h4 id="Додавання-ключа-та-значення-тільки-якщо-ключ-відсутній"><a class="header" href="#Додавання-ключа-та-значення-тільки-якщо-ключ-відсутній">Додавання ключа та значення тільки якщо ключ відсутній</a></h4>
<p>Доволі поширено перевіряти, чи певний ключ уже присутній у хешмапі зі значенням, а тоді якщо ключ існує, то наявне значення має залишатися таким, яким воно є. Якщо ж ключ відсутній, вставити його і значення для нього.</p>
<p>Хешмапи мають спеціальне API для цього, що зветься <code>entry</code>, яке приймає параметром ключ, який ви хочете перевірити. Значення, що повертається з методу <code>entry</code> - це енум, що зветься <code>Entry</code>, який представляє значення, що може існувати або не існувати. Скажімо, ми хочемо перевірити, чи ключ для Жовтої команди має пов'язане з ним значення. Як ні, ми хочемо вставити значення 50, і те саме для Синьої команди. За допомогою API <code>entry</code>, код стає схожим на Блок коду 8-24.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from(&quot;Blue&quot;), 10);

    scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
    scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

    println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-24: використання методу <code>entry</code> для вставляння лише якщо ключ ще не має відповідного значення</span></p>
<p>Метод <code>or_insert</code> для <code>Entry</code> за визначенням повертає мутабельне посилання на відповідний ключ <code>Entry</code>, якщо ключ існує, а як ні, то вставляє параметр як нове значення для цього ключа і повертає мутабельне посилання на нове значення. Ця техніка набагато чистіша, ніж написання логіки самостійно і ще, крім того, краще працює з borrow checker.</p>
<p>Запуск коду у Блоці коду 8-24 надрукує <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>. Перший виклик <code>entry</code> вставить ключ для Жовтої команди зі значенням 50, бо Жовта команда ще не має свого значення. Другий виклик <code>entry</code> не змінить хешмапу, бо Синя команда вже має значення 10.</p>
<h4 id="Оновлення-значення-на-основі-старого-значення"><a class="header" href="#Оновлення-значення-на-основі-старого-значення">Оновлення значення на основі старого значення</a></h4>
<p>Інший поширений сценарій використання хешмап - пошук значення ключа і оновлення його на основі старого значення. Наприклад, Блок коду 8-25 показує код, який підраховує, скільки разів кожне слово з'являється в певному тексті. Ми використовуємо хешмапу з ключами - словами і збільшуємо значення, щоб відстежувати, скільки разів ми бачили це слово. Якщо ми зустрічаємо слово уперше, то спершу вставляємо значення 0.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = &quot;hello world wonderful world&quot;;

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!(&quot;{:?}&quot;, map);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 8-25: підрахунок кількості слів за допомогою хешмапи слів, що зберігає слова і кількість</span></p>
<p>Цей код виведе <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. Ви можете побачити ті ж пари ключів/значень, виведені в іншому порядку: згадайте з підрозділу <a href="ch08-03-hash-maps.html#accessing-values-in-a-hash-map">&quot;Доступ до значень у хешмапі&quot;</a><!-- ignore --> , що ітерування по хешмапі відбувається у довільному порядку.</p>
<p>Метод <code>split_whitespace</code> повертає ітератор по підслайсах, розділених пробілами, значення у <code>text</code>. Метод <code>or_insert</code> повертає мутабельне посилання (<code>&amp;mut V</code>) на значення для вказаного ключа. Тут ми зберігаємо це мутабельне посилання у змінній <code>count</code>, тож для того, щоб присвоїти цьому значенню, нам необхідно спочатку розіменувати <code>count</code> за допомогою зірочки (<code>*</code>). Мутабельне посилання виходить з області видимості в кінці циклу <code>for</code>, тож всі ці зміни є безпечними та дозволеними правилами позичання.</p>
<h3 id="Функції-хешування"><a class="header" href="#Функції-хешування">Функції хешування</a></h3>
<p>За замовчуванням, <code>HashMap</code> використовує функцію хешування під назвою <em>SipHash</em>, яка забезпечує стійкість до атак на відмову в обслуговуванні (Denial of Service, DoS) з використанням хеш-таблиць <sup class="footnote-reference"><a href="#siphash">1</a></sup><!-- ignore -->. Це не найшвидший з доступних алгоритмів хешування, але покращення безпеки, отримане з падінням продуктивності, того варте. Якщо ви профілюєте свій код і виявите, що функція хешування за замовчуванням є надто повільною для ваших потреб, ви можете перейти на іншу функцію, вказавши інший хешер. <em>Хешер</em> - це тип, який реалізує трейт <code>BuildHasher</code>. Ми поговоримо про трейти і як їх реалізовувати у Розділі 10. Вам не обов'язково потрібно реалізувати власний хеш з нуля; <a href="https://crates.io/">crates.io</a><!-- ignore --> містить бібліотеки, надані іншими користувачами Rust, що забезпечують реалізацію багатьох поширених алгоритмів хешування.</p>
<h2 id="Підсумок-7"><a class="header" href="#Підсумок-7">Підсумок</a></h2>
<p>Вектори, стрічки та хешмапи забезпечать значну частину функціональності, необхідної для програм під час зберігання, доступу і зміни даних. Ось деякі вправи, які ви вже маєте бути в змозі виконати:</p>
<ul>
<li>Дано список цілих чисел; використайте вектор і поверніть медіану (значення посередині після сортування) та моду (значення, яке зустрічається найчастіше; тут стане в пригоді хешмапа) цього списку.</li>
<li>Перетворіть рядки на &quot;поросячу латину&quot;. Перший приголосний кожного слова переноситься в кінець слова і додається &quot;ay&quot;, так що &quot;first&quot; стає &quot;irst-fay.&quot; До слів, що починаються на голосну, натомість додається в кінці “hay” (“apple” стає “apple-hay”). Не забувайте, що використовується кодування UTF-8!</li>
<li>За допомогою хешмапи і векторів створіть текстовий інтерфейс, що дозволить користувачеві додати імена співробітників у відділ компанії. Наприклад, “Add Sally to Engineering” чи “Add Amir to Sales.” Тоді дайте користувачеві можливість отримати список усіх людей у відділі чи всіх людей у компанії по відділах, відсортованих за алфавітом.</li>
</ul>
<p>Документація API стандартної бібліотеки описує методи, які мають вектори, стрічки і хешпами, які будуть корисними для цих вправ!</p>
<p>Ми переходимо до складніших програм, у яких операції можуть зазнавати невдачу, тому зараз ідеальний час для обговорення обробки помилок. Цим ми й займемося!
ch10-03-lifetime-syntax.html#validating-references-with-lifetimes</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Обробка-помилок"><a class="header" href="#Обробка-помилок">Обробка помилок</a></h1>
<p>Помилки є частиною звичайного життя в програмному забезпеченні, тому Rust має ряд можливостей для обробки ситуацій, коли щось йде не так. У багатьох випадках Rust вимагає від вас визнати можливість помилки та вжити певних дій перед тим, як ваш код буде скомпільовано. Ця вимога робить вашу програму більш надійною, забезпечуючи що ви будете виявляти помилки та поводитися з ними належним чином, перш ніж ви розгорнете свій код у production!</p>
<p>Rust групує помилки у дві основні категорії: <em>виправні</em> та <em>невиправні</em> помилки. Для виправних помилок, таких як помилка <em>файл не знайдено</em>, ми, швидше за все, захочемо просто повідомити про проблему користувачеві й спробувати знову повторити операцію. Невиправні помилки завжди є ознаками вад, наприклад спроба отримати доступ до місця в пам'яті після закінчення масиву, і тому ми хочемо негайно зупинити програму.</p>
<p>Більшість мов не розрізняють ці два види помилок і обробляють їх однаково, використовуючи механізми, такі як виняткові ситуації. У Rust немає виняткових ситуацій. Натомість вона має тип <code>Result&lt;T, E&gt;</code> для виправних помилок та макрос <code>panic!</code>, що зупиняє виконання, коли програма зіткнулася з невиправною помилкою. Цей розділ спершу охоплює виклик <code>panic!</code>, а потім розповідає про повернення значень <code>Result&lt;T, E&gt;</code>. Крім того, ми розглянемо міркування при ухваленні рішення про те, чи намагатися відновитися після помилки, чи зупинити виконання.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Невідновні-Помилки-із-panic"><a class="header" href="#Невідновні-Помилки-із-panic">Невідновні Помилки із <code>panic!</code></a></h2>
<p>Іноді погані речі трапляються у вашому коді з якими ви нічого не можете зробити. У цих випадках Rust має макрос <code>panic!</code>. Є два практичних способи викликати паніку: зробивши дію, яка призведе до паніки (наприклад отримати доступ до елемента масиву за його межами) або явно викликавши макрос <code>panic!</code>. В обох випадках ми викличемо паніку в нашій програмі. За замовчуванням, ці паніки виведуть в консолі повідомлення про помилку, розгорнуть та очистять стек та закриють програму. За допомогою змінної середовища ви також можете скерувати Rust показати стек викликів, коли виникне паніка, щоб полегшити відстеження її джерела.</p>
<blockquote>
<h3 id="Розгортання-Стека-або-Переривання-у-Відповідь-на-Паніку"><a class="header" href="#Розгортання-Стека-або-Переривання-у-Відповідь-на-Паніку">Розгортання Стека або Переривання у Відповідь на Паніку</a></h3>
<p>За замовчуванням, коли виникає паніка, програма запускає <em>розгортання</em>. Це означає, що Rust проходиться по стеку та очищає дані всіх зустрічних функцій. Проте ця розгортка та очищення це багато роботи. Отже, Rust дозволяє вибрати альтернативу: негайно завершувати програму без її очищення.</p>
<p>Пам'ять, яку використовувала програма, тоді буде очищена операційною системою. Якщо у вашому проєкті вам потрібно зробити кінцевий бінарний файл якомога менше, ви можете змінити поведінку програми при паніці з розгортки стеку на негайне переривання додавши <code>panic = 'abort'</code> у відповідну секцію <code>[profile]</code> у вашому файлі <em>Cargo.toml</em>. Наприклад, якщо ви хочете негайне переривання паніки у режимі збірки, додайте наступне:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Спробуймо викликати <code>panic!</code> у простій програмі:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<p>Коли ви запускаєте програму, ви побачите щось на зразок цього:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Виклик <code>panic!</code> призвів до повідомлення про помилку, що міститься в останніх двох рядках. Перший рядок показує наше повідомлення про паніку і місце в нашому початковому коді, де вона сталася: <em>src/main.rs:2:5</em> вказує, що це другий рядок, п'ятий символ нашого файлу <em>src/main.rs</em>.</p>
<p>У цьому випадку зазначений рядок є частиною нашого коду, і якщо ми перейдемо до цього рядка, ми побачимо виклик макроса <code>panic!</code>. В інших випадках виклик <code>panic!</code> може бути в коді, який викликає наш код, а назва файлу і номер рядка, звітований повідомленням про помилку, буде чужим кодом, де викликається макрос <code>panic!</code>, а не рядок нашого коду, який зрештою призвів до <code>panic!</code>. Ми можемо використати бектрейс функції з якої прийшов виклик <code>panic</code>, щоб дізнатися, яка частина нашого коду викликає проблему. Ми обговоримо бектрейс у деталях пізніше.</p>
<h3 id="Використання-Бектрейсу-panic"><a class="header" href="#Використання-Бектрейсу-panic">Використання Бектрейсу <code>panic!</code></a></h3>
<p>Розглянемо ще один приклад, коли виклик <code>panic!</code> йде з бібліотеки через помилку в нашому коді, а не через прямий виклик макроса нашим кодом. Блок коду 9-1 намагається отримати доступ до елемента вектора поза меж діапазону припустимих індексів.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p><span class="caption">Блок коду 9-1: Спроба отримати доступ до елемента вектора за межами його кінця викличе <code>panic!</code></span></p>
<p>Тут ми намагаємося отримати доступ до 100-го елемента нашого вектора (який знаходиться за індексом 99, бо індексування починається з нуля), але вектор має всього 3 елементи. В цій ситуації Rust панікуватиме. Використання <code>[]</code> повинно повернути елемент, але якщо передати не валідний індекс, то не буде елементу, який Rust може повернути, що було б правильним.</p>
<p>У C спроба прочитати за межами кінця структури даних це не визначена поведінка або undefined behaviour. Ви можете отримати те, що розташоване в місці в пам'яті та відповідає цьому елементу структури даних, навіть якщо пам'ять не належить цій структурі. Це називається <em>читання поза межами буфера або buffer overread</em> і може стати причиною появи уразливостей в безпеці, якщо нападник здатен маніпулювати індексом таким чином, щоб прочитати дані які зберігаються поза структурою даних до яких він не має права на доступ.</p>
<p>Щоб захистити вашу програму від такого роду уразливості, при спробі прочитати елемент за індексом, якого не існує, Rust зупинить виконання програми. Спробуймо:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Ця помилка вказує на рядок 4 нашого файлу <code>main.rs</code>, де ми намагаємося отримати доступ до елемента за індексом
99. Наступний рядок каже нам, що ми можемо встановити змінну середовища <code>RUST_BACKTRACE</code> для отримання бектрейсу того, що саме стало причиною помилки. <em>Бектрейс</em> це список усіх функцій які були викликані до появи помилки. Бектрейси в Rust працюють так само як і в інших мовах: Читати бекстрейс потрібно зверху вниз й читати доти, доки ви не побачите назви ваших файлів. Ось місце, де виникла проблема. Рядки зверху це те, що викликано вашим кодом; рядки знизу це код, який викликає код зверху. Ці &quot;до-та-після&quot; рядки можуть включати код ядра Rust, код стандартної бібліотеки, або крейтів, що ви використовуєте. Спробуймо отримати бектрейс встановивши змінну середовища <code>RUST_BACKTRACE</code> будь-яке значення окрім 0. Блок коду 9-2 показує вивід схожий на те, що ви побачите.</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14
   2: core::panicking::panic_bounds_check
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9
   6: panic::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p><span class="caption">Блок коду 9-2: Бектрейс утворений викликом &lt;0&gt;panic!&lt;/0&gt; показує, коли змінна середовища &lt;0&gt;RUST_BACKTRACE&lt;/0&gt; була встановлена</span></p>
<p>Це багато виводу! Точний вивід може відрізнятися в залежності від версії операційної системи та версії Rust. Для того, щоб отримати бектрейс із цією інформацією, мають бути увімкнені дебаг символи. Дебаг символи увімкнуті за замовчуванням коли ви використовуєте <code>cargo build</code> або <code>cargo run</code> без позначки <code>--release</code>, як ми зробили тут.</p>
<p>У виводі Блока коду 9-2, рядок 6 бектрейсу вказує на наш рядок який спричиняє проблему: рядок 4 файлу <em>src/main.rs</em>. Якщо ми не хочемо, щоб наша програма панікувала, ми повинні почати наше розслідування з першого рядка, де згадується написаний нами файл. В Блоці коду 9-1, де ми навмисно написали код, який викличе паніку, спосіб виправлення паніки це не запитувати елемент поза межами діапазону індексів вектора. Надалі коли ваш код панікуватиме, вам потрібно буде з'ясовувати, які дії виконує код із якими значеннями щоб спричинити паніку і що код повинен робити натомість.</p>
<p>Ми ще повернемося до <code>panic!</code> і до того, коли нам слід і не слід використовувати <code>panic!</code> для обробки умов помилок у секції <a href="">&quot;To <code>panic!</code>or Not to <code>panic!</code>”</a><!-- ignore --> пізніше у цьому розділі. Далі ми розглянемо, як відновляти помилки за допомогою <code>Result</code>.
ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Помилки-що-піддаються-відновленню-за-допомогою-result"><a class="header" href="#Помилки-що-піддаються-відновленню-за-допомогою-result">Помилки, що піддаються відновленню за допомогою <code>Result</code></a></h2>
<p>Більшість помилок не є достатньо серйозними, щоб вимагати повної зупинки виконання програми. Іноді, якщо функція не спрацьовує, то це можна досить просто пояснити й відреагувати певним чином. Наприклад, якщо ви намагаєтесь відкрити файл і ця операція зазнає невдачі, тому що такого файлу немає, то замість завершення процесу ви б захотіли створити такий файл.</p>
<p>Нагадаємо з підрозділу <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result">Керування потенційною невдачею за допомогою типу <code>Result</code></a><!--
ignore --> в Розділі 2, що </p>
<p><code>Result</code> визначається як енум, що має два можливих значення <code>Ok</code> та <code>Err</code>, наступним чином:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>T</code> and <code>E</code> це параметри, що відносять до узагальнених типів, які ми розглянемо більш детально у розділі 10. Все, що вам необхідно знати на даний момент, що <code>T</code> представляє тип значення, яке буде повернуто результатом успішного виконання як вміст варіанту <code>Ok</code>, а <code>E</code> представляє тип помилки, що буде повернуто як вміст варіанту <code>Err</code> у випадку невдачі. Оскільки <code>Result</code> містить ці узагальнені типи параметрів, ми можемо використовувати тип <code>Result</code> і функції, що визначені для нього у стандартній бібліотеці, для різних випадків, коли значення успішного виконання і значення невдачі, які ми хочемо повернути, можуть відрізнятися.</p>
<p>Спробуймо викликати функцію, яка повертає значення типу <code>Result</code>, оскільки ця функція може не спрацювати. В блоці коду 9-3 ми спробуємо відкрити файл.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Блок коду 9-3: Відкривання файлу</span></p>
<p>Типом, який повертає <code>File::open</code> є <code>Result&lt;T, E&gt;</code>. Узагальнений параметр <code>T</code> був визначений в реалізації <code>File::open</code>, як тип значення при успіху при обробці файлу, а саме <code>std::fs::File</code>. Тип <code>E</code>, що використовується, як значення помилки, визначений як <code>std::io::Error</code>. Цей тип значення, що повертається, означає, що виклик <code>File::open</code> може бути успішним і повернути обробник файлу, за допомогою якого ми можемо його зчитувати, або записувати. Також виклик функції може завершитися не успішно, наприклад файлу може ще не існувати, або у нас не буде дозволів на обробку цього файлу. Функція <code>File::open</code> має мати можливість сповістити нас, чи виклик був успішним чи ні, і дати нам або обробник файлу, або інформацію про помилку. Ця інформація і є безпосередньо тим, що являє собою енум <code>Result</code>.</p>
<p>У випадку, коли виклик <code>File::open</code> був успішним, значенням змінної <code>greeting_file_result</code> буде екземпляр <code>Ok</code>, що містить обробник файлу. А у випадку помилки, значенням <code>greeting_file_result</code> буде екземпляр <code>Err</code>, який містить інформацію про тим помилкової ситуації, що сталася.</p>
<p>Ми повинні розширити блок коду 9-3, щоб зрозуміти різні підходи в залежності від значення, яке повертає <code>File::open</code>. Блок коду 9-4 демонструє один із способів обробки <code>Result</code>, використовуючи базові підхід, такий як вираз співставлення зі зразком (<code>match</code>), що розглядався у розділі 6.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;Problem opening the file: {:?}&quot;, error),
    };
}
</code></pre></pre>
<p><span class="caption">Блок коду 9-4: Використання <code>match</code> виразу для обробки варіантів <code>Result</code></span></p>
<p>Звернуть увагу, що аналогічно до енума <code>Option</code>, енум <code>Result</code> і його варіанти вже введені в область видимості прелюдії, тому немає необхідності вказувати <code>Result::</code> перед варіантами <code>Ok</code> і <code>Err</code> в рукавах виразу співставлення зі зразком <code>match</code>.</p>
<p>Коли результат буде рівний <code>Ok</code>, нам необхідно повернути внутрішнє значення <code>file</code> з варіанту <code>Ok</code>, таким чином при присвоїмо значення обробника файлу змінній <code>greeting_file</code>. Після виразу <code>match</code> ми можемо використовувати обробник файлу для запису чи зчитування.</p>
<p>Другий рукав виразу <code>match</code> обробляє випадок, коли отримуємо значення <code>Err</code> результатом виконання <code>File::open</code>. В нашому прикладі ми вирішили викликати макрос <code>panic!</code>. Якщо в поточному каталозі немає файлу з іменем <em>hello.txt</em> і ми запустимо наш код, то завдяки макрокоманді <code>panic!</code> побачимо наступний вивід:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Як завжди, цей вивід розкаже нам, що саме пішло не так.</p>
<h3 id="Застосування-виразу-match-для-різних-помилок"><a class="header" href="#Застосування-виразу-match-для-різних-помилок">Застосування виразу match для різних помилок</a></h3>
<p>Код у блоці 9-4 буде завершиться панікою, незалежно від того, чому виклик <code>File::open</code> не спрацював. Однак, ми б хотіли виконати різні дії для різних причин неуспішного виконання: якщо <code>File::open</code> не відпрацьовує, оскільки файл не існує, ми б хотіли створити такий файл і повернути обробник для цього нового файлу. Якщо ж <code>File::open</code> не спрацював через будь-які інші причини, наприклад, у нас немає дозволів для відкриття файлу, ми б все ж таки хотіли викликати <code>panic!</code> таким самим чином, як це було в блоці коду 9-4. Для цього ми додамо вкладений вираз <code>match</code>, як показано у блоці коду 9-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem creating the file: {:?}&quot;, e),
            },
            other_error =&gt; {
                panic!(&quot;Problem opening the file: {:?}&quot;, other_error);
            }
        },
    };
}
</code></pre>
<p><span class="caption">Блок коду 9-5: Обробка різних типів помилок різним способом</span></p>
<p>Тип значення, який повертає <code>File::open</code> всередині варіантів <code>Err</code> є <code>io::Error</code>, який в свою чергу є структурою, що поставляється стандартною бібліотекою. Ця структура має метод <code>kind</code>, при виклику якого отримаємо <code>io::ErrorKind</code> значення. Енум <code>io::ErrorKind</code> поставляється у стандартній бібліотеці і має варіанти, які представляють різні типи помилок, що можуть бути результатом операції <code>io</code>. Варіант, який ми хочемо використати, це <code>ErrorKind::NotFound</code>. Цей варіант сигналізує нам, що файлу, який ми намагаємось відкрити, не існує. Тому ми застосовуємо вираз match у <code>greeting_file_result</code>, а також ми маємо вкладений вираз match для <code>error.kind()</code>.</p>
<p>У внутрішньому виразі match ми хочемо перевірити, чи значення, що повертає метод <code>error.kind()</code> є варіантом <code>NotFound</code> енума <code>ErrorKind</code>. Якщо ж так і є, ми пробуємо створити такий файл за допомогою методу <code>File::create</code>. Однак, оскільки метод <code>File::create</code> може також завершитися не успішно, нам треба ще один рукав всередині вкладеного виразу <code>match</code>. Якщо файл не може бути створено, то виводимо інше повідомлення про помилку. Другий рукав зовнішнього виразу <code>match</code> залишається незмінним, тому програма підіймає паніку на будь-які інші помилки за виключенням помилки відсутнього файлу.</p>
<blockquote>
<h3 id="Альтернативи-використанню-виразу-match-для-значень-типу-resultt-e"><a class="header" href="#Альтернативи-використанню-виразу-match-для-значень-типу-resultt-e">Альтернативи використанню виразу <code>match</code> для значень типу <code>Result&lt;T, E&gt;</code></a></h3>
<p>Схоже, що у нас забагато <code>match</code>! Вираз <code>match</code> дуже корисний, проте дуже примітивний. У розділі 13 ми будемо вивчати замикання, які використовуються  у комбінації з багатьма методами, які визначені для типу <code>Result&lt;T, E&gt;</code>. Ці методи можуть бути більш виразними за використання виразу <code>match</code>, коли працюємо зі значеннями <code>Result&lt;T, E&gt;</code> у своєму коді.</p>
<p>Прикладом може бути інший спосіб описати таку ж саму логіку, що показана у блоці коду 9-5, але з використанням замикань і методу <code>unwrap_or_else</code>:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem creating the file: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;Problem opening the file: {:?}&quot;, error);
        }
    });
}
</code></pre>
<p>Хоча цей код має таку ж поведінку, що і код у блоці 9-5, він не містить жодного  виразу <code>match</code> і зрозуміліший для читання. Повертайтесь до цього прикладу після того, як прочитаєте розділ 13 і познайомтесь з методом <code>unwrap_or_else</code> у документації до стандартної бібліотеки. Також багато інших методів можуть допомогти справитися з великою кількістю вкладений між собою виразів <code>match</code>, при роботі з помилками.</p>
</blockquote>
<h3 id="Короткі-форми-для-паніки-на-помилках-unwrap-і-expect"><a class="header" href="#Короткі-форми-для-паніки-на-помилках-unwrap-і-expect">Короткі форми для паніки на помилках: <code>unwrap</code> і <code>expect</code></a></h3>
<p>Використання виразу <code>match</code> працює достатньо добре, але може бути занадто багатослівним і не завжди добре передавати наші наміри. Тип <code>Result&lt;T, E&gt;</code> має багато допоміжних методів, які визначені для того, щоб здійснити більш специфічні обробки. Метод <code>unwrap</code> є скороченням імплементації виразу <code>match</code>, як це було зроблено у блоці коду 9-4. Якщо значення <code>Result</code> є варіантом <code>Ok</code>, метод <code>unwrap</code> поверне значення, як міститься всередині <code>Ok</code>. Якщо ж <code>Result</code> є варіантом <code>Err</code>, то метод <code>unwrap</code> викличе макрос <code>panic!</code> для нас. Ось приклад методу <code>unwrap</code> у дії:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>Якщо ми виконаємо код без існуючого файлу <em>hello.txt</em>, ми отримаємо повідомлення про помилку із виклику <code>panic!</code>, який здійснить метод <code>unwrap</code>:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {
code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }',
src/main.rs:4:49
</code></pre>
<p>Аналогічний метод <code>expect</code> дозволяє додатково нам вибрати повідомлення про помилку для макрокоманди <code>panic!</code>. Використання методу <code>expect</code> замість <code>unwrap</code> разом із заданням хороших повідомлень про помилку допоможе краще передати ваші наміри й спростить відстежування причин такої паніки. Синтаксис методу <code>expect</code> виглядає наступним чином:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)
        .expect(&quot;hello.txt should be included in this project&quot;);
}
</code></pre></pre>
<p>Ми використовуємо <code>expect</code> в такий самий спосіб, як і <code>unwrap</code>, щоб повернути обробник файлу або викликати макрос <code>panic!</code>. Повідомленням про помилку, що використовує метод <code>expect</code> у виклику макросу <code>panic!</code>, буде параметром, який ми передаємо у <code>expect</code>, замість стандартного повідомлення макросу <code>panic!</code>, яку використовує <code>unwrap</code>. Ось як це виглядає:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'hello.txt should be included in this project: Os {
code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }',
src/main.rs:5:10
</code></pre>
<p>Частіше програмісти на Rust віддають перевагу у своєму коді методу <code>expect</code> аніж <code>unwrap</code>, додаючи більше контексту з роз'ясненням, чому дана операція має бути завжди успішною для виконання. Таким чином, навіть якщо ваші припущення були не до кінця точними у такій ситуації, у вас буде більше інформації під час відлагодження.</p>
<h3 id="Поширення-помилок"><a class="header" href="#Поширення-помилок">Поширення помилок</a></h3>
<p>Коли ви пишите функцію, імплементація якої може викликати щось, що може не спрацювати, тоді замість обробки помилки всередині функції, ви можете повернути помилку тій частині коду, що її викликала. І тоді вже ця частина коду буде вирішувати, що робити з цією помилкою. Це називається <em>розповсюдженням</em> помилки й дає більше контролю викликаючому коду, де, можливо, є більше інформації або логіки, які диктують, як ця помилка має бути оброблено, ніж те що є доступним в контексті вашого коду функції.</p>
<p>Для прикладу блок коду 9-6 показує функцію, яка зчитає username з файлу. Якщо ж файл не існує або його неможливо прочитати, то цю функція поверне ці помилки в код, який викликає дану функцію.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open(&quot;hello.txt&quot;);

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 9-6: Функція, яка повертає помилки в код, який її викликає за допомогою виразу <code>match</code></span></p>
<p>Вказану функцію також можливо написати коротшим способом, але ми почнемо з того, що зробимо більшу частину самостійно, для того, щоб познайомитися з обробкою помилок. В кінці ми продемонструємо коротший спосіб. Давайте спочатку розглянемо тип значення, яке повертає функція: <code>Result&lt;String, io::Error&gt;</code>. Це означає, що функція повертає значення типу <code>Result&lt;T, E&gt;</code>, де узагальнений параметр <code>T</code> був підставлений конкретним типом <code>String</code>, а узагальнений тип <code>E</code> конкретним типом <code>io::Error</code>.</p>
<p>Якщо виклик функції відпрацює успішно без жодних проблем, то код, який викликає її, отримає значення типу <code>Ok</code>, яке містить <code>String</code> - тобто username, який був зчитаним функцією з файлу. Якщо ж виконання функції зіткнеться з якимось проблемами, код,який викликав її отримає значення <code>Err</code>, яке містить екземпляр <code>io::Error</code>, який, в свою чергу, містить більше інформації стосовно характеру проблем. Ми вибрали <code>io::Error</code> як тип значення, що повертається з неї, тому що вона є типом помилок обох функцій, що можуть виконатись не успішно, які ми викликаємо в тілі нашої функції: функція <code>File::open</code> і <code>read_to_string</code>.</p>
<p>Тіло функції починається з виклику методу <code>File::open</code>. Далі ми обробляємо значення <code>Result</code> за допомогою виразу <code>match</code>, схоже до того, що було у блоці коду 9-4. Якщо виклик <code>File::open</code> буде успішним, тоді обробник файлу буде міститися у змінній <code>file</code> виразу співставлення, який стане значення мутабельної змінної <code>username_file</code> і виконання функції буде продовжуватися. А у випадку значення <code>Err</code>, замість виклику <code>panic!</code>, ми використовуємо ключове слово <code>return</code> для передчасного виходу з функції з поверненням значення помилки в місце виклику нашої функції, яку отримаємо з виклику <code>File::open</code> як внутрішню змінну зіставлення <code>e</code>.</p>
<p>Якщо ми маємо обробник файлу у змінній <code>username_file</code>, тоді функція створить нове значення <code>String</code> у змінній <code>username</code> і викличе метод <code>read_to_string</code> на обробнику файлу <code>username_file</code>, щоб прочитати контент цього файлу у значення змінної <code>username</code>. Метод <code>read_to_string</code> також повертає <code>Result</code>, оскільки може виконатись не успішно, навіть виконання <code>File::open</code> було успішним до цього. Тому нам потрібно ще один вираз <code>match</code> для обробки цього <code>Result</code>: якщо <code>read_to_string</code> був успішним, то і виконання нашої функції теж успішне і повертаємо значення username з файлу, огорнутим у <code>Ok</code>. Якщо є <code>read_to_string</code> виконалось не успішно, ми просто повертаємо помилку у той самий спосіб, як і у виразі <code>match</code>, що обробляв значення виклику <code>File::open</code>. Однак нам непотрібно явно використовувати <code>return</code>, оскільки це останній вираз нашої функції.</p>
<p>Код, який викликає цей має обробити отримані або значення <code>Ok</code>, що містить username або значення <code>Err</code>, яке містить <code>io::Error</code>. Ми не повинні знати, що саме код який викликає буде робити з отриманими значеннями. Якщо він отримає значення <code>Err</code>, то може або викликати <code>panic!</code> і зупинити виконання програми, або скористатися іменем користувача по замовчуванню, або знайти його де інде. Ми не маємо достатньої інформації стосовно того, що саме код, який викликає буде робити, тому ми поширюємо всю інформацію, як і успішного виконання, так і не успішного вгору, для обробки її належним чином.</p>
<p>Цей патерн поширення помилок є дуже поширеним в Rust, тому Rust має спеціальний оператор знаку питання <code>?</code>, для роботи з цим більш зручний спосіб.</p>
<h4 id="Коротка-форма-поширення-помилок-оператором-"><a class="header" href="#Коротка-форма-поширення-помилок-оператором-">Коротка форма поширення помилок оператором <code>?</code></a></h4>
<p>Блок коду 9-7 демонстрував імплементацію функції <code>read_username_from_file</code>, яка має таку ж функціональність, як і функція в блоці коду 9-6, але дана реалізація використовувала оператор <code>?</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open(&quot;hello.txt&quot;)?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 9-7: Функція, яка повертає помилки коду, який її викликає за допомогою оператора <code>?</code></span></p>
<p>Якщо розмістити оператор <code>?</code> після значення <code>Result</code>, то він буде працювати таким самим чином, як і вираз <code>match</code>, який ми визначали для обробки значення <code>Result</code> в блоці коду 9-6. Якщо значення <code>Result</code> є <code>Ok</code>, то значення, що знаходиться всередині <code>Ok</code>, буде повернутим як результат виразу і програма продовжить виконання. Якщо ж значення є <code>Err</code>, то в цілому з функції буде повернуто <code>Err</code>, так ніби ми використали ключове слово <code>return</code> і значення помилки буде передано функції, що викликала даний код.</p>
<p>Є певна різниця між тим, що виконує вираз <code>match</code> з блоку коду 9-6 і тим, що виконує оператор <code>?</code>. Значення помилок, при яких викликається оператор <code>?</code> проходять через виклик функції <code>from</code>, яка визначена на трейті <code>From</code> стандартної бібліотеки і використовується для конвертації значень із одного типу в інший. Коли оператор <code>?</code> викликає функцію <code>from</code>, отриманий тип помилки конвертується в тим помилки, який був визначений типом, що повертається з поточної функції. Це корисно, коли функція повертає один тип помилки, який являє собою всі можливі шляхи, при яких функція може виконатись не успішно, навіть якщо її частини можуть завершуватись не успішно з різних причин.</p>
<p>Для прикладу, ми б могли змінити функцію <code>read_username_from_file</code> в блоці коду 9-7, щоб вона повертала кастомізований тип помилки визначений нами, який б називався <code>OurError</code>. Якщо ми також визначимо імплементацію <code>impl From</code> для типу <code>OurError</code> при створенні екземпляру <code>OurError</code> із <code>io::Error</code>, тоді виклик оператора <code>?</code> в тілі функції <code>read_username_from_file</code> викличе метод &lt;0&gt;from&lt;/0&gt; і здійснить конвертацію типу помилки без необхідності додавання жодного коду у нашу функцію.</p>
<p>В контексті блоку коду 9-7, оператор <code>?</code> в кінці виклику функції <code>File::open</code> поверне значення значення всередині <code>Ok</code> у змінну <code>username_file</code>. Якщо ж помилка виникне, то оператор <code>?</code> припинить виконання функції заздалегідь і поверне якесь значення <code>Err</code> коду, який її викликав. Те ж саме буде справедливим для оператора <code>?</code> в кінці виклику методу <code>read_to_string</code>.</p>
<p>Оператор <code>?</code> дозволяє уникнути надлишкового коду у функціях і робить їх імплементацію простішою. Ми можемо навіть ще більше скоротити код, об'єднуючи виклики методів в ланцюжок відразу після оператора <code>?</code>, як це показано в блоці коду 9-8.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 9-8: Ланцюжок викликів методів після оператора <code>?</code></span></p>
<p>Ми перенесли створення нового екземпляру <code>String</code> в <code>username</code> на початок функції. Замість створення змінної <code>username_file</code>, ми приєднали ланцюжком виклик <code>read_to_string</code> прямо до результату виклику <code>File::open(&quot;hello.txt&quot;)?</code>. Ми все ще маємо оператор <code>?</code> в кінці виклику <code>read_to_string</code> і все ще повертаємо значення <code>Ok</code>, яке містить <code>username</code>, якщо обидва виклики <code>File::open</code> і <code>read_to_string</code> завершаться успішно, а не повертаємо помилки. Ця функціональність знову ж таки аналогічна тій, що представлена у блоках коду 9-6 і 9-7 з однією тільки відмінністю, що такий шлях більш ергономічний для написання.</p>
<p>Блок коду 9-9 демонструє ще коротший шлях використання <code>fs::read_to_string</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 9-9: Використання методу <code>fs::read_to_string</code> замість того, щоб відкривати файл і потім виконувати його зчитування</span></p>
<p>Зчитування файлу в стрічку є досить типовою операцією, тому стандартна бібліотека надає зручнішу функцію <code>fs::read_to_string</code>, яка відкриває файл, створює новий екземпляр <code>String</code>, зчитує вміст фалу, поміщає вміст в створений екземпляр стрічки <code>String</code> і повертає його. Звичайно, використання методу <code>fs::read_to_string</code> не дає можливості пояснити всі підходи до обробки помилок, тому ми спочатку пішли більш довгим шляхом.</p>
<h4 id="Де-можна-використовувати-оператор-"><a class="header" href="#Де-можна-використовувати-оператор-">Де можна використовувати оператор <code>?</code></a></h4>
<p>Оператор <code>?</code> може бути використаним тільки у функціях, які повертають тип, який сумісний зі значення, яке він може обробити. Це тому, що оператор <code>?</code> створений для обробки раннього повернення значення з функції в такий самий спосіб, як і вираз <code>match</code>, описаний у блоці коду 9-6. Тут вираз <code>match</code> використовує значення <code>Result</code> і повертає значення <code>Err(e)</code> по рукаву раннього виходу. Типом, що повертається з функції має бути тип <code>Result</code>, що є сумісним цим <code>return</code>.</p>
<p>Давайте розглянемо в блоці коду 9-10 помилку, яку отримаємо, якщо використаємо оператор <code>?</code> у функції <code>main</code>, яка має повертати тип, що не сумісний з типом значення, яке ми використовуємо з оператором <code>?</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p><span class="caption">Блок коду 9-10: Спроба використати оператор <code>?</code> всередині функції <code>main</code>, яка не скомпілюється, оскільки має повертати несумісний тип <code>()</code></span></p>
<p>Цей код відкриває файл, тому ця операція може виконатись не успішно. Оператор <code>?</code> слідує за значенням <code>Result</code>, який повертає <code>File::open</code>, але функція <code>main</code> має повертати тип <code>()</code>, а не тип <code>Result</code>. Коли ми спробуємо скомпілювати цей код, ми отримаємо наступне повідомлення про помилку компілювання:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | / fn main() {
4 | |     let greeting_file = File::open(&quot;hello.txt&quot;)?;
  | |                                                ^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
</code></pre>
<p>Ця помилка компілювання вказує на те, що ми можемо використовувати оператор <code>?</code> тільки у функціях, які повертають <code>Result</code>, <code>Option</code>, або інший тип, який імлементує <code>FromResidual</code>.</p>
<p>Для виправлення цієї помилки ми маємо два шляхи. Перший полягає в тому, щоб змінювати тип значення, яке повертаємо для нашої функції, щоб бути сумісним по типу зі значенням, яке використовуємо з оператором <code>?</code> до того моменту, поки немає жодних інших обмежень для цього. Інший полягає в тому, щоб використовувати вираз <code>match</code> або один із методів визначених для типу <code>Result&lt;T, E&gt;</code>, щоб обробити значення <code>Result&lt;T, E&gt;</code> більш підходящим способом.</p>
<p>Помилка компілювання також говорить, що оператор <code>?</code> також можна використовувати зі значенням <code>Option&lt;T&gt;</code>. Як і з використанням <code>?</code> на <code>Result</code>, ми можемо використовувати оператор <code>?</code> на <code>Option</code> у функціях, які повертають <code>Option</code>. Поведінка оператора <code>?</code>, коли викликаємо його на <code>Option&lt;T&gt;</code> є подібною до випадку з <code>Result&lt;T, E&gt;</code>: якщо значення <code>None</code>, то це значення буде повернуто достроково з функції. Якщо ж значення <code>Some</code>, то значення всередині <code>Some</code> буде значенням результату виразу і виконання функції буде продовжуватися далі. Блок коду 9-11 є прикладом функції, що знаходить останній символ в отриманому тексті:</p>
<pre><pre class="playground"><code class="language-rust">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line(&quot;Hello, world\nHow are you today?&quot;),
</span><span class="boring">        Some('d')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;&quot;), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;\nhi&quot;), None);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 9-11: Використання оператора <code>?</code> на значенні <code>Option&lt;T&gt;</code></span></p>
<p>Ця функція повертає <code>Option&lt;char&gt;</code>, тому що як є можливість, що символ може бути, так і можливість, що символу не буде. Ця функція приймає як аргумент стрічковий слайс <code>text</code> і викликає метод <code>lines</code> на ньому, який повертає ітератор над рядками у стрічці. Оскільки ця функція має отримати перший рядок, вона викликає метод <code>next</code> на ітераторі, щоб отримати перше значення з ітератора. Якщо <code>text</code> буде пустою стрічкою, то виклик <code>next</code> поверне значення <code>None</code>, для цього випадку ми використовуємо оператор <code>?</code>, щоб достроково зупинити виконання і повернути <code>None</code> з функції <code>last_char_of_first_line</code>. Якщо ж <code>text</code> не порожня стрічка, виклик <code>next</code> поверне значення <code>Some</code>, яке буде містити стрічковий слайс із першим рядком у <code>text</code>.</p>
<p>Оператор <code>?</code> вилучає цей стрічковий слайс, і ми можемо далі викликати метод <code>chars</code> на цьому зрізі, щоб отримати ітератор символів. Ми зацікавлені в останньому символі першої стрічки, тому ми викликаємо метод <code>last</code>, для останнього елементу ітератора. Це значення також <code>Option</code>, оскільки можливо, що цей перший рядок є пустою стрічкою, наприклад, якщо <code>text</code> починається з пустого рядку, але має символи на наступних рядках, як, до прикладу, у <code>&quot;\nhi&quot;</code>. Однак, якщо є останній символ у першому рядку, то він повернеться загорнутим у <code>Some</code>. Оператор <code>?</code> посередині дає нам виразний спосіб описати логіку, змушуючи нас реалізовувати тіло функції в один рядок. Якщо б ми не використовували оператор <code>?</code> на <code>Option</code>, то довелося би реалізовувати логіку з використанням більшої кількості викликів методів та виразів <code>match</code>.</p>
<p>Варто зазначити, що ми можемо використовувати оператор <code>?</code> на <code>Result</code> всередині функцій, які повертають <code>Result</code>, а також можемо використовувати на <code>Option</code> у функціях, які повертають <code>Option</code>, але ми не можемо їх змішувати і порівнювати. Оператор <code>?</code> не може автоматично конвертувати <code>Result</code> в <code>Option</code> або навпаки. В цих випадках слід використовувати методи на зразок <code>ok</code> на <code>Result</code>, або <code>ok_or</code> на <code>Option</code>, для здійснення явного конвертування.</p>
<p>Поки що всі функції <code>main</code>, які ми використовували повертали значення типу <code>()</code>. Функція <code>main</code> є спеціальною, тому що є вхідною та вихідною точкою для запуску програм і має строгі обмеження до типу значення, яке вона повертає, щоб програма поводила себе так, як очікується.</p>
<p>На щастя, <code>main</code> може також повертати значення типу <code>Result&lt;(), E&gt;</code>. Блок 9-12 містить код з блоку 9-10, але тут ми змінили тип значення, яке повертається з <code>main</code> на <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> і повернули значення <code>Ok(())</code> в кінці тіла функції. Цей код буде тепер компілюватися:</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}
</code></pre>
<p><span class="caption">Блок коду 9-12: Зміна функції <code>main</code> щоб повертати <code>Result&lt;(), E&gt;</code> і мати можливість використання оператора <code>?</code> на значеннях <code>Result</code></span></p>
<p>Тип <code>Box&lt;dyn Error&gt;</code> є <em>об'єктом типажом</em>, про який ми будемо говорити у секції <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">«Використання трейт об'єктів, які допускають значення різних типів»</a><!-- ignore --> розділу 17. На тепер ми можемо читати це, як<code>Box&lt;dyn Error&gt;</code>, що означає «будь який тип помилок». Використання оператора <code>?</code> на значенні <code>Result</code> всередині функції <code>main</code> з помилкою типу <code>Box&lt;dyn Error&gt;</code> є допустимим, оскільки допустимими є будь-які значення <code>Err</code> для дострокового повернення. Навіть якщо тіло цієї функції <code>main</code> буде повертати помилки типу <code>std::io::Error</code>, спеціалізована <code>Box&lt;dyn Error&gt;</code> сигнатура буде залишатися коректною, навіть якщо додамо більше коду в тіло функції <code>main</code>, який може повертати помилки іншого типу.</p>
<p>Коли функція <code>main</code> повертає <code>Result&lt;(), E&gt;</code>, виконання запиниться зі значенням <code>0</code>, якщо <code>main</code> поверне <code>Ok(())</code> і запиниться з ненульовим значенням, якщо <code>main</code> поверне значення <code>Err</code>. Виконувані файли, написані на C повертають цілі числа коли завершуються: програми які виконалися успішно повертають ціле число <code>0</code>, а програми що виконалися з помилкою повертають цілі числа, відмінні від <code>0</code>. Rust також повертає цілі числа з виконуваних файлів, щоб бути сумісним з такою домовленістю.</p>
<p>Функція <code>main</code> може повертати довільний тип, який імплементує <code>std::process::Termination</code> трейт<!-- ignore -->що містить функцію <code>report</code>, яка повертає <code>ExitCode</code>. Зверніться до документації стандартної бібліотеки для отримання додаткової інформації про реалізацію трейта <code>Termination</code> для ваших власних типів.</p>
<p>Тепер, коли ми обговорили деталі виклику <code>panic!</code> й використанню <code>Result</code>, повернімось до теми, яким чином визначати, що з переліченого доцільно використовувати та в яких випадках.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="panic-чи-не-panic"><a class="header" href="#panic-чи-не-panic"><code>panic!</code> чи не <code>panic!</code></a></h2>
<p>Отже, як приймається рішення, коли слід викликати <code>panic!</code>, а коли повернути <code>Result</code>? При паніці код не може відновити своє виконання. Можна було б викликати <code>panic!</code> для будь-якої помилкової ситуації, незалежно від того, чи є спосіб відновлення, чи ні, але з іншого боку, ви приймаєте рішення від імені коду, який викликає, що ситуація необоротна. Коли ви повертаєте значення <code>Result</code>, ви делегуєте прийняття рішення коду, що викликає. Код, що викликає, може спробувати виконати відновлення способом, який підходить в даній ситуації, або ж він може вирішити, що з помилки в <code>Err</code> не можна відновитися і викличе <code>panic!</code>, перетворивши вашу помилку, що виправляється, в невиправну. Тому повернення <code>Result</code> є гарним вибором за замовчуванням для функції, яка може дати збій.</p>
<p>У таких ситуаціях як приклади, прототипи та тести, більш доречно писати код, який панікує замість повернення <code>Result</code>. Розгляньмо чому, а потім обговоримо ситуації, коли компілятор не може довести, що помилка неможлива, але ви, як людина, можете це зробити. Глава закінчуватиметься деякими загальними керівними принципами про те, як вирішити, чи варто панікувати в коді бібліотеки.</p>
<h3 id="Приклади-прототипування-та-тести"><a class="header" href="#Приклади-прототипування-та-тести">Приклади, прототипування та тести</a></h3>
<p>Коли ви пишете приклад, який ілюструє деяку концепцію, наявність гарного коду обробки помилок може зробити приклад менш зрозумілим. В прикладах виклик методу <code>unwrap</code>, який може призвести до паніки, є лише позначенням способу обробки помилок у додатку, який може відрізнятися в залежності від того, що робить решта коду.</p>
<p>Так само методи <code>unwrap</code> та <code>expect</code> є дуже зручними при створенні прототипу, перш ніж ви будете готові вирішити, як обробляти помилки. Вони залишають чіткі маркери в коді до моменту, коли ви будете готові зробити програму надійнішою.</p>
<p>Якщо в тесті відбувається збій при виклику методу, то ви б хотіли, щоб весь тест не пройшов, навіть якщо цей метод не є функціональністю, що тестується. Оскільки виклик <code>panic!</code> це спосіб, яким тест позначається як невдалий, використання <code>unwrap</code> чи <code>expect</code> – саме те, що потрібно.</p>
<h3 id="Випадки-коли-у-вас-більше-інформації-ніж-у-компілятора"><a class="header" href="#Випадки-коли-у-вас-більше-інформації-ніж-у-компілятора">Випадки, коли у вас більше інформації, ніж у компілятора.</a></h3>
<p>Також було б доцільно викликати <code>unwrap</code> або <code>expect</code>, коли у вас є якась інша логіка, яка гарантує, що <code>Result</code> буде мати значення <code>Ok</code>, але вашу логіку не розуміє компілятор. У вас, як і раніше, буде значення <code>Result</code>, яке потрібно обробити: будь-яка операція, яку ви викликаєте, все ще має можливість невдачі в цілому, хоча це логічно неможливо у вашій конкретній ситуації. Якщо, перевіряючи код вручну, ви можете переконатися, що ніколи не буде варіанту <code>Err</code>, то можна викликати <code>unwrap</code>, а ще краще задокументувати причину, з якої ви думаєте, що ніколи не матимете варіант <code>Err</code> у тексті <code>expect</code>. Ось приклад:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = &quot;127.0.0.1&quot;
        .parse()
        .expect(&quot;Hardcoded IP address should be valid&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Ми створюємо екземпляр <code>IpAddr</code> шляхом аналізу жорстко заданого рядка. Можна побачити що <code>127.0.0.1</code> є дійсною IP-адресою, тому доречно використовувати <code>expect</code> тут. Однак наявність жорстко заданого правильного рядка не змінює тип повертаємого значення методу <code>parse</code>: ми все ще отримуємо значення <code>Result</code>, і компілятор досі змушує нас обробляти <code>Result</code> так, ніби варіант <code>Err</code> є можливим, тому що компілятор недостатньо розумний, щоб побачити, що цей рядок завжди є дійсною IP-адресою. Якщо рядок IP-адреси надійшов від користувача, а не є жорстко заданим у програмі, він <em>може</em> призвести до помилки, тому ми точно хотіли б обробити <code>Result</code> більш надійним способом. Згадка про припущення, що ця IP-адреса жорстко задана, спонукатиме нас до зміни <code>expect</code> на кращий код обробки помилок, якщо в майбутньому нам знадобиться отримати IP-адресу з іншого джерела.</p>
<h3 id="Інструкція-з-обробки-помилок"><a class="header" href="#Інструкція-з-обробки-помилок">Інструкція з обробки помилок</a></h3>
<p>Бажано, щоб код панікував, якщо він може опинитися в некоректному стані. В цьому контексті <em>некоректний стан</em> це такий стан, коли деяке допущення, гарантія, контракт чи інваріант були порушені. Наприклад, коли неприпустимі, суперечливі чи пропущенні значення передаються у ваш код, та інші приклади зі списку нижче:</p>
<ul>
<li>Некоректний стан - це щось неочікуване, відмінне від того, що може відбуватися час від часу, наприклад, коли користувач вводить дані у неправильному форматі.</li>
<li>Ваш код після цієї точки повинен покладатися на те, що він не знаходиться у некоректному стані, замість перевірок наявності проблеми на кожному етапі.</li>
<li>Немає гарного способу закодувати цю інформацію в типах, які ви використовуєте. Ми подивимося приклад того, що ми маємо на увазі в розділі <a href="ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types">“Кодування станів та поведінки на основі типів”</a><!-- ignore --> розділу 17.</li>
</ul>
<p>Якщо хтось викликає ваш код та передає значення, які не мають сенсу, краще за все повернути помилку, якщо це можливо, щоб користувач бібліотеки мав змогу вирішити, що йому робити в цьому випадку. Однак, у випадках, коли продовження може бути небезпечним чи шкідливим, найкращим вибором може бути виклик <code>panic!</code> для оповіщення користувача бібліотеки, що в його коді є помилка й він може її виправити. Також <code>panic!</code> підходить, якщо ви викликаєте зовнішній, неконтрольований вами код, і він повертає неприпустимий стан, який ви не можете виправити.</p>
<p>Однак, якщо очікується збій, краще повернути <code>Result</code>, ніж виконати виклик <code>panic!</code>. Як приклад можна привести синтаксичний аналізатор, якому передали неправильно сформовані дані чи статус HTTP-запиту, що повернувся, вказує на те, що ви досягли обмеження частоти запитів. У цих випадках повертання <code>Result</code> вказує на те, що відмова є очікуваною, такою, яку код, що викликає, повинен вирішити, як саме обробити.</p>
<p>Коли ваш код виконує операцію, яка може бути ризикованою для користувача, якщо використовуються неприпустимі значення, ваш код повинен спочатку перевірити чи вони коректні, та панікувати, якщо це не так. Діяти таким чином рекомендується в основному з міркувань безпеки: спроба оперувати некоректними даними може спричинити вразливість вашого коду. Це основна причина, через що стандартна бібліотека буде викликати <code>panic!</code>, якщо спробувати отримати доступ до пам'яті поза межами масиву: доступ до пам'яті, яка не стосується поточної структури даних, є відомою проблемою безпеки. Функції часто мають <em>контракти</em>: їх поведінка гарантується, тільки якщо вхідні дані відповідають визначеним вимогам. Паніка при порушенні контракту має сенс, тому що це завжди вказує на дефект з боку коду, що викликає, і це не помилка, яку б ви хотіли, щоб код, що викликає, явно обробляв. Насправді немає розумного способу для відновлення коду, що викликає; <em>Програмісти</em>, що викликають ваш код, повинні виправити свій. Контракти для функції, особливо порушення яких викликає паніку, слід описати в документації API функції.</p>
<p>Проте, наявність великої кількості перевірок помилок у всіх ваших функціях було б багатослівним та дратівливим. На радість, можна використовувати систему типів Rust (отже і перевірку типів компілятором), щоб вона зробила множину перевірок замість вас. Якщо ваша функція має визначений тип в якості параметру, ви можете продовжити роботу з логікою коду знаючи, що компілятор вже забезпечив правильне значення. Наприклад, якщо використовується звичайний тип, а не тип <code>Option</code>, то ваша програма очікує наявність <em>чогось</em> замість <em>нічого</em>. Ваш код не повинен буде опрацювати обидва варіанти <code>Some</code> та <code>None</code>: він буде мати тільки один варіант для певного значення. Код, який намагається нічого не передавати у функцію, не буде навіть компілюватися, тому ваша функція не повинна перевіряти такий випадок під час виконання. Інший приклад - це використання цілого типу без знаку, такого як <code>u32</code>, який гарантує, що параметр ніколи не буде від'ємним.</p>
<h3 id="Створення-користувацьких-типів-для-перевірки"><a class="header" href="#Створення-користувацьких-типів-для-перевірки">Створення користувацьких типів для перевірки</a></h3>
<p>Розвиньмо ідею використання системи типів Rust щоб переконатися, що в нас є коректне значення, та розглянемо створення користувацького типа для валідації. Згадаємо гру вгадування числа з розділу 2, в якому наш код просив користувача вгадати число між 1 й 100. Ми ніколи не перевіряли, що припущення користувача знаходяться в межах цих чисел, перед порівнянням з задуманим нами числом; ми тільки перевіряли, що воно додатне. У цьому випадку наслідки були не дуже страшними: наші повідомлення “Забагато” чи “Замало”, які виводилися у консоль, все одно були коректними. Але було б краще підштовхувати користувача до правильних догадок та мати різну поведінку для випадків, коли користувач пропонує число за межами діапазону, і коли користувач вводить, наприклад, літери замість цифр.</p>
<p>One way to do this would be to parse the guess as an <code>i32</code> instead of only a <code>u32</code> to allow potentially negative numbers, and then add a check for the number being in range, like so:</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --snip--

<span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!(&quot;The secret number will be between 1 and 100.&quot;);
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --snip--
<span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}
</span></code></pre>
<p>Вираз <code>if</code> перевіряє, чи знаходиться наше значення поза діапазону, повідомляє користувачу про проблему та викликає <code>continue</code>, щоб почати наступну ітерацію циклу й попросити ввести інше число. Після виразу <code>if</code> ми можемо продовжити порівняння значення <code>guess</code> із задуманим числом, знаючи, що <code>guess</code> належить діапазону від 1 до 100.</p>
<p>However, this is not an ideal solution: if it was absolutely critical that the program only operated on values between 1 and 100, and it had many functions with this requirement, having a check like this in every function would be tedious (and might impact performance).</p>
<p>Замість цього можна створити новий тип та помістити перевірки у функцію створення екземпляру цього типу, не повторюючи їх повсюди. Таким чином, функції можуть використовувати новий тип у своїх сигнатурах та бути впевненими у значеннях, які їм передають. Лістинг 9-13 демонструє один зі способів, як визначити тип <code>Guess</code>, так щоб екземпляр <code>Guess</code> створювався лише при умові, що функція <code>new</code> отримує значення від 1 до 100.</p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 9-13: Тип <code>Guess</code>, який буде створювати екземпляри тільки для значень від 1 до 100</span></p>
<p>Спочатку ми визначимо структуру з ім'ям <code>Guess</code>, яка має поле з іменем <code>value</code> типу <code>i32</code>. Ось де буде збережено число.</p>
<p>Потім ми реалізуємо асоційовану функцію <code>new</code> структури <code>Guess</code>, яка створює нові екземпляри значень типу <code>Guess</code>. Функція <code>new</code> має один параметр <code>value</code> типу <code>i32</code> та повертає <code>Guess</code>. Код у тілі функції <code>new</code> перевіряє, що значення <code>value</code> знаходиться між 1 та 100. Якщо <code>value</code> не проходить цю перевірку, ми викликаємо <code>panic!</code>, що сповістить програміста, який написав код, що в його коді є помилка, яку необхідно виправити, оскільки спроба створення <code>Guess</code> зі значенням <code>value</code> поза заданого діапазону порушує контракт, на який покладається <code>Guess::new</code>. Умови, за яких <code>Guess::new</code> панікує, повинні бути описані в документації до API; ми розглянемо угоди про документації, що вказують на можливість виникнення <code>panic!</code> в документації API, яку ви створите в розділі 14. Якщо <code>value</code> проходить перевірку, ми створюємо новий екземпляр <code>Guess</code>, у якого значення поля <code>value</code> дорівнює значенню параметра <code>value</code>, і повертаємо <code>Guess</code>.</p>
<p>Потім ми реалізуємо метод з назвою <code>value</code>, який запозичує <code>self</code>, не має інших параметрів, та повертає значення типу <code>i32</code>. Цей метод іноді називають <em>витягувач (getter)</em>, тому що його метою є вилучити дані з полів структури та повернути їх. Цей публічний метод є необхідним, оскільки поле <code>value</code> структури <code>Guess</code> є приватним. Важливо, щоб поле <code>value</code> було приватним, щоб код, який використовує структуру <code>Guess</code>, не міг встановлювати <code>value</code> напряму: код зовні модуля <em>повинен</em> використовувати функцію <code>Guess::new</code> для створення екземпляру <code>Guess</code>, таким чином гарантуючи, що у <code>Guess</code> немає можливості отримати <code>value</code>, не перевірене умовами у функції <code>Guess::new</code>.</p>
<p>A function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a <code>Guess</code> rather than an <code>i32</code> and wouldn’t need to do any additional checks in its body.</p>
<h2 id="Підсумок-8"><a class="header" href="#Підсумок-8">Підсумок</a></h2>
<p>Можливості обробки помилок в Rust покликані допомогти написанню більш надійного коду. Макрос <code>panic!</code> сигналізує, що ваша програма знаходиться у стані, яке вона не може обробити, та дозволяє сказати процесу щоб він зупинив своє виконання, замість спроби продовжити виконання з некоректними чи невірними значеннями. Перерахунок (enum) <code>Result</code> використовує систему типів Rust, щоб повідомити, що операції можуть завершитися невдачею, і ваш код мав змогу відновитися. Можна використовувати <code>Result</code>, щоб повідомити коду, що викликає, що він повинен обробити потенціальний успіх чи потенційну невдачу. Використання <code>panic!</code> та <code>Result</code> правильним чином зробить ваш код більш надійним перед обличчям неминучих помилок.</p>
<p>Now that you’ve seen useful ways that the standard library uses generics with the <code>Option</code> and <code>Result</code> enums, we’ll talk about how generics work and how you can use them in your code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Узагальнені-типи-трейти-та-лайфтайми"><a class="header" href="#Узагальнені-типи-трейти-та-лайфтайми">Узагальнені типи, трейти та лайфтайми</a></h1>
<p>Кожна мова програмування має інструменти, щоб уникати повторення концепцій. У мові Rust, одним з таких інструментів є <em>узагальнені типи</em>, також відомі як &lt;0&gt;дженеріки&lt;/0&gt; (від англ. &lt;0&gt;generic&lt;/0&gt; &quot;загальний, типовий&quot;): абстрактні замінники конкретних типів або інших властивостей. Ми можемо описувати поведінку узагальнених типів і їх відношення до інших узагальнених типів, не знаючи, який саме тип буде на їх місці під час компіляції і виконання коду.</p>
<p>Функції можуть приймати параметри певного узагальненого типу замість конкретного типу (наприклад, <code>i32</code> або <code>String</code>), так само як функції можуть приймати параметри з невідомими значеннями і виконувати той самий код з багатьма конкретними значеннями. Насправді ми вже стикалися з узагальненими типами у розділі 6 (<code>Option&lt;T&gt;</code>), розділі 8 (<code>Vec&lt;T&gt;</code> та <code>HashMap&lt;K, V&gt;</code>) і розділі 9 (<code>Result&lt;T, E&gt;</code>). У цьому розділі ми побачимо, як можна визначати ваші власні типи, функції та методи з узагальненими типами!</p>
<p>Спочатку пригадаємо, як виділити код в окрему функції, щоб зменшити дублювання. Тоді ми використаємо цю техніку, щоб створити узагальнену функцію з двох функцій, які відрізняються лише типами їх параметрів. Також ми пояснимо, як використовувати узагальнені типи для визначення структур і енамів.</p>
<p>Після цього ви навчитесь використовувати <em>трейти</em> (від англ. &lt;0&gt;trait&lt;/0&gt; &quot;властивість, риса&quot;), щоб визначати поведінку в узагальнений спосіб. Ви можете поєднувати трейти з узагальненими типами, щоб обмежити узагальнений тип так, щоб він працював не з будь-якими типами, а лише тими, які мають певну поведінку.</p>
<p>Нарешті ми поговоримо про <em>лайфтайми</em> (від англ. &lt;0&gt;lifetime&lt;/0&gt; &quot;час життя&quot;): підвид узагальнених типів, які дають компілятору інформацію про те, як посилання відносяться одне до одного. Лайфтайми дозволяють нам давати компілятору достатньо інформації про позичені значення, щоб він міг впевнитись, що посилання будуть дійсними в тих ситуаціях, де компілятор не знав би цього без наших підказок.</p>
<h2 id="Уникання-повторень-за-допомогою-виділення-функції"><a class="header" href="#Уникання-повторень-за-допомогою-виділення-функції">Уникання повторень за допомогою виділення функції</a></h2>
<p>Узагальнені типи дозволяють використати змінну типу, яка замінює багато типів, а не конкретний тип, щоб уникнути повторень у коді. Перед тим як розглянути синтаксис узагальнених типів, погляньмо на уникнення повторень без узагальнених типів, а саме виділення функції, яка замінює конкретні значення на змінну, що представляє багато значень. Тоді ми застосуємо той самий підхід, щоб виділити узагальнену функцію! Поглянувши на те, як помітити продубльований код, який можна винести в окрему функцію, ви почнете помічати продубльований код, який може використовувати узагальнені типи.</p>
<p>We begin with the short program in Listing 10-1 that finds the largest number in a list.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
<span class="boring">    assert_eq!(*largest, 100);
</span>}
</code></pre></pre>
<p><span class="caption">Блок коду 10-1: Пошук найбільшого числа у списку</span></p>
<p>Ми зберігаємо список цілих чисел у змінній <code>number_list</code> і присвоєму змінній <code>largest</code> посилання на перше число у списку. Тоді ми проходимося по всіх числах у списку, і якщо поточне число більше за те, яке зберігається у <code>largest</code>, то ми замінємо посилання у цій змінній. Проте якщо поточне число менше або рівне поки що найбільшому числу, змінна зберігає своє значення і наш код продовжує з наступного числа у списку. Після того як ми пройшлися по всіх числах у списку, <code>largest</code> має містити значення найбільшого числа. У цьому випадку це 100.</p>
<p>Тепер нам дали завдання знайти найбільше число в інших двох списках чисел. Для цього ми можемо продублювати код з роздруку 10-1 і використати ту саму логіку у двох різних місцях програми, як показано у роздруку 10-2.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<p><span class="caption">Блок коду 10-2: Програма, яка знаходить найбільше число у <em>двох</em> списках</span></p>
<p>Хоча цей код працює, дублювання коду виснажливе і збільшує ризик помилок. Також потрібно не забути оновити код у двох місцях, якщо ми хочемо внести будь-які зміни.</p>
<p>Щоб уникнути цього дублювання, ми створимо абстракцію визначивши функцію, що працює з будь-яким списком цілих чисел, переданим як параметр. Це рішення робить наш код більш зрозумілим і дозволяє нам виразити концепцію пошуку найбільшого числа у списку в абстрактний спосіб.</p>
<p>У роздруку 10-3 ми виносимо у функцію <code>largest</code> код, який знаходить найбільше число у списку. Тоді ми можемо викликати цю функцію, щоб знайти найбільше число у двох списках з роздруку 10-2. Також ми можемо використати цю функцію на будь-якому іншому списку значень типу <code>i32</code>, який ми отримали б у майбутньому.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">    assert_eq!(*result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">    assert_eq!(*result, 6000);
</span>}
</code></pre></pre>
<p><span class="caption">Listing 10-3: Abstracted code to find the largest number in two lists</span></p>
<p>Функція <code>largest</code> має параметр <code>list</code>, який представляє будь-який конкретний слайс значень <code>i32</code>, який ми могли б передати в цю функцію. Як результат, коли ми викликаємо функцію, код працює з конкретними значеннями, які ми передаємо.</p>
<p>In summary, here are the steps we took to change the code from Listing 10-2 to Listing 10-3:</p>
<ol>
<li>Визначити код, що повторюється.</li>
<li>Винести код, що повторюється, у тіло нової функції і вказати вхідні та вихідні данні цього коду у сигнатурі функції.</li>
<li>Замінити продубльований код на виклик функції в обох місцях.</li>
</ol>
<p>Далі ми використаємо ці самі кроки з узагальненими типами, щоб зменшити кількість повторень у коді. Так само як функція може працювати з абстрактною змінною <code>list</code>, а не конкретними значеннями, узагальнені типи дозволяють коду працювати з абстрактними типами.</p>
<p>Наприклад, скажімо, ми маємо дві функції: одна знаходить найбільший елемент у слайсі значень <code>i32</code>, а інша — у слайсі значень <code>char</code>. Як можна уникнути повторень? Давайте дізнаємось!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Узагальнені-типи-даних"><a class="header" href="#Узагальнені-типи-даних">Узагальнені типи даних</a></h2>
<p>Ми використовуємо узагальнені типи для створення таких речей як сигнатури функцій або структури, які потім можна використовувати з багатьма конкретними типами даних. Погляньмо на те, як визначити функції, структури, енуми та методи, що використовують узагальнені типи. Далі ми поговоримо про те, як узагальнені типи впливають на швидкодію коду.</p>
<h3 id="У-визначеннях-функцій"><a class="header" href="#У-визначеннях-функцій">У визначеннях функцій</a></h3>
<p>При визначенні функції, що використовує узагальнені типи, ми розмістимо їх в сигнатурі функції, де зазвичай ми вказуємо типи даних параметрів та результату. Це робить наш код більш гнучким і забезпечує більше функціоналу користувачам нашої функції, водночас запобігаючи дублюванню коду.</p>
<p>Продовжимо з нашою функцією <code>largest</code>. Роздрук 10-4 показує дві функції, які шукають найбільше значення у слайсі. Пізніше ми обʼєднаємо їх в одну функцію, яка використовує узагальнені типи.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">    assert_eq!(*result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
<span class="boring">    assert_eq!(*result, 'y');
</span>}
</code></pre></pre>
<p><span class="caption">Listing 10-4: Two functions that differ only in their names and the types in their signatures</span></p>
<p>Функція <code>largest_i32</code> – це та сама, яку ми винесли у роздруку 10-3, яка шукає найбільше значення типу <code>i32</code> у слайсі. Функція <code>largest_char</code> шукає найбільше значення типу <code>char</code> у слайсі. Тіла функції мають той самий код, тому можна усунути дублювання, ввівши узагальнений параметр-тип в обʼєднаній функції.</p>
<p>Щоб параметризувати типи в новій обʼєднаній функції, нам потрібно дати імʼя параметру, так само як ми даємо імʼя параметрам-значенням у функції. Ви можете використовувати будь-який ідентифікатор як імʼя параметра-типу. Але ми використаємо <code>T</code>, тому що за домовленістю назви параметрів у Rust короткі і часто складаються лише з однієї букви, а імена типів, за домовленістю, слідують &quot;camel case&quot; (окремі слова пишуться без пробілів і з великої букви; наприклад, так: &quot;CamelCase&quot;). Оскільки це скорочення від &quot;тип&quot;, <code>T</code> – це типовий вибір для програмістів на Rust.</p>
<p>Коли ми використовуємо параметр у тілі функції, ми маємо оголосити його імʼя у сигнатурі, щоб компілятор знав, що воно означає. Так само, коли ми використовуємо імʼя параметру-типу у сигнатурі функції, ми маємо оголосити цей параметр-тип перед використанням. Щоб оголосити узагальнену функцію <code>largest</code>, вставте оголошення імен типів у кутові дужки, <code>&lt;&gt;</code>, між імʼям функції та списком параметрів, ось так:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
</code></pre>
<p>Ми читаємо це визначення так: функція <code>largest</code> узагальнена відносно певного типу <code>T</code>. Ця функція має один параметр з назвою <code>list</code>, який є слайсом значень типу <code>T</code>. Функція <code>largest</code> поверне посилання на значення того самого типу <code>T</code>.</p>
<p>Роздрук 10-5 показує визначення обʼєднаної функції <code>largest</code> з використанням узагальненого типу в її сигнатурі. Цей приклад також показує, як можна викликати функцію зі слайсом значень <code>i32</code> або <code>char</code>. Зверніть увагу, що цей код поки не скомпілюється, але ми виправимо це пізніше у цьому розділі.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-5: The <code>largest</code> function using generic type parameters; this doesn’t yet compile</span></p>
<p>Якщо ми скомпілюємо цей код зараз, ми отримаємо таку помилку:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Текст довідки згадує <code>std::cmp::PartialOrd</code>, який є трейтом, але ми будемо обговорювати трейти в наступній секції. На цей час, запамʼятайте, що ця помилка вказує, що тіло <code>largest</code> не працюватиме для всіх можливих типів, якими може бути <code>T</code>. Оскільки, ми хочемо порівняти значення типу <code>T</code> в тілі, ми можемо використовувати лише типи, значення яких можна впорядкувати. Щоб дозволити операції порівняння стандартна бібліотека має трейт <code>std::cmp::PartialOrd</code>, який ви можна реалізувати для типів (див. додаток C для деталей щодо цього трейту). Слідуючи підказці, ми обмежуємо припустимі типи <code>T</code> до тих, що реалізують <code>PartialOrd</code>, і цей приклад компілюється, оскільки стандартна бібліотека реалізує <code>PartialOrd</code> для <code>i32</code> і <code>char</code>.</p>
<h3 id="У-визначеннях-структур"><a class="header" href="#У-визначеннях-структур">У визначеннях структур</a></h3>
<p>Ми також можемо визначити структури з використанням узагальнених параметрів-типів в одному або декількох полях використовуючи синтаксис з <code>&lt;&gt;</code>. Роздрук 10-6 визначає структуру <code>Point&lt;T&gt;</code>, яка містить координати <code>x</code> та <code>y</code>, які можуть бути значеннями будь-якого типу.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listing 10-6: A <code>Point&lt;T&gt;</code> struct that holds <code>x</code> and <code>y</code> values of type <code>T</code></span></p>
<p>Синтаксис для використання узагальнених типів у визначеннях структур схожий на той, що використовується в визначеннях функцій. Спочатку ми оголошуємо ім'я параметру типу всередині кутових дужок одразу після назви структури. Далі ми використовуємо узагальнений тип у визначенні структури де б ми інакше вказували конкретні типи даних.</p>
<p>Зауважте, що оскільки ми тільки використовуємо один узагальнений тип, щоб визначити <code>Point&lt;T&gt;</code>, це визначення означає, що структура <code>Point&lt;T&gt;</code> узагальнена відносно певного типу <code>T</code>, і поля <code>x</code> та <code>y</code> <em>обоє</em> мають той самий тип, яким би він не був. Якщо ми створимо екземпляр <code>Point&lt;T&gt;</code> зі значеннями різних типів, як у роздруку 10-7, наш код не буде компілюватися.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">Listing 10-7: The fields <code>x</code> and <code>y</code> must be the same type because both have the same generic data type <code>T</code>.</span></p>
<p>У цьому прикладі, коли ми присвоюємо ціле значення 5 до <code>x</code>, ми повідомимо компілятору що тип <code>T</code> буде цілим числом для даного екземпляру <code>Point&lt;T&gt;</code>. Потім ми вкажемо 4,0 для <code>у</code>, який ми визначили як такий же тип, що й <code>x</code>, і отримаємо невідповідність типів таким чином:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Щоб визначити структуру <code>Point</code>, де <code>x</code> і <code>y</code> є обидва узагальненими, але можуть мати значення різних типів, можна використовувати декілька узагальнених параметрів-типів. Наприклад, у роздруку 10-8, ми змінюємо визначення <code>Point</code> на узагальнене відносно типів <code>T</code> та <code>U</code>, де <code>x</code> має тип <code>T</code>, а <code>y</code> має тип <code>U</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listing 10-8: A <code>Point&lt;T, U&gt;</code> generic over two types so that <code>x</code> and <code>y</code> can be values of different types</span></p>
<p>Тепер всі екземпляри <code>Point</code> допускаються! Ви можете використовувати скільки завгодно параметрів-типів у визначенні, але використання декількох робить ваш код складнішим для читання. Якщо ви виявите, що потрібно багато узагальнених типів в коді, то це може означати, що ваш код потребує розбиття на менші частини.</p>
<h3 id="У-визначеннях-енумів"><a class="header" href="#У-визначеннях-енумів">У визначеннях енумів</a></h3>
<p>Так само як зі структурами, ми можемо визначати енуми, які містять узагальнені типи даних у своїх варіантах. Давайте ще раз подивимось на енум <code>Option&lt;T&gt;</code>, який надає стандартна бібліотека, яку ми використали в розділі 6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>Тепер таке визначення має бути зрозуміліше. Як ви можете бачити, енум <code>Option&lt;T&gt;</code> є узагальненим відносно типу <code>T</code> і має два варіанти: <code>Some</code>, який містить одне значення типу <code>T</code>, і <code>None</code>, який не містить жодних значень. Використовуючи <code>Option&lt;T&gt;</code>, ми можемо виразити абстрактне поняття необовʼязкового значення, і через те, що <code>Option&lt;T&gt;</code> є узагальненим, ми можемо використовувати цю абстракцію, незалежно від типу необов'язкового значення.</p>
<p>Енуми також можуть використовувати декілька узагальнених типів. Визначення енуму <code>Result</code>, який ми використовували у розділі 9 є одним з прикладів:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>Енум <code>Result</code> узагальнений відносно двох типів, <code>T</code> та <code>E</code>, і має два варіанти: <code>Ok</code>, який містить значення типу <code>T</code>, і <code>Err</code>, який містить значення типу <code>E</code>. Це визначення робить <code>Result</code> зручним для операцій, які можуть мати успішний результат (повернути значення певного типу <code>T</code>) або помилку (повернути помилку певного типу <code>E</code>). Насправді це те, що ми використовували для відкриття файлу у роздруку 9-3 де <code>T</code> був заповнений типом <code>std::fs::File</code>, коли файл був успішно відкритий, а <code>E</code> був заповнений типом <code>std::io::Error</code>, коли виникли проблеми з відкриттям файлу.</p>
<p>When you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.</p>
<h3 id="У-визначеннях-методів"><a class="header" href="#У-визначеннях-методів">У визначеннях методів</a></h3>
<p>Ми можемо імплементувати методи структур та енамів (як це було у розділі 5), і використовувати у їх визначеннях узагальнені типи. Роздрук 10-9 показує структуру <code>Point&lt;T&gt;</code>, яку ми визначили у роздруку 10-6 з імплементованим методом <code>x</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">Listing 10-9: Implementing a method named <code>x</code> on the <code>Point&lt;T&gt;</code> struct that will return a reference to the <code>x</code> field of type <code>T</code></span></p>
<p>Here, we’ve defined a method named <code>x</code> on <code>Point&lt;T&gt;</code> that returns a reference to the data in the field <code>x</code>.</p>
<p>Зверніть увагу, що ми повинні оголосити <code>T</code> відразу після <code>impl</code>, тож ми можемо використовувати <code>T</code>, щоб вказати, що ми застосовуємо методи на типі <code>Point&lt;T&gt;</code>. Оголосивши <code>T</code> як узагальнений тип після <code>impl</code>, Rust може визначити, що тип у кутових дужках у <code>Point</code> – узагальнений, а не конкретний тип. Ми могли б вибрати іншу назву, ніж назва параметра з визначення структури, для даного узагальненого параметра, але за домовленістю ми використовуємо ту саму назву. Методи, написані в межах <code>impl</code>, який оголошує узагальнений тип, буде визначено в будь-якому екземплярі типу, неважливо, який конкретний тип ми отримаємо, коли підставимо конкретний тип на місце параметра.</p>
<p>Ми також можемо вказати обмеження для узагальнених типів при визначенні методів у типі. Наприклад, ми можемо реалізувати методи лише на екземплярах <code>Point&lt;f32&gt;</code>, а не екземплярах <code>Point&lt;T&gt;</code> з будь-яким узагальненим типом. У роздруку 10-10 ми використовуємо конкретний тип <code>f32</code>, тобто ми не оголошуємо жодних типів після <code>impl</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-10: An <code>impl</code> block that only applies to a struct with a particular concrete type for the generic type parameter <code>T</code></span></p>
<p>Цей код означає, що тип <code>Point&lt;f32&gt;</code> буде мати метод <code>distance_from_origin</code>; інші екземпляри <code>Point&lt;T&gt;</code>, у яких <code>T</code> не є типом <code>f32</code> не будуть мати цього методу. Метод вимірює відстань від нашої точки до координати (0,0; 0,0) і використовує математичні операції, які доступні тільки для чисел з рухомою комою.</p>
<p>Типи-параметри у визначеннях структури не завжди такі самі, що й у сигнатурах методів цієї структури. Роздрук 10-11 використовує типи <code>X1</code> та <code>Y1</code> для структури <code>Point</code> і <code>X2</code> <code>Y2</code> для сигнатури методу <code>mixup</code>, щоб краще пояснити цей приклад. Метод створює новий екземпляр <code>Point</code> зі значенням <code>x</code> з <code>self</code> <code>Point</code> (з типом <code>X1</code>) і значенням <code>y</code> з екземпляра <code>Point</code>, що передається як параметр (з типом <code>Y2</code>).</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c' };

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">Listing 10-11: A method that uses generic types different from its struct’s definition</span></p>
<p>У <code>main</code>, ми визначили <code>Point</code>, що має тип <code>i32</code> для <code>x</code> (зі значенням <code>5</code>) і тип <code>f64</code> для <code>y</code> (зі значенням <code>10.4</code>). Змінна <code>p2</code> – це структура <code>Point</code>, де <code>x</code> є слайсом стрічки (зі значенням <code>&quot;Hello&quot;</code>), <code>y</code> є <code>char</code> (зі значенням <code>c</code>). Виклик <code>mixup</code> на <code>p1</code> з аргументом <code>p2</code> дає нам <code>p3</code>, у якому <code>x</code> буде <code>i32</code>, тому що <code>x</code> береться з <code>p1</code>. Змінна <code>p3</code> матиме <code>y</code> з типом <code>char</code>, тому що <code>y</code> береться з <code>p2</code>. Виклик макроса <code>println!</code> виведе в консоль <code>p3.x = 5, p3.y = c</code>.</p>
<p>Мета цього прикладу – продемонструвати ситуацію, у якій деякі параметри-типи визначені в <code>impl</code>, а деякі у визначенні метода. Тут параметри-типи <code>X1</code> і <code>Y1</code> оголошені після <code>impl</code>, тому що вони відповідають визначенню структури. Параметри-типи <code>X2</code> і <code>Y2</code> оголошені після <code>fn mixup</code>, тому що вони стосуються виключно метода.</p>
<h3 id="Швидкодія-коду-з-узагальненими-типами"><a class="header" href="#Швидкодія-коду-з-узагальненими-типами">Швидкодія коду з узагальненими типами</a></h3>
<p>Можливо, вам цікаво, чи страждає швидкодія, коли ми використовуємо узагальнені типи. Гарна новина в тому, що використання узагальнених типів не зробить вашу програму повільнішою, ніж якби ви використовували конкретні типи.</p>
<p>Rust може досягнути цього за допомогою мономорфізації коду, який використовує узагальнені типи, під час компіляції. <em>Мономорфізація</em> – це процес перетворення коду з узагальненими типами в код з конкретними, заповнюючи типів-параметрів конкретними типами, під час компіляції. У цьому процесі компілятор робить зворотні кроки, до тих, які ми виконали, створюючи узагальнену функцію у роздруку 10-5; компліятор шукає всі місця, де код з узагальненими типами викликається і генерує код для кожного конкретного типу, з яким він викликається.</p>
<p>Let’s look at how this works by using the standard library’s generic <code>Option&lt;T&gt;</code> enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<p>Коли Rust компілює цей код, він виконує мономорфізацію. Під час цього процесу, компілятор читає значення, які були використані в екземплярах <code>Option&lt;T&gt;</code> і визначає два види <code>Option&lt;T&gt;</code>: один з <code>i32</code>, а інший – з <code>f64</code>. Таким чином, він розкладає узагальнене визначення <code>Option&lt;T&gt;</code> на два визначення, які використовують <code>i32</code> і <code>f64</code>, замінюючи узагальнене визначення на визначення з конкретизовані.</p>
<p>The monomorphized version of the code looks similar to the following (the compiler uses different names than what we’re using here for illustration):</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>Узагальнене <code>Option&lt;T&gt;</code> замінюється на конкретизовані визначення, створені компілятором. Оскільки Rust компілює код з узагальненими типами в код, який вказує тип в кожному випадку, ми не платимо за використання узагальнених типів під час виконання. Коли код запускається, він виконується так само, як і якби ми продублювали кожне визначення вручну. Процес мономорфізації робить узагальнені типи в Rust надзвичайно ефективними під час виконання коду.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Трейти-визначення-загальної-поведінки"><a class="header" href="#Трейти-визначення-загальної-поведінки">Трейти: визначення загальної поведінки</a></h2>
<p><em>Трейт</em> визначає функціональність, якою володіє визначений тип та якою він може ділитися з іншими типами. Ми можемо використовувати трейти, щоб визначати спільну поведінку абстрактним способом. Також маємо змогу застосувати <em>обмеження трейту</em>, щоб вказати, що загальний тип, може бути будь-яким типом, який реалізує певну поведінку.</p>
<blockquote>
<p>Note: Traits are similar to a feature often called <em>interfaces</em> in other languages, although with some differences.</p>
</blockquote>
<h3 id="Визначення-трейту"><a class="header" href="#Визначення-трейту">Визначення трейту</a></h3>
<p>Поведінка типу визначається тими методами, які ми можемо викликати у цього типу. Різні типи розділяють однакову поведінку, якщо ми можемо викликати одні й ті самі методи цих типів. Визначення трейтів - це спосіб згрупувати сигнатури методів разом, заради того, щоб описати загальну поведінку, необхідну для досягнення певної мети.</p>
<p>For example, let’s say we have multiple structs that hold various kinds and amounts of text: a <code>NewsArticle</code> struct that holds a news story filed in a particular location and a <code>Tweet</code> that can have at most 280 characters along with metadata that indicates whether it was a new tweet, a retweet, or a reply to another tweet.</p>
<p>Ми хочемо створити бібліотечний крейт медіа агрегатору під назвою <code>aggregator</code>, який може відображати зведення даних, які збережені в екземплярах структур <code>NewsArticle</code> чи <code>Tweet</code>. Щоб це зробити, нам треба мати можливість для кожної структури зробити коротке зведення на основі даних, які маємо: для цього треба, щоб обидві структури реалізували загальну поведінку, в нашому випадку це буде виклик методу <code>summarize</code> в екземпляра об'єкту. Лістинг 10-12 ілюструє визначення публічного трейту <code>Summary</code>, який висловлює таку поведінку.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</code></pre>
<p><span class="caption">Блок коду 10-12: Визначення трейту <code>Summary</code>, що містить поведінку, надану методом <code>summarize</code></span></p>
<p>Тут ми визначаємо трейт, використовуючи ключове слово <code>trait</code>, а потім його назву, якою є <code>Summary</code> в цьому випадку. Ми також визначили цей трейт як <code>pub</code>, щоб крейти, які залежать від цього крейту, також могли використовувати цей трейт, як ми побачимо в декількох прикладах. Всередині фігурних дужок визначаються сигнатури методів, які описують поведінку типів, які реалізують цей трейт. У цьому випадку поведінка визначається тільки однією сигнатурою методу: <code>fn summarize(&amp;self) -&gt; String</code>.</p>
<p>Після сигнатури методу, замість надання реалізації у фігурних дужках, ми використовуємо крапку з комою. Кожен тип, який реалізує цей трейт, повинен надати свою власну поведінку для цього методу. Компілятор забезпечить, що будь-який тип, який містить трейт <code>Summary</code>, буде також мати й метод <code>summarize</code> визначений з точно такою сигнатурою.</p>
<p>Трейт може мати декілька методів у описі його тіла: сигнатури методів перераховуються по одній на кожному рядку та повинні закінчуватися крапкою з комою.</p>
<h3 id="Реалізація-трейту-для-типів"><a class="header" href="#Реалізація-трейту-для-типів">Реалізація трейту для типів</a></h3>
<p>Тепер, після того, як ми визначили бажану поведінку, використовуючи трейт <code>Summary</code>, можна реалізувати його для типів у нашому медіа агрегатору. Лістинг 10-13 показує реалізацію трейту <code>Summary</code> для структури <code>NewsArticle</code>, яка використовує для створення зведення в методі <code>summarize</code> заголовок, автора та місце публікації. Для структури <code>Tweet</code> ми визначаємо реалізацію <code>summarize</code>, використовуючи користувача та повний текст твіту, вважаючи зміст вже обмеженим 280 символами.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
</code></pre>
<p><span class="caption">Блок коду 10-13: Реалізація трейту <code>Summary</code> для структур <code>NewsArticle</code> та <code>Tweet</code></span></p>
<p>Реалізація трейту для типу аналогічна реалізації звичайних методів. Різниця в тому, що після <code>impl</code> ми пишемо ім'я трейту, який ми хочемо реалізувати, після чого використовуємо ключове слово <code>for</code>, а потім вказуємо ім'я типу, для якого ми хочемо зробити реалізацію трейту. Всередині блоку <code>impl</code> ми розташовуємо сигнатуру методу, яка визначена в трейту. Замість додавання крапки з комою в кінці, після кожної сигнатури використовуються фігурні дужки, та тіло методу заповнюється конкретною поведінкою, яку ми хочемо отримати у методів трейту для конкретного типу.</p>
<p>Тепер, коли в бібліотеці реалізований трейт <code>Summary</code> для <code>NewsArticle</code> та <code>Tweet</code>, користувачі крейту можуть викликати методи трейту для екземплярів <code>NewsArticle</code> й <code>Tweet</code>, так само як ми викликаємо звичайні методи. Єдина різниця в тому, що користувач повинен ввести в область видимості трейти, а також типи. Ось приклад як бінарний крейт може використовувати наш <code>aggregator</code>:</p>
<pre><code class="language-rust ignore">use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
}
</code></pre>
<p>Цей код надрукує: <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Інші крейти, які залежать від крейту <code>aggregator</code>, також можуть взяти <code>Summary</code> в область видимості, щоб реалізувати <code>Summary</code> для своїх власних типів. Слід зазначити одне обмеження: ми можемо реалізувати трейт для типу тільки в тому випадку, якщо хоча б один трейт чи тип є локальними для нашого крейту. Наприклад, ми можемо реалізувати стандартні бібліотечні трейти, такі як <code>Display</code> на користувальницькому типі <code>Tweet</code>, як частина функціональності нашого крейту <code>aggregator</code>, тому що тип <code>Tweet</code> є локальним для нашого крейту <code>aggregator</code>. Також ми можемо реалізувати <code>Summary</code> для <code>Vec&lt;T&gt;</code> в нашому крейті <code>aggregator</code>, оскільки трейт <code>Summary</code> є локальним для нашого крейту <code>aggregator</code>.</p>
<p>Але ми не можемо реалізувати зовнішні трейти на зовнішніх типах. Наприклад, ми не можемо реалізувати трейт <code>Display</code> для <code>Vec&lt;T&gt;</code> в нашому крейті <code>aggregator</code>, тому що <code>Display</code> та <code>Vec&lt;T&gt;</code> визначені у стандартній бібліотеці та не є локальними для нашого крейту <code>aggregator</code>. Це обмеження є частиною властивості, яка називається <em>узгодженість</em> (coherence), та, більш конкретно <em>правило сироти</em> (orphan rule), яке назвали так, тому що батьківський тип відсутній. Це правило гарантує, що чужий код не може порушити ваш код, та навпаки. Без цього правила два крейти мали б змогу реалізовувати один й той самий трейт для одного й того самого типу, і Rust не знав би, яку реалізацію використовувати.</p>
<h3 id="Реалізація-поведінки-за-замовчуванням"><a class="header" href="#Реалізація-поведінки-за-замовчуванням">Реалізація поведінки за замовчуванням</a></h3>
<p>Іноді корисно мати поведінку за замовчуванням для деяких чи всіх методів трейту замість того, щоб вимагати реалізації всіх методів у кожному типі, що реалізує цей трейт. Потім, коли ми реалізуємо трейт для певного типу, можна зберегти чи перевизначити поведінку кожного методу за замовчуванням вже всередині типів.</p>
<p>В Блоці коду 10-14 показано, як вказати стрічку за замовчуванням для методу <code>summarize</code> з трейту <code>Summary</code> замість визначення тільки сигнатури методу, як ми робили в Блоці коду 10-12.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 10-14: Визначення трейту <code>Summary</code> з реалізацією методу <code>summarize</code> за замовчуванням</span></p>
<p>Для використання реалізації за замовчуванням під час створення зведення в екземплярах <code>NewsArticle</code>, ми вказуємо порожній блок <code>impl</code> з <code>impl Summary for NewsArticle {}</code>.</p>
<p>Хоча ми більше не визначаємо метод <code>summarize</code> безпосередньо в <code>NewsArticle</code>, ми надали реалізацію за замовчуванням та вказали, що <code>NewsArticle</code> реалізує трейт <code>Summary</code>. В результаті ми все ще маємо змогу викликати метод <code>summarize</code> в екземпляра <code>NewsArticle</code>, наприклад таким чином:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        author: String::from(&quot;Iceburgh&quot;),
        content: String::from(
            &quot;The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.&quot;,
        ),
    };

    println!(&quot;New article available! {}&quot;, article.summarize());
<span class="boring">}
</span></code></pre>
<p>Цей код надрукує <code>New article available! (Read more...)</code>.</p>
<p>Створення реалізації за замовчуванням не вимагає від нас змін чого-небудь у реалізації <code>Summary</code> для типу <code>Tweet</code> у Блоці коду 10-13. Причина полягає в тому, що синтаксис для перевизначення реалізації за замовчуванням є таким, як синтаксис для реалізації метода трейту, котрий не має реалізації за замовчуванням.</p>
<p>Реалізації за замовчуванням можуть викликати інші методи в тому ж трейті, навіть якщо ці методи не мають реалізації за замовчуванням. Таким чином, трейт може надати багато корисної функціональності, тільки вимагаючи від розробників вказувати невелику його частину. Наприклад, ми мали змогу б визначити трейт <code>Summary</code>, який має метод <code>summarize_author</code>, реалізація якого вимагається, а потім визначити метод <code>summarize</code>, який має реалізацію за замовчуванням, котра всередині викликає метод <code>summarize_author</code>:</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.username)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Щоб використовувати таку версію трейту <code>Summary</code>, потрібно тільки визначити метод <code>summarize_author</code>, під час реалізації трейту для типу:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p>Після того, як ми визначимо <code>summarize_author</code>, можемо викликати <code>summarize</code> для екземплярів структури <code>Tweet</code> і реалізація за замовчуванням методу <code>summarize</code> буде викликати визначення <code>summarize_author</code>, яке ми вже надали. Оскільки ми реалізували метод <code>summarize_author</code> трейту <code>Summary</code>, то трейт дає нам поведінку метода <code>summarize</code> без необхідності писати код.</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<p>Цей код друкує: <code>1 new tweet: (Read more from @horse_ebooks...)</code>.</p>
<p>Зверніть увагу, що неможливо викликати реалізацію за замовчуванням з перевизначеної реалізації того ж самого методу.</p>
<h3 id="Трейти-як-параметри"><a class="header" href="#Трейти-як-параметри">Трейти як параметри</a></h3>
<p>Тепер, коли ви знаєте, як визначати та реалізовувати трейти, можна вивчити, як використовувати трейти, щоб визначити функції, які приймають багато різних типів. Ми будемо використовувати трейт <code>Summary</code>, який ми реалізували для типів <code>NewsArticle</code> та <code>Tweet</code> у Блоці коду 10-13, щоб визначити функцію <code>notify</code>, яка викликає метод <code>summarize</code> для свого параметра <code>item</code>, який є деяким типом, який реалізує трейт <code>Summary</code>. Для цього ми використовуємо синтаксис <code>impl Trait</code>, наприклад таким чином:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>Замість конкретного типу в параметрі <code>item</code> вказується ключове слово <code>impl</code> та ім'я трейту. Цей параметр приймає будь-який тип, який реалізує вказаний трейт. У тілі <code>notify</code> ми маємо змогу викликати будь-які методи в екземпляра <code>item</code>, які повинні бути визначені при реалізації трейту <code>Summary</code>, наприклад можна викликати метод <code>summarize</code>. Ми можемо викликати <code>notify</code> та передати в нього будь-який екземпляр <code>NewsArticle</code> чи <code>Tweet</code>. Код, який викликає цю функцію з будь-яким іншим типом, таким як <code>String</code> чи <code>i32</code>, не буде компілюватися, тому що ці типи не реалізують трейт <code>Summary</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="Синтаксис-обмеження-трейту"><a class="header" href="#Синтаксис-обмеження-трейту">Синтаксис обмеження трейту</a></h4>
<p>Синтаксис <code>impl Trait</code> працює для простих випадків, але насправді є синтаксичним цукром для більш довгої форми, яка називається <em>обмеження трейту</em>, це виглядає ось так:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>Ця більш довга форма еквівалентна прикладу в минулому розділі, але вона більш багатослівна. Ми розміщуємо оголошення параметра узагальненого типа з обмеженням трейту після двокрапки всередині кутових дужок.</p>
<p>Синтаксис <code>impl Trait</code> зручний та робить більш виразним код у простих випадках, в той час, як більш повний синтаксис обмеження трейту може висловити більшу складність в інших випадках. Наприклад, у нас може бути два параметри, які реалізують трейт <code>Summary</code>. Використання синтаксису <code>impl Trait</code> виглядає наступним чином:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
</code></pre>
<p>Використання <code>impl Trait</code> доцільно, якщо ми хочемо, щоб ця функція дозволяла <code>item1</code> та <code>item2</code> мати різні типи (за умовою, що обидва типи реалізують <code>Summary</code>). Якщо ми хочемо змусити обидва параметри мати один й той самий тип, ми повинні використовувати обмеження трейту, наприклад, ось так:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
</code></pre>
<p>Узагальнений тип <code>T</code> зазначений як тип параметрів <code>item1</code> та <code>item2</code> обмежує функцію таким чином, що конкретний тип значення переданого як аргумент для <code>item1</code> і <code>item2</code> має бути однаковим.</p>
<h4 id="Вказівка-кількох-обмежень-трейтів-за-допомогою-синтаксису-"><a class="header" href="#Вказівка-кількох-обмежень-трейтів-за-допомогою-синтаксису-">Вказівка кількох обмежень трейтів за допомогою синтаксису <code>+</code></a></h4>
<p>Також можна вказати більше одного обмеження трейту. Скажімо, ми хочемо, щоб <code>notify</code> використовував форматування відображення, а також <code>summarize</code> для <code>item</code>: ми вказуємо у визначенні <code>notify</code>, що <code>item</code> повинен реалізувати <code>Display</code> та <code>Summary</code> одночасно. Це можна зробити за допомогою синтаксису <code>+</code>:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {
</code></pre>
<p>Синтаксис <code>+</code> також валідний з обмеженням трейту для узагальнених типів:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
</code></pre>
<p>За наявності двох обмежень трейту, тіло методу <code>notify</code> може викликати <code>summarize</code> та використовувати <code>{}</code> для форматування <code>item</code> під час його друку.</p>
<h4 id="Конкретніші-межі-трейту-за-допомогою-where"><a class="header" href="#Конкретніші-межі-трейту-за-допомогою-where">Конкретніші межі трейту за допомогою <code>where</code></a></h4>
<p>Використання занадто великої кількості обмежень трейту має свої недоліки. Кожен узагальнений тип має свої межі трейту, тому функції з декількома параметрами узагальненого типу можуть містити багато інформації про обмеження між назвою функції та списком її параметрів, що ускладнює читання сигнатури. З цієї причини в Rust є альтернативний синтаксис для визначення обмежень трейту всередині блок <code>where</code> після сигнатури функції. Тому замість того, щоб писати ось так:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<p>Можна використати блок <code>where</code>, наприклад таким чином:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>Сигнатура цієї функції менш захаращена: назва функції, список параметрів, та тип значення, що повертається, знаходяться поруч, а сигнатура не містить в собі множину обмежень трейту.</p>
<h3 id="Повертання-значень-типу-що-реалізує-певний-трейт"><a class="header" href="#Повертання-значень-типу-що-реалізує-певний-трейт">Повертання значень типу, що реалізує певний трейт</a></h3>
<p>We can also use the <code>impl Trait</code> syntax in the return position to return a value of some type that implements a trait, as shown here:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    }
}
</code></pre>
<p>Використовуючи <code>impl Summary</code> для типу, що повертається, ми вказуємо, що функція <code>returns_summarizable</code> повертає деяких тип, який реалізує трейт <code>Summary</code> без позначення конкретного типу. В цьому випадку <code>returns_summarizable</code> повертає <code>Tweet</code>, але код, який викликає цю функцію, цього не знає.</p>
<p>Можливість повертати тип, який визначається тільки ознакою, яку він реалізує, є особливо корисна в контексті замикань та ітераторів, які ми розглянемо у розділі 13. Замикання та ітератори створюють типи, які відомі тільки компілятору, або типи, які дуже довго визначати. Синтаксис <code>impl Trait</code> дозволяє вам лаконічно вказати, що функція повертає деяких тип, що реалізує ознаку <code>Iterator</code>, без необхідності вказувати дуже довгий тип.</p>
<p>Проте, <code>impl Trait</code> можливо використовувати, якщо ви повертаєте тільки один тип. Наприклад, цей код, який повертає значення типу <code>NewsArticle</code> або <code>Tweet</code>, але як тип, що повертається, оголошує <code>impl Summary</code>, не буде працювати:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Penguins win the Stanley Cup Championship!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;of course, as you probably already know, people&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
</code></pre>
<p>Повертання або <code>NewsArticle</code> або <code>Tweet</code> не дозволяється через обмеження того, як реалізований синтаксис <code>impl Trait</code> в компіляторі. Ми подивимося, як написати функцію з такою поведінкою у секції <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Використання об'єктів трейтів, які дозволяють використовувати значення різних типів”</a><!--
ignore --> розділу 17.</p>
<h3 id="Використання-обмежень-трейту-для-умовної-реалізації-методів"><a class="header" href="#Використання-обмежень-трейту-для-умовної-реалізації-методів">Використання обмежень трейту для умовної реалізації методів</a></h3>
<p>Використовуючи обмеження трейту з блоком <code>impl</code>, який використовує параметри узагальненого типу, можна реалізувати методи умовно, для тих типів, які реалізують вказаний трейт. Наприклад, тип <code>Pair&lt;T&gt;</code> у Блоці коду 10-15 завжди реалізує функцію <code>new</code> для повертання нового екземпляру <code>Pair&lt;T&gt;</code> (нагадаємо з секції <a href="ch05-03-method-syntax.html#defining-methods">“Визначення методів”</a><!-- ignore --> розділу 5, що <code>Self</code> це псевдонім типу для типа блоку <code>impl</code>, який в цьому випадку є <code>Pair&lt;T&gt;</code>). Але в наступному блоці <code>impl</code>, <code>Pair&lt;T&gt;</code> реалізує тільки метод <code>cmp_display</code>, якщо його внутрішній тип <code>T</code> реалізує трейт <code>PartialOrd</code>, який дозволяє порівнювати <em>і</em> трейт <code>Display</code>, який забезпечує друкування.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
</code></pre>
<p><span class="caption">Лістинг 10-15: Умовна реалізація методів в узагальнених типів в залежності від обмежень трейту</span></p>
<p>Ми також можемо умовно реалізувати трейт для будь-якого типу, який реалізує інший трейт. Реалізація трейту для будь-якого типу, що задовольняє обмеженням трейту називається <em>загальною реалізацією</em> (blanket implementations) й широко використовується в стандартній бібліотеці Rust. Наприклад, стандартна бібліотека реалізує трейт <code>ToString</code> для будь-якого типу, який реалізує трейт <code>Display</code>. Блок <code>impl</code> в стандартній бібліотеці виглядає приблизно так:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>Оскільки стандартна бібліотека має загальну реалізацію, то можна викликати метод <code>to_string</code> визначений трейтом <code>ToString</code> для будь-якого типу, який реалізує трейт <code>Display</code>. Наприклад, ми можемо перетворити цілі числа в їх відповідні <code>String</code> значення, тому що цілі числа реалізують трейт <code>Display</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>Загальні реалізації наведені в документації до трейту в розділі “Implementors”.</p>
<p>Трейти та обмеження трейтів дозволяють писати код, який використовує параметри узагальненого типу для зменшення дублювання коду, а також вказання компілятору, що ми хочемо узагальнений тип, щоб мати визначену поведінку. Потім компілятор може використовувати інформацію про обмеження трейту, щоб перевірити, що всі конкретні типи, які використовуються з нашим кодом, забезпечують правильну поведінку. У динамічно типізованих мовах програмування ми отримали б помилку під час виконання, якби викликали метод для типу, який не реалізує тип визначений методом. Але Rust перекладає ці помилки на час компіляції, тому ми повинні виправити проблеми, перш ніж наш код почне працювати. Крім того, ми не повинні писати код, який перевіряє свою поведінку під час компіляції, тому що це вже перевірено під час компіляції. Це підвищує швидкодію без необхідності відмовлятися від гнучкості узагальнених типів.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Перевірка-коректності-посилань-за-допомогою-часів-існування"><a class="header" href="#Перевірка-коректності-посилань-за-допомогою-часів-існування">Перевірка коректності посилань за допомогою часів існування</a></h2>
<p>Часи існування (lifetimes) є ще одним узагальненим типом даних, який ми вже використовували. Замість того щоб гарантувати, що тип має бажану поведінку, часи існування гарантують що посилання є валідним доти, доки воно може бути нам потрібним.</p>
<p>В частині <a href="">“Посилання і позичання”</a><!-- ignore --> четвертого розділу ми не згадали про те, що кожне посилання в Rust має свій <em>час існування</em>, який обмежує час протягом якого посилання є дійсним. В більшості випадків, часи існування є неявними (implicit) та виведеними (inferred), так само як і типи. Ми зобовʼязані додавати анотації лише у випадках коли можливий більше ніж один тип. Відповідно, ми мусимо додавати анотації до часів існування лише якщо останні можуть бути використані у кілька різних способів. Rust зобовʼязує нас анотувати звʼязки використовуючи узагальнені параметри часу існування, щоб впевнитися що посилання використані протягом часу виконання програми будуть коректними.</p>
<p>Додавання анотацій для часів існування не є поширеним в інших мовах програмування, тож може бути здаватися дещо складним для сприйняття. Попри те що в цьому розділі ми не розглядатимемо всі деталі часів існування, ми обговоримо їх найбільш загальні способи використання, щоб в подальшому у вас не виникало проблем зі сприйняттям цієї концепції.</p>
<h3 id="Запобігання-висячим-посиланням-з-використанням-часів-існування"><a class="header" href="#Запобігання-висячим-посиланням-з-використанням-часів-існування">Запобігання висячим посиланням з використанням часів існування</a></h3>
<p>Головною метою використання часів існування є запобігання <em>висячим посиланням</em>, які зберігають в памʼяті дані, котрі більше не будуть використані програмою. Розглянемо приклад з блоку коду 10-16, який має внутрішню і зовнішню область видимості.</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
</code></pre>
<p><span class="caption">Блок коду 10-16: Спроба використати посилання, значення якого лежить за межами області видимості</span></p>
<blockquote>
<p>Примітка: Приклади у Блоках коду 10-16, 10-17 та 10-23 проголошують змінні без надання їм початкового значення, тож, назва змінної існує в зовнішньої області видимості. На перший погляд, може видатися, що це суперечить тому, що Rust не має нульових значень. Однак, якщо ми спробуємо використати змінну перед наданням їй значення, ми отримаємо помилку часу компіляції, що показує, що Rust дійсно не допускає значення null.</p>
</blockquote>
<p>Зовнішня область видимості проголошує змінну з назвою <code>r</code> без початкового значення, а внутрішня область видимості проголошує змінну з назвою <code>x</code> з початковим значенням 5. Усередині внутрішньої області видимості ми намагаємося встановити значення r у посилання до <code>x</code>. Тоді внутрішня область видимості закінчується, і ми намагаємося вивести значення <code>r</code>. Цей код не компілюється, бо значення, на яке посилається <code>r</code>, вийшло з області видимості до того, як ми спробували ним скористатися. Ось повідомлення про помилку:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 | 
9 |     println!(&quot;r: {}&quot;, r);
  |                       - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Змінна <code>x</code> не &quot;існує достатньо довго&quot;. Причина в тому, що <code>x</code> вийде з області видимості коли внутрішня область видимості скінчиться у рядку 7. Але змінна <code>r</code> все ще валідна у зовнішній області видимості; оскільки її область видимості більша, ми кажемо, що вона &quot;існує довше&quot;. Якби Rust дозволив цьому коду працювати, <code>r</code> посилався би на пам'ять, що була звільнена, коли <code>x</code> вийшов з області видимості, і все, що ми намагатимемося робити з <code>r</code>, не працюватиме належним чином. То як Rust визначає, що код є некоректним? Вона використовує borrow checker.</p>
<h3 id="borrow-checker"><a class="header" href="#borrow-checker">Borrow Checker</a></h3>
<p>Компілятор Rust має <em>borrow checker</em>, який порівнює області видимості і визначає, чи всі позичання валідні. Блок коду 10-17 показує такий самий код, як у Блоці коду 10-16, але з анотаціями, які показують часи існування змінних.</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {}&quot;, r); //          |
}                         // ---------+
</code></pre>
<p><span class="caption">Блок коду 10-17: анотації часів існування <code>r</code> та <code>x</code>, що називаються відповідно <code>'a</code> та <code>'b</code></span></p>
<p>Тут ми анотували час існування <code>r</code> як <code>'a</code> і час існування <code>x</code> як <code>'b</code>. Як бачите, час існування внутрішнього блоку <code>'b</code> є набагато меншим, ніж зовнішнього <code>'a</code>. Під час компіляції Rust порівнює розмір двох часів існування і бачить, що <code>r</code> має час існування <code>'a</code>, але він посилається на пам'ять з часом існування <code>'b</code>. Програма буде відхилена через те, що <code>'b</code> коротший за <code>'a</code>: те, на що посилаються, існує менше, ніж посилання.</p>
<p>Блок коду 10-18 виправляє код, щоб не було висячого посилання, і компілюється без жодних помилок.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {}&quot;, r); //   |       |
                          // --+       |
}                         // ----------+
</code></pre></pre>
<p><span class="caption">Блок коду 10-18: посилання є валідним, бо дані мають довший час існування, ніж посилання</span></p>
<p>Тут <code>x</code> має час існування <code>'b</code>, що у цьому випадку більше, ніж <code>'a</code>. Це означає, що <code>r</code> може посилатись на <code>x</code>, тому що Rust знає, що посилання в <code>r</code> завжди буде дійсним, поки <code>x</code> є дійсним.</p>
<p>Тепер, коли ви знаєте, де знаходяться часи існування посилань і як Rust аналізує часи існування, щоб гарантувати, що посилання завжди будуть валідними, розгляньмо узагальнені часи існування параметрів та значень, що повертаються, в контексті функцій.</p>
<h3 id="Узагальнені-часи-існування-у-функціях"><a class="header" href="#Узагальнені-часи-існування-у-функціях">Узагальнені часи існування у функціях</a></h3>
<p>Ми напишемо функцію, яка повертає довший з двох стрічкових слайсів. Ця функція прийматиме два стрічкові слайси і повертатиме один слайс. Після реалізації функції <code>longest</code>, код у Блоці коду 10-19 має вивести <code>The longest string is abcd</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Блок коду 10-19: функція <code>main</code>, що викликає функцію <code>longest</code> щоб знайти довший з двох стрічкових слайсів</span></p>
<p>Зверніть увагу, що нам потрібно, щоб функція приймала рядки фрагментів, які є посиланнями, а не стрічки, тому що ми не хочемо, щоб функція <code>longest</code> брала володіння над своїми параметрами. Зверніться до підрозділу <a href="">&quot;Стрічкові слайси як параметри&quot;</a><!-- ignore --> Розділу 4 для детальнішого обговорення, чому ми хочемо використати саме такі параметри в Блоці коду 10-19.</p>
<p>Якщо ми спробуємо реалізувати функцію <code>longest</code> як показано у Блоці коду 10-20, вона не скомпілюється.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p><span class="caption">Блок коду 10-20: реалізація функції <code>longest</code>, що повертає довший з двох стрічкових слайсів, але ще не компілюється</span></p>
<p>Натомість ми отримуємо наступну помилку, яка говорить про часи існування:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Текст підказки показує, що тип, який повертається, потребує для себе вказаного узагальненого часу існування, оскільки Rust не може сказати, буде повернуте посилання <code>x</code> чи <code>y</code>. Насправді ми також цього не знаємо, оскільки блок <code>if</code> у тілі цієї функції повертає посилання на <code>x</code>, а блок <code>else</code> повертає посилання на <code>y</code>!</p>
<p>Коли ми визначаємо цю функцію, ми не знаємо конкретних значень, які будуть передані в цю функцію, тому ми не знаємо, спрацює випадок <code>if</code> чи <code>else</code>. Ми також не знаємо конкретного часу існування посилань, які будуть передані, тож ми не можемо подивитися на область видимості, як ми робили у Блоках коду 10-17 та 10-18, щоб визначити, чи посилання, яке ми повертаємо, буде завжди валідним. Borrow checker також не може визначити цього, оскільки він не знає як час існування <code>x</code> або <code>y</code> стосується часу існування значення, що повертається. Щоб виправити цю помилку, ми додамо узагальнені параметри часу існування, які визначають зв'язок між посиланнями, щоб borrow checker міг його проаналізувати.</p>
<h3 id="Синтаксис-анотацій-часу-існування"><a class="header" href="#Синтаксис-анотацій-часу-існування">Синтаксис анотацій часу існування</a></h3>
<p>Анотації часу існування не змінюють як довго існує посилання. Натомість вони описують взаємозв'язок часів існування багатьох посилань між собою, не впливаючи на ці часи існування. Так само як функції можуть приймати будь-який тип, коли сигнатура визначає параметр узагальненого типу, функції можуть приймати посилання з будь-яким часом існування, якщо заданий узагальнений параметр часу існування.</p>
<p>Анотації часу існування мають дещо незвичний синтаксис: імена параметрів часу існування мають починатися на апостроф (<code>'</code>) і зазвичай в нижньому регістрі та дуже короткі, як узагальнені типи. Більшість людей використовують ім'я <code>'a</code> для першої анотації часу існування. Ми розміщуємо анотації часу існування параметрів після <code>&amp;</code> посилання, використовуючи пробіл для відокремлення анотації від типу посилання.</p>
<p>Ось кілька прикладів: посилання на <code>i32</code> без параметру часу існування, посилання на на <code>i32</code>, що має параметр часу існування <code>'a</code>, і мутабельне посилання на <code>i32</code>, що також має час існування <code>'a</code>.</p>
<pre><code class="language-rust ignore">&amp;i32        // посилання
&amp;'a i32     // посилання з явним часом існування
&amp;'a mut i32 // мутабельне посилання з явним часом існування
</code></pre>
<p>Сам по собі одна анотація часу існування не має великого значення. оскільки анотації мають повідомляти Rust, як узагальнені параметри часу існування багатьох посилань співвідносяться один з одним. Дослідімо, як анотації часу існування співвідносяться одна з одною в контексті функції <code>longest</code>.</p>
<h3 id="Анотації-часу-існування-у-сигнатурах-функцій"><a class="header" href="#Анотації-часу-існування-у-сигнатурах-функцій">Анотації часу існування у сигнатурах функцій</a></h3>
<p>Щоб використовувати анотації часу існування в сигнатурах функцій, ми маємо проголосити узагальнений параметр <em>часу існування</em> в кутових дужках між назвою функції і списком параметрів, так, як це робиться з узагальненими параметрами <em>типу</em>.</p>
<p>Ми хочемо, щоб сигнатура виражала наступне обмеження: повернуте посилання буде валідним стільки, скільки обидва параметри будуть валідними. Це відношення між часом існування параметрів та значення, що повертається. Ми назвемо час існування <code>'a</code>, а тоді додамо його до кожного посилання, як показано в Блоці коду 10-21.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p><span class="caption">Блок коду 10-21: Визначення функції <code>longest</code> із зазначенням, що всі посилання у сигнатурі повинні мати однаковий час існування <code>'a</code></span></p>
<p>Цей код має компілюватися і створювати бажаний результат, коли ми використовуємо його у функції <code>main</code> у Блоці коду 10-19.</p>
<p>Сигнатура функції тепер повідомляє Rust, що для якогось часу існування <code>'a</code> функція приймає два параметри, обидва з яких - стрічкові слайси, які існують принаймні так довго, як час існування <code>'a</code>. Сигнатура функції також каже Rust, що стрічковий слайс, повернутий з функції, існуватиме щонайменше так довго, як час існування <code>'a</code>. На практиці це означає, що час існування посилання, повернутого функцією <code>longest</code>, дорівнює коротшому з часів існування значень, на які посилаються аргументи функції. Ці відносини - це те, що ми хочемо, щоб Rust використовувала під час аналізу цього коду.</p>
<p>Пам'ятайте, що коли ми зазначаємо час існування параметрів на сигнатурі цієї функції, ми не змінюємо час існування жодного значення, які передаються або повертаються. Радше ми уточнюємо, що borrow checker повинен відкидати будь-які значення, які не відповідають цим обмеженням. Зверніть увагу, що функція <code>longest</code> не повинна точно знати, як довго <code>x</code> і <code>y</code> будуть існувати, лише те, що деяка область видимості може бути замінена на <code>'a</code> що задовольняє цій сигнатурі.</p>
<p>При анотації часів існування у функції анотації зазначаються у сигнатурі функції, а не в її тілі. Анотації часу існування стають частиною контракту функції, так само, як типи у сигнатурі. Те, що сигнатури функцій містять контракт на час існування, означає, що аналіз, який робить компілятор Rust, буде простішим. Якщо є проблема з тим, як функція анотована або як її викликають, помилки компілятора можуть точніше вказувати на частину нашого коду та обмеження. Якщо натомість компілятор Rust робив більше припущень про те, якими ми хотіли б бачити відносини між часами існування, компілятор міг би вказувати лише на використання нашого коду за багато кроків від причини проблеми.</p>
<p>Коли ми передаємо конкретні посилання до <code>longest</code>, конкретний час існування, що підставляється в <code>'a</code>, є частиною області видимості <code>x</code>, що перетинається з областю видимості <code>y</code>. Іншими словами, узагальнений час існування <code>'a</code> отримає конкретний час існування, що є рівним меншому з часів існування <code>x</code> та <code>y</code>. Оскільки ми анотували посилання, що повертається, тим самим параметром часу існування <code>'a</code>, посилання, що повертається, також буде валідним під час тривалості меншого з часів інсування <code>x</code> та <code>y</code>.</p>
<p>Подивімося, як анотації часу існування обмежують функцію <code>longest</code>, передаючи посилання, що мають різне конкретні часи існування. Блок коду 10-22 надає прямолінійний приклад.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 10-22: використання функції &quot;longest&quot; з посиланнями на значення &quot;String&quot;, які мають різний конкретний час існування</span></p>
<p>У цьому прикладі <code>string1</code> буде валідним до кінця зовнішньої області видимості, <code>string2</code> до кінця внутрішньої області видимості, а <code>result</code> посилається на щось, що є валідним до кінця внутрішньої області видимості. Запустіть цей код, і ви побачите, що borrow checker його приймає; код скомпілюється і виведе <code>The longest string is long string is long</code>.</p>
<p>Далі розгляньмо приклад, який показує, що час існування посилання в <code>result</code> має бути меншим з тривалостей існування двох аргументів. Ми перемістимо оголошення змінної <code>result</code> за межі внутрішньої області видимості, але залишимо присвоєння значення змінній <code>result</code> усередині області видимості зі <code>string2</code>. Потім ми перемістимо <code>println!</code>, який використовує <code>result</code>, за межі внутрішньої області видимості, її після закінчення. Код в Блоці коду 10-23 не скомпілюється.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 10-23: спроба використати <code>result</code> після виходу <code>string2</code> з області видимості</span></p>
<p>Якщо ми спробуємо скомпілювати цей код, то отримаємо таку помилку:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^^^^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;The longest string is {}&quot;, result);
  |                                          ------ borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Помилка показує, що для того, що <code>result</code> був валідним для інструкції <code>println!</code>, <code>string2</code> має бути валідним до кінця зовнішньої області видимості. Rust знає це, бо ми анотували час існування параметрів функції та значення, що повертається, за допомогою того самого параметра часу існування <code>'a</code>.</p>
<p>Як люди, ми можемо подивитися на цей код і побачити, що <code>string1</code> довша за <code>string2</code> і тому <code>result</code> міститиме посилання на <code>string1</code>. Оскільки <code>string1</code> ще не вийшла з області видимості, посилання на <code>string1</code> все ще буде валідним для інструкції <code>println!</code>. Однак, компілятор не може побачити, що посилання в цьому випадку валідне. Ми повідомили Rust, що час існування посилання, що повертається функцією <code>longest</code>, такий самий, як менший з часів існування переданих їй посилань. Тому borrow checker забороняє код у Блоці коду 10-23 як такий, що потенційно містить неправильне посилання.</p>
<p>Спробуйте провести більше експериментів, які змінюють значення і часи існування посилань, переданих у функцію <code>longest</code>, а також використання посилання, що повертається. Робіть припущення про те, чи пройдуть ваші експерименти borrow checker до компіляції; потім перевірте, щоб побачити, чи маєте ви рацію!</p>
<h3 id="Мислення-в-термінах-часів-існування"><a class="header" href="#Мислення-в-термінах-часів-існування">Мислення в термінах часів існування</a></h3>
<p>Спосіб, яким треба позначати параметри часу існування, залежить від того, що саме робить ваша функція. Наприклад, якби ми змінили реалізацію функції <code>longest</code>, щоб та завжди повертала перший параметр замість найдовшої стрічки, то нам не потрібно було б вказувати час існування для параметра <code>y</code>. Цей код буде скомпілюється:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre></pre>
<p>Ми зазначили параметр часу існування <code>'a</code> для параметра <code>x</code> та типу, що повертається, але не для параметра <code>y</code>, оскільки час існування <code>у</code> у не має стосунку до часу існування <code>x</code> або значення, що повертається.</p>
<p>При поверненні посилання з функції, параметр часу існування для типу, що повертається, має збігатися з параметром часу існування для одного з параметрів. Якщо повернуте посилання <em>не</em> посилається на один з параметрів, воно повинне посилатись на значення, створене всередині цієї функції. Однак це буде висяче посилання, тому що значення вийде з області видимості в кінці функції. Розглянемо спробу реалізації функції <code>longest</code>, яка не компілюється:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre>
<p>Тут, хоча ми й зазначили параметр часу існування <code>'a</code> для типу, що повертається, ця реалізація не буде скомпільованою, оскільки час існування значення, що повертається, взагалі не пов'язаний з часом існування параметрів. Ось яке повідомлення про помилку ми отримаємо:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return reference to local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Проблема в тому, що <code>result</code> виходить з області видимості й очищується в кінці функції <code>longest</code>. Ми також намагаємося повернути з функції посилання на <code>result</code>. Неможливо вказати параметри часу існування, які змінять висяче посилання, і Rust не дозволяє нам створити висяче посилання. У цьому випадку найкращим виправленням було б повернути тип, що володіє даними, замість посилання, щоб функція, яка викликала, була б відповідальною за очищення значення.</p>
<p>Зрештою, синтаксис часу існування стосується зв'язування часів існування різних параметрів і значень, що повертаються з функцій. Коли вони пов'язуються, Rust має достатньо інформації, щоб дозволити безпечні операції з пам'яттю і забороняти операції, які створювали б висячі вказівники або іншим чином порушували безпеку пам’яті.</p>
<h3 id="Анотації-часів-існування-у-визначеннях-структур"><a class="header" href="#Анотації-часів-існування-у-визначеннях-структур">Анотації часів існування у визначеннях структур</a></h3>
<p>Досі всі визначені нами структури містили типи, що володіють даними. Ми можемо визначити структури, що міститимуть посилання, але в цьому разі ми маємо додати анотацію часу існування до кожного посилання у визначенні структури. Блок коду 10-24 демонструє структуру, що зветься <code>ImportantExcerpt</code>, що містить стрічковий слайс.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre></pre>
<p><span class="caption">Блок коду 10-24: структура, що містить посилання, яке потребує анотації часу існування</span></p>
<p>Ця структура має єдине поле <code>part</code>, що містить стрічковий слайс, що є посиланням. Як і для узагальнених типів даних, ми проголошуємо назву узагальненого параметру часу існування в кутових дужках після назви структури, щоб ми могли використати цей параметр часу існування у визначенні структури. Ця анотація означає, що екземпляр <code>ImportantExcerpt</code> не може існувати довше, ніж посилання, яке він містить у своєму полі <code>part</code>.</p>
<p>Функція <code>main</code> тут створює екземпляр структури <code>ImportantExcerpt</code>, який містить посилання на перше речення <code>String</code>, якою володіє змінна <code>novel</code>. Дані в <code>novel</code> існують до створення екземпляра <code>ImportantExcerpt</code>. Крім того, <code>novel</code> не виходить з області видимості, доки <code>ImportantExcerpt</code> не вийде з області видимості, тож посилання в екземплярі <code>ImportantExcerpt</code> є валідним.</p>
<h3 id="Елізія-часу-існування"><a class="header" href="#Елізія-часу-існування">Елізія часу існування</a></h3>
<p>Ви дізналися, що кожне посилання має час існування і ви маєте зазначити параметри часу існування для функцій та структур, які використовують посилання. Однак у Розділі 4 у нас була функція в Блоці коду 4-9, показана знову у Блоці коду 10-25, яка скомпілювалася без анотацій часу існування.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 10-25: функція, визначена в Блоці коду 4-9, яка компілюється без анотацій часу існування, хоча параметр і тип, що повертається є посиланнями</span></p>
<p>Причина, чому ця функція компілюється без анотацій часу існування, є історичною: у ранніх версіях (до 1.0) Rust цей код не скомпілювався б тому, що кожне посилання потребувало явного часу існування. На той момент сигнатура функції була б записана так:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Після написання великої кількості коду на Rust, команда Rust виявила, що програмісти Rust вводять ті самі анотації часу існування знову і знову в конкретних випадках. Ці ситуації були передбачуваними та відповідали декільком визначеним шаблонів. Розробники запрограмували ці шаблони у код компілятора, щоб borrow checker міг вивести часи існування в цих ситуаціях і не потребував явних анотацій.</p>
<p>Цей шматок історії Rust має значення, оскільки цілком можливо, що буде виявлено ще більше визначених шаблонів і будуть додані до компілятора. Можливо, у майбутньому буде потрібно ще менше анотацій часу існування.</p>
<p>Шаблони, запрограмовані в аналіз посилань Rust, називаються <em>правилами елізії часів існування</em>. Це не правила для програмістів; вони є набором певних випадків, які розглядає компілятор, і якщо ваш код відповідає цим випадкам, вам не потрібно явно вказувати часи існування.</p>
<p>Правила елізії не забезпечують повного виведення. Якщо Rust детерміновано застосовує правила, але залишається невизначеність щодо того, які часи існування мають посилання, компілятор не зможе здогадатися, якими мають бути часи існування решти посилань. Замість відгадування компілятор дасть вам помилку, котру ви можете її усунути, додавши анотації часів існування.</p>
<p>Часи існування на параметрах функції чи методу називаються <em>вхідні часи існування</em>, а часи існування на значеннях, що повертаються - <em>вихідні часи існування</em>.</p>
<p>Компілятор використовує три правила, щоб знайти час існування для посилань, коли немає явних анотацій. Перше правило застосовується до вхідних часів існування, а друге і третє правила до вихідного часу існування. Якщо компілятор досягає закінчуння трьох правил все ще є посилання, для яких він не може визначити часи існування, компілятор зупиниться з помилкою. Ці правила застосовуються до проголошень <code>fn</code>, а також до блоків <code>impl</code>.</p>
<p>Перше правило полягає в тому, що компілятор встановлює параметр часу існування для кожного параметра, що є посиланням. Іншими словами, функція з одним параметром отримує один параметр часу існування: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; функція з двома параметрами отримує два окремі параметри часу існування:<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>; і так далі.</p>
<p>Друге правило полягає в тому, що якщо існує рівно один вхідний параметр часу існування, цей час існування призначається на всі вихідні параметри часів існування: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>Третє правило полягає в тому, що якщо є багато вхідних параметрів часу існування, але один з них є <code>&amp;self</code> or <code>&amp;mut self</code>, бо це метод, час існування <code>self</code> призначається усім вихідним параметрам часу існування. Це третє правило набагато полегшує читання і писання методів, бо потрібно менше символів.</p>
<p>Зробімо вигляд, що ми компілятор. Ми застосуємо ці правила, щоб визначити часи існування посилань у сигнатурі функції <code>first_word</code> у Блоці коду 10-25. Сигнатура починається без жодних часів існування, пов'язаних із посиланнями:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Потім компілятор застосовує перше правило, яке визначає, що кожен параметр отримує свій власний час існування. Ми назвемо його <code>'a</code>, як зазвичай, тому тепер сигнатура є такою:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>Друге правило застосовується, бо тут є рівно один вхідний час існування. Друге правило каже, що час існування єдиного вхідного параметра призначається вихідному часу існування, тож сигнатура тепер така:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Тепер всі посилання в сигнатурі цієї функції мають часи існування, і компілятор може продовжити свій аналіз, не змушуючи програміста анотувати часи існування в сигнатурі цієї функції.</p>
<p>Розгляньмо інший приклад, цього разу з функцією <code>longest</code>, яка не мала параметрів часу існування, коли ми почали працювати з нею у Блоці коду 10-20:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Застосуємо перше правило: кожен параметр отримує свій час існування. Цього разу ми маємо два параметри замість одного, тому ми маємо два часи існування:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>Як бачите, друге правило не застосовується, тому що є більш ніж один вхідний час існування. Третє правило також не застосовується, тому що <code>longest</code> є функцією, а не методом, тож жоден з параметрів не є <code>self</code>. Виконавши всі три правила, ми все ще не з'ясували час існування типу, що повертається. Саме тому ми отримали помилку при спробі скомпілювати код у Блоці коду 10-20: компілятор пропрацював правила елізії часів існування, але все ж не зміг з'ясувати всі часи існування посилань у сигнатурі.</p>
<p>Оскільки третє правило застосовується тільки в сигнатурі методів, далі ми подивимося на часи існування в цьому контексті, щоб зрозуміти, чому третє правило означає, що нам не дуже часто доводиться анотувати часи існування у сигнатурах методів.</p>
<h3 id="Анотації-часів-існування-у-визначеннях-методів"><a class="header" href="#Анотації-часів-існування-у-визначеннях-методів">Анотації часів існування у визначеннях методів</a></h3>
<p>Коли ми реалізовуємо методи для структур з часами існування, то використовуємо той самий синтаксис, що і параметри узагальненого типу, показані у Блоці коду 10-11. Де нам проголошувати і використовувати параметри часу існування, залежить від того, чи стосуються вони полів структури, чи параметрів методу і значення, що повертається.</p>
<p>Назви часу існування полів структур завжди треба проголошувати після ключового слова <code>impl</code>, а потім використовувати після назви структури, тому що ці часи існування є частиною типу структури.</p>
<p>У сигнатурах методів всередині блоку <code>impl</code> посилання мають бути або прив'язані до часу існування посилань у полях структури, або ж мають бути незалежними. Крім того, правила елізії часів існування часто роблять анотації часів існування непотрібними у сигнатурах методів. Погляньмо на деякі приклади, використовуючи структуру з назвою <code>ImportantExcerpt</code>, яку ми визначили у Блоці коду 10-24.</p>
<p>Спершу, ми використовуємо метод з назвою <code>level</code>, єдиним параметром якого є посилання на <code>self</code>, а значення, що повертається є <code>i32</code>, що не є посиланням:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!(&quot;Attention please: {}&quot;, announcement);
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<p>Декларація параметра часу існування після <code>impl</code> і його використання після назви типу є необхідними, але ми не маємо анотувати час існування посилання на <code>self</code> через перше правило елізії.</p>
<p>Ось приклад, де застосовується третє правило елізії часу існування:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<p>Тут є два вхідних часи існування, тож Rust застосовує перше правило елізії часів існування і дає обом <code>&amp;self</code> та <code>announcement</code> власні часи існування. Тоді, оскільки один з параметрів є <code>&amp;self</code>, тип, що повертається. отримує час існування <code>&amp;self</code>, і всі часи існування було призначено.</p>
<h3 id="Статичний-час-існування"><a class="header" href="#Статичний-час-існування">Статичний час існування</a></h3>
<p>Ми маємо обговорити один особливий час існування - <code>'static</code>, що позначає, що посилання <em>може</em> існувати весь час роботи програми. Всі стрічкові літерали мають час існування <code>'static</code>, що ми можемо анотувати таким чином:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Текст цієї стрічки зберігається безпосередньо в двійковому файлі програми, який є завжди доступним. Таким чином, час життя усіх стрічкових літералів є <code>'static</code>.</p>
<p>Ви можете побачити пропозиції використовувати час існування <code>'static</code> у повідомленнях про помилки. Але перш ніж вказати часом існування посилання <code>'static</code>, подумайте, чи дійсно ваше посилання існує впродовж усієї роботи вашої програми чи ні, і чи хочете, щоб воно таким було. У більшості випадків повідомлення про помилку, що пропонує час існування <code>'static</code> є результатом спроби створити висяче посилання чи невідповідність наявних часів існування. У таких випадках рішенням є виправити ці проблеми, а не визначити час існування <code>'static</code>.</p>
<h2 id="Параметри-узагальненого-типу-обмеження-трейтів-і-часи-існування-разом"><a class="header" href="#Параметри-узагальненого-типу-обмеження-трейтів-і-часи-існування-разом">Параметри узагальненого типу, обмеження трейтів і часи існування разом</a></h2>
<p>Подивімося коротко на синтаксис визначення параметрів узагальненого типу, обмежень трейтів і часів існування разом в одній функції!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Today is someone's birthday!&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>Це функція <code>longest</code> зі Блоку коду 10-21, яка повертає довший із двох стрічкових слайсів. Але тепер вона має додатковий параметр з назвою <code>ann</code> узагальненого типу <code>T</code>, який може бути заповнений будь-яким типом, який реалізує трейт <code>Display</code>, як зазначено в клаузі <code>where</code>. Цей додатковий параметр буде виведено за допомогою <code>{}</code>, то й робить необхідним обмеження трейту <code>Display</code>. Оскільки часи існування є узагальненням, проголошення параметра часу існування <code>'a</code> і параметру узагальненого типу <code>T</code> розміщуються в одному списку в кутових дужках після назви функції.</p>
<h2 id="Підсумок-9"><a class="header" href="#Підсумок-9">Підсумок</a></h2>
<p>Ми багато відкрили в цьому розділі! Тепер, коли ви знаєте про параметри узагальненого типу, трейти і трейтові обмеження, і узагальнені параметри часу існування, ви готові написати код без повторень, що працюватиме у багатьох різних ситуаціях. Параметри узагальнених типів дозволяють вам застосовувати один код для різних типів. Трейти та трейтові обмеження гарантують, що навіть якщо типи є узагальненими, вони матимуть поведінку, потрібну коду. Ви вивчили, як використовувати анотації часу існування, щоб убезпечити такий гнучкий код від висячих посилань. І відбувається весь цей аналіз під час компіляції, що не впливає на продуктивність під час виконання!</p>
<p>Вірите ви чи ні, є ще багато чого, що можна дізнатися про обговорені в цьому розділі теми: Розділ 17 обговорює трейтові об'єкти, які є іншим способом використання трейтів. Також є складніші сценарії, що використовують анотації часів існування, що знадобляться вам лише у дуже просунутих сценаріях; для них ви маєте прочитати <a href="../reference/index.html">Rust Reference</a>. Та зараз ви навчитеся писати тести на Rust, щоб переконатися, що ваш код працює так, як треба.
ch04-02-references-and-borrowing.html#references-and-borrowing ch04-03-slices.html#string-slices-as-parameters</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Написання-автоматизованих-тестів"><a class="header" href="#Написання-автоматизованих-тестів">Написання автоматизованих тестів</a></h1>
<p>У 1972 році у своєму есе &quot;Скромний програміст&quot; Едсгер Дейкстра сказав “Тестування програми може бути дуже ефективним способом показати наявність помилок, але його зовсім недостатньо, щоб показати їх відсутність.” Це не означає, що ми не повинні тестувати стільки, скільки ми можемо!</p>
<p>Коректність наших програм полягає у ступені відповідності того, що вони роблять тому, що ми мали на увазі, коли їх розробляли. Rust розроблений з високим ступенем турботи про коректність програм, але коректність є складною та її не легко довести. Система типів Rust несе величезну частину цього тягаря, але вона не здатна впоратися з усім. Таким чином, Rust включає підтримку написання автоматизованих тестів програмного забезпечення.</p>
<p>Нехай ми пишемо функцію <code>add_two</code> яка додає 2 до будь-якого числа, що передано в неї. В сигнатурі цієї функції ми вказуємо ціле число як вхідний параметр, та ціле число, як результат, що повертається. Коли ми реалізуємо та компілюємо цю функцію, Rust робить усі перевірки типів та запозичень, щоб гарантувати, що ми не передаємо <code>String</code> або недійсне посилання до цієї функції. Але Rust <em>не може</em> перевірити, що ця функція робить безпосередньо те, що ми задумали, що повертає параметр плюс 2, а не, скажімо, параметр плюс 10 або параметр мінус 50! Ось тут і з'являються тести.</p>
<p>Ми можемо написати тести, які підтверджують, що, наприклад, коли ми передаємо <code>3</code> до функції <code>add_two</code>, то вона повертає значення <code>5</code>. Ми можемо запускати ці тести кожного разу, коли вносимо зміни до нашого коду, щоб бути впевненими в тому, що коректна поведінка програми при цьому не змінилася.</p>
<p>Тестування - це складна навичка: хоча ми не можемо в одному розділі охопити усі нюанси того, як створювати гарні тести, ми оглянемо засоби тестування у Rust. Ми поговоримо про анотації та макроси, доступні вам для написання тестів, про поведінку за замовчуванням та параметри для запуску ваших тестів, а також як організувати тестування за допомогою unit- та інтеграційних тестів.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Як-писати-тести"><a class="header" href="#Як-писати-тести">Як писати тести</a></h2>
<p>Тести - це функції Rust, які перевіряють, чи тестований код працює у очікуваний спосіб. Тіла тестових функцій зазвичай виконують наступні три дії:</p>
<ol>
<li>Встановити будь-яке потрібне значення або стан.</li>
<li>Запустити на виконання код, який ви хочете протестувати.</li>
<li>Переконатися, що отримані результати відповідають вашим очікуванням.</li>
</ol>
<p>Розгляньмо функціонал, наданий Rust спеціально для написання тестів та виконання зазначених дій, що включає атрибут <code>test</code>, декілька макросів, а також атрибут <code>should_panic</code>.</p>
<h3 id="Анатомія-тестувальної-функції"><a class="header" href="#Анатомія-тестувальної-функції">Анатомія тестувальної функції</a></h3>
<p>У найпростішому випадку тест у Rust - це функція, анотована за допомогою атрибута <code>test</code>. Атрибути - це метадані фрагментів коду на Rust; прикладом може бути атрибут <code>derive</code>, який ми використовували зі структурами у Розділі 5. Для перетворення звичайної функції на тестувальну функцію додайте <code>#[test]</code> у рядок перед <code>fn</code>. Коли ви запускаєте ваші тести командою <code>cargo test</code>, Rust збирає двійковий файл, що запускає анотовані функції та звітує, чи тестові функції пройшли, чи провалилися.</p>
<p>Кожного разу, коли ми створюємо новий бібліотечний проєкт за допомогою Cargo, він автоматично генерує для нас тестовий модуль з тестовими функціями. Цей модуль надає вам шаблон для написання тестів, а отже вам непотрібно кожного разу при створенні нового проєкту уточнювати їхню структуру та синтаксис. Ви можете додати стільки тестових модулів та тестових функцій, скільки забажаєте!</p>
<p>Перш ніж фактично протестувати будь-який код, ми розглянемо деякі аспекти роботи тестів, експериментуючи з шаблоном тесту. Потім ми напишемо декілька реальних тестів, що запускають наш код та підтверджують, що його поведінка є правильною.</p>
<p>Створімо новий бібліотечний проєкт під назвою <code>adder</code>, в якому додаються два числа:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>Вміст файлу <em>src/lib.rs</em> у вашій бібліотеці <code>adder</code> має виглядати, як показано в Блоці коду 11-1.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
cargo test
git co output.txt
cd ../../..
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
</code></pre>
<p><span class="caption">Блок коду 11-1: тестовий модуль і функція, створена автоматично за допомогою <code>cargo new</code></span></p>
<p>Наразі проігноруймо два верхні рядки та зосередимося на функції. Зверніть увагу на анотацію <code>#[test]</code>: цей атрибут вказує на те, що функція є тестувальною, тож функціонал для запуску тестів ставитиметься до неї, як до тесту. Ми також можемо мати нетестувальні функції в модулі <code>tests</code>, щоб допомогти налаштувати типові сценарії або виконати загальні операції, тому ми завжди повинні позначати анотаціями, які саме функції є тестувальними.</p>
<p>Тіло функції зі приклада використовує макрос <code>assert_eq!</code> для ствердження того, що <code>result</code>, який містить результат операції додавання 2 та 2, дорівнює 4. Це ствердження служить типовим зразком формату для тесту. Запустімо його та впевнимось, що тест проходить.</p>
<p>Команда <code>cargo test</code> запускає усі тести з нашого проєкту, як показано у Блоці коду 11-2.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p><span class="caption">Блок коду 11-2: виведення після запуску автоматично згенерованого тесту</span></p>
<p>Cargo скомпілював та запустив тест. Ми бачимо рядок <code>running 1 test</code>. Наступний рядок показує назву згенерованої тестувальної функції <code>it_works</code>, а також що результат запуску тесту є <code>ok</code>. Загальний результат <code>test result: ok.</code> означає, що усі тести пройшли, а частина <code>1 passed; 0 failed</code> показує загальну кількість тестів що були пройдені та провалилися.</p>
<p>Можна позначити деякі тести як ігноровані, тоді вони не будуть запускатися; ми розглянемо це далі у цьому розділі у підрозділі<a href="ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested"> &quot;Ігнорування окремих тестів без спеціального уточнення&quot;</a><!-- ignore --> . Оскільки ми не позначали жодного тесту для ігнорування, то отримуємо на виході <code>0 ignored</code>. Ми також можемо додати до команди <code>cargo test</code> аргумент, щоб запускалися лише ті тести, що відповідають певній стрічці; Це називається <em>фільтрацією</em> та ми поговоримо про це у підрозділі <a href="ch11-02-running-tests.html#running-a-subset-of-tests-by-name">&quot;Запуск підмножини тестів за назвою&quot;</a><!-- ignore --> . Ми також не маємо відфільтрованих тестів, тому вивід показує <code>0 filtered out</code>.</p>
<p><code>0 measured</code> показує статистику бенчмарків, що тестують швидкодію. Бенчмарки на момент написання цієї статті доступні лише у нічних збірках Rust. Дивись <a href="../unstable-book/library-features/test.html">документацію про бенчмарки</a> для більш детальної інформації.</p>
<p>Наступна частина виводу <code>Doc-tests adder</code> призначена для результатів документаційних тестів. У нас поки що немає документаційних тестів, але Rust може скомпілювати будь-які приклади коду з документації по нашому API. Ця функція допомагає синхронізувати вашу документацію та код! Ми розглянемо, як писати документаційні тести в підрозділі <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">“Документаційні коментарі як тести”</a><!-- ignore --> Розділу 14. Зараз ми проігноруємо частину виводу, присвячену <code>Doc-tests</code>.</p>
<p>Налаштуймо тест для відповідності нашим потребам. Спочатку змінимо назву тестової функції <code>it_works</code> на іншу, наприклад <code>exploration</code>, ось так:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<p>Далі знову запустимо <code>cargo test</code>. Вивід тепер покаже <code>exploration</code> замість <code>it_works</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Тепер ми додамо інший тест, але цього разу він завершиться зі збоєм! Тести завершуються зі збоєм, коли щось у тестувальній функції викликає паніку. Кожний тест запускається в окремому потоці, та коли головний потік бачить, що тестовий потік упав, то тест позначається як такий невдалий. У Розділі 9 ми розглядали найпростіший спосіб викликати паніку за допомогою виклику макросу <code>panic!</code>. Створіть новий тест та назвіть тестувальну функцію <code>another</code>, щоб ваш файл <em>src/lib.rs</em> виглядав як у Блоці коду 11-3.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}
</code></pre>
<p><span class="caption">Блок коду 11-3: додавання другого тесту, що провалюється, бо ми викликаємо макрос <code>panic!</code></span></p>
<p>Запустіть тест знову, використовуючи <code>cargo test</code>. Вивід виглядатиме схоже на Блок коду 11-4, який показує, що тест <code>exploration</code> пройшов, а <code>another</code> провалився.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'main' panicked at 'Make this test fail', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p><span class="caption">Блок коду 11-4: результати тестів, коли один тест проходить, а другий провалюється</span></p>
<p>Замість <code>ok</code>, рядок <code>test tests::another</code> показує <code>FAILED</code>. Дві нові секції з'явилися між результатами окремих тестів та загальними результатами: перша показує детальну причину того, чому тест провалився. У цьому випадку ми отримали те, що тест <code>another</code> провалився тому, що <code>panicked at 'Make this test fail'</code> у рядку 10 у файлі <em>src/lib.rs</em>. У наступній секції наведені назви тестів, що провалилися, і це зручно коли у нас багато таких тестів та багато деталей про провали. Ми можемо використати назву тесту для його подальшого зневадження; ми поговоримо більше про запуск тестів у підрозділі <a href="">Керування запуском тестів&quot;</a><!-- ignore
--> .</p>
<p>У кінці показується підсумковий результат тестування: в цілому результат нашого тесту <code>FAILED</code>. У нас один тест пройшов, та один провалився.</p>
<p>Тепер, коли ви побачили, як виглядають результати тесту в різних сценаріях, розгляньмо деякі макроси, крім <code>panic!</code>, які корисні в тестах.</p>
<h3 id="Перевірка-результатів-за-допомогою-макроса-assert"><a class="header" href="#Перевірка-результатів-за-допомогою-макроса-assert">Перевірка результатів за допомогою макроса <code>assert!</code></a></h3>
<p>Макрос <code>assert!</code>, що надається стандартною бібліотекою, широко використовується для того, щоб впевнитися, що деяка умова у тесті приймає значення <code>true</code>. Ми даємо макросу <code>assert!</code> аргумент, який обчислюється як вираз булевого типу. Якщо значення обчислюється як <code>true</code>, нічого поганого не трапляється та тест вважається пройденим. Якщо ж значення буде <code>false</code> макрос <code>assert!</code> викликає паніку <code>panic!</code>, що спричиняє провал тесту. Використання макросу <code>assert!</code> допомагає нам перевірити, чи працює наш код в очікуваний спосіб.</p>
<p>У Розділі 5, Блок коду 5-15, ми використовували структуру <code>Rectangle</code> та метод <code>can_hold</code>, які повторюються у Блоці коду 11-5. Розмістімо цей код у файлі <em>src/lib.rs</em>, а далі напишемо декілька тестів, використовуючи макрос <code>assert!</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
</code></pre>
<p><span class="caption">Блок коду 11-5: використання структури <code>Rectangle</code> і її методу <code>can_hold</code> з Розділу 5</span></p>
<p>Метод <code>can_hold</code> повертає булеве значення, що означає, що це ідеальний варіант використання для макросу <code>assert!</code>. У Блоці коду 11-6 ми пишемо тест, який перевіряє метод <code>can_hold</code>, створивши екземпляр <code>Rectangle</code>, що має ширину 8 і висоту 7, і стверджує, що він може вмістити інший екземпляр <code>Rectangle</code>, що має ширину 5 і висоту 1.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}
</code></pre>
<p><span class="caption">Блок коду 11-6: тест для <code>can_hold</code>, що перевіряє, чи більший прямокутник справді може вмістити менший</span></p>
<p>Зверніть увагу, що ми додали новий рядок всередині модуля <code>tests</code>: <code>use super::*;</code>. Модуль <code>tests</code> є звичайним модулем, що слідує звичайним правилам видимості, про які ми розповідали у підрозділі <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Шляхи для посилання на елемент в дереві модулів”</a><!-- ignore -->
Розділу 7. Оскільки модуль <code>tests</code> є внутрішнім модулем, нам потрібно ввести код для тестування з зовнішнього модуля до області видимості внутрішнього модуля. Ми використовуємо глобальний режим для того, щоб все, що визначене у зовнішньому модулі, було доступним к модулі <code>tests</code>.</p>
<p>Ми назвали наш тест <code>larger_can_hold_smaller</code>і створили потрібні нам два екземпляри <code>Rectangle</code>. Тоді ми викликали макрос <code>assert!</code> і передали йому результат виклику <code>larger.can_hold(&amp;smaller)</code>. Цей вираз повинен повернути <code>true</code>, тому наш тест повинен пройти. З'ясуймо, чи це так!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Цей тест проходить! Додамо ще один тест, цього разу стверджуючи, що менший прямокутник не може вміститися в більшому:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
</code></pre>
<p>Оскільки правильний результат функції <code>can_hold</code> у цьому випадку <code>false</code>, нам необхідно обернути результат перед тим, як передати його до макросу <code>assert!</code>. В результаті наш тест пройде, якщо <code>can_hold</code> повертає <code>false</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Проходять вже два тести! Тепер подивімося, що відбувається з результатами тесту, якщо в код додати ваду. Ми змінимо реалізацію методу <code>can_hold</code>, замінивши знак більше на менше при порівняння ширин:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Запуск тестів тепер виводить таке:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'main' panicked at 'assertion failed: larger.can_hold(&amp;smaller)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Наші тести викрили ваду! Оскільки <code>larger.width</code> дорівнює 8, а <code>smaller.width</code> дорівнює 5, порівняння ширин у <code>can_hold</code> тепер повертає <code>false</code>: 8 не є меншим за 5.</p>
<h3 id="Тестування-на-рівність-за-допомогою-макросів-assert_eq-та-assert_ne"><a class="header" href="#Тестування-на-рівність-за-допомогою-макросів-assert_eq-та-assert_ne">Тестування на рівність за допомогою макросів <code>assert_eq!</code> та <code>assert_ne!</code></a></h3>
<p>Поширеним способом перевірки функціональності є перевірка на рівність між результатом коду, що тестується, і значенням, яке ви очікуєте від коду. Ви можете зробити це за допомогою макросу <code>assert!</code>, передавши йому вираз за допомогою оператора <code>==</code>. Однак це такий поширений тест, що стандартна бібліотека надає пару макросів — <code>assert_eq!</code> та <code>assert_ne!</code> — для зручнішого проведення цього тесту. Ці макроси порівнюють два аргументи на рівність або нерівність відповідно. Також вони виводять два значення, якщо ствердження провалюється, що допомагає зрозуміти, <em>чому</em> тест провалився; і навпаки, макрос <code>assert!</code> лише вказує на те, що отримав значення <code>false</code> для виразу <code>==</code>, без виведення значень, що призвели до цього <code>false</code>.</p>
<p>У Блоці коду 11-7 ми пишемо функцію з назвою <code>add_two</code>, яка додає до свого параметра <code>2</code>, а потім тестуємо цю функцію за допомогою макросу <code>assert_eq!</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p><span class="caption">Блок коду 11-7: Тестування функції <code>add_two</code> за допомогою макросу <code>assert_eq!</code></span></p>
<p>Переконаймося, що вона проходить!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Ми передали <code>4</code> як аргумент <code>assert_eq!</code>, що дорівнює результату виклику <code>add_two(2)</code>. Рядок для цього тесту <code>test tests::it_adds_two ... ok</code>, і текст <code>ok</code> позначає, що наш тест пройшов!</p>
<p>Додамо в наш код ваду, щоб побачити, як виглядає <code>assert_eq!</code>, коли тест провалюється. Змініть реалізацію функції <code>add_two</code>, щоб натомість додавати <code>3</code>:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        assert_eq!(4, add_two(2));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Запустимо тести знову:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Наш тест виявив ваду! Тест <code>it_adds_two</code> провалився, і повідомлення каже нам про те, що провалене ствердження було <code>assertion failed: `(left == right)`</code> і значення <code>left</code> і <code>right</code>. Це повідомлення допомагає нам почати зневадження: аргумент <code>left</code> був <code>4</code>, але аргумент <code>right</code>, де стоїть <code>add_two(2)</code>, був <code>5</code>. Ви можете собі уявити, що це буде особливо корисно, коли у нас проводиться багато тестів.</p>
<p>Зверніть увагу, що в деяких мовах і тестувальних фреймворках параметри функції ствердження рівності називаються <code>expected</code> (очікувалося) і <code>actual</code> (фактично), і порядок, в якому ми вказуємо аргументи, важливий. Однак у Rust вони називаються <code>left</code> і <code>right</code>, і порядок, в якому ми вказуємо значення, яке ми очікуємо, і значення, обчислене кодом, не має значення. Ми могли б записати ствердження у цьому тесті як <code>assert_eq!(add_two(2), 4)</code>, що призведе до того ж повідомлення про помилку, яке показує <code>assertion failed: `(left == right)`</code>.</p>
<p>Макрос <code>assert_ne!</code> проходить тест, якщо два значення, які ми даємо, не дорівнюють одне одному, і провалюється, якщо вони рівні. Цей макрос найбільш корисний для випадків, коли ми не впевнені яким значення <em>буде</em>, але ми знаємо, яким значення безумовно <em>не повинне</em> бути. Наприклад, якщо ми тестуємо функцію, яка гарантовано певним чином змінює вхідні параметри, але те, як змінюється вони змінюються, залежить від дня тижня, коли ми проводимо свої тести, найкраще, що може стверджувати — що вихід функції не дорівнює вводу.</p>
<p>Під капотом макроси <code>assert_eq!</code> і <code>assert_ne!</code> використовують оператори <code>==</code> and <code>!=</code>, відповідно. Коли ствердження провалюється, ці макроси друкують свої аргументи з використанням форматування налагодження, тобто, що значення, які порівнюються, повинні реалізовувати трейти <code>PartialEq</code> і <code>Debug</code>. Всі примітивні типи та більшість типів зі стандартної бібліотеки реалізовують ці трейти. Для структур та енумів, які ви визначаєте самостійно, вам потрібно буде реалізувати <code>PartialEq</code>, щоб стверджувати рівність таких типів. Також потрібно буде реалізувати <code>Debug</code> для виведення значень, коли ствердження провалюється. Оскільки обидва ці трейти вивідні, як було зазначено в Блоці коду 5-12 у Розділі 5, зазвичай просто треба додати анотацію <code>#[derive(PartialEq, Debug)</code> до визначення вашої структури чи енуму. Дивіться Додаток C, <a href="appendix-03-derivable-traits.html">&quot;Вивідні трейти&quot;,</a><!-- ignore --> для детальнішої інформації про ці та інші вивідні трейти.</p>
<h3 id="Додавання-користувацьких-повідомлень-про-провали"><a class="header" href="#Додавання-користувацьких-повідомлень-про-провали">Додавання користувацьких повідомлень про провали</a></h3>
<p>Ви також можете додати користувальницьке повідомлення для виведення з повідомленням про помилку, як додатковий аргументи до макросів <code>assert!</code>, <code>assert_eq!</code>, і <code>assert_ne!</code>. Будь-які аргументи, вказані після необхідних аргументів, передаються до макпрсу <code>format!</code> (обговорюється у Розділі 8 у підрозділі <a href="">&quot;Конкатенація оператором <code>+</code> або макросом <code>format!</code>&quot;</a><!-- ignore -->
), тож ви можете передати стрічку форматування, що містить заповнювачі <code>{}</code> та значення для підставляння в ці заповнювачі. Користувальницькі повідомлення корисні для документування, що означає ствердження; коли тест провалюється, ви будете мати краще розуміння того, що за проблема з кодом.</p>
<p>Наприклад, припустимо, у нас є функція, яка вітає людей на ім'я, і ми хочемо перевірити, що ім'я, яке ми передаємо, з'являється у вихідній стрічці:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
</code></pre>
<p>Вимоги до цієї програми ще не були узгоджені, і ми цілком певні, що текст <code>Hello,</code> на початку вітання зміниться. Ми вирішили не оновлювати тест при змінах вимог, отже замість перевірки на точну рівність значенню, яке повернула функція <code>greeting</code>, ми просто ствердимо, що результат містить текст текст вихідного параметра.</p>
<p>Тепер введімо ваду у цей код, змінивши <code>greeting</code> s виключивши <code>name</code>, щоб побачити, як виглядає тест провалу за замовчуванням:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting(&quot;Carol&quot;);
</span><span class="boring">        assert!(result.contains(&quot;Carol&quot;));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Запуск цього тесту виводить таке:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'assertion failed: result.contains(\&quot;Carol\&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Цей результат вказує на те, що ствердження провалилося і в якому рядку. Більш корисне повідомлення про помилку може вивести значення з функції <code>greeting</code>. Додаймо власне повідомлення про помилку, складене зі стрічки форматування з заповнювачем, заповненим фактичним значенням, яке ми отримали від функції <code>greeting</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;Hello!&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(
            result.contains(&quot;Carol&quot;),
            &quot;Greeting did not contain name, value was `{}`&quot;,
            result
        );
    }
<span class="boring">}
</span></code></pre>
<p>Тепер, коли ми запустимо тест, ми отримаємо більш інформативне повідомлення про помилку:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'Greeting did not contain name, value was `Hello!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Ми можемо бачити значення, яке ми фактично отримали на виході тесту, що допоможе нам налагодити, що сталося замість того, що ми очікували.</p>
<h3 id="Перевірка-на-паніку-за-допомогою-should_panic"><a class="header" href="#Перевірка-на-паніку-за-допомогою-should_panic">Перевірка на паніку за допомогою <code>should_panic</code></a></h3>
<p>На додаток до перевірки значень, повернених з функцій, важливо перевірити, чи наш код обробляє помилкові стани, які ми очікуємо. Наприклад, розгляньте тип <code>Guess</code>, який ми створили у Блоці коду 9-13 у Розділі 9. Інший код, який використовує <code>Guess</code>, залежить від гарантії, що екземпляри <code>Guess</code> будуть містити лише значення у діапазоні від 1 до 100. Ми можемо написати тест, який гарантує, що намагання створити екземпляр <code>Guess</code> зі значенням поза інтервалом панікує.</p>
<p>Ми робимо це, додаючи атрибут <code>should_panic</code> до нашої тестової функції. Тест проходить, якщо код усередині функції панікує; тест провалюється, якщо код усередині функції не запанікував.</p>
<p>Блок коду 11-8 показує тест, який перевіряє, що умови помилки <code>Guess::new</code> стаються тоді, коли ми очікуємо на них.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre>
<p><span class="caption">Блок коду 11-8: Тестування умови, що призводить до <code>panic!</code></span></p>
<p>Ми розміщаємо атрибут <code>#[should_panic]</code> після <code>#[test]</code> перед тестовою функцією, до якої він застосовується. Подивімося на результат, коли цей тест проходить:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Здається, усе гаразд! Тепер додамо ваду у наш код, видаливши умову, що функція <code>new</code> запанікує, якщо значення більше за 100:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Коли ми запустимо тест з Блоку коду 11-8, він провалюється:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>В цьому випадку ми отримуємо не дуже помічне повідомлення, але коли подивитися на тестову функцію, то бачимо, що вона анотована <code>#[should_panic]</code>. Отриманий провал означає, що код у тестовій функції не призвів до паніки.</p>
<p>Тести, що використовують <code>should_panic</code>, можуть бути неточними. Тест із <code>should_panic</code> пройде, навіть якщо тест запанікує з іншої причини, а не очікуваної. Щоб зробити тести із <code>should_panic</code> більш точними, ми можемо додати необов'язковий параметр <code>expected</code> до атрибута <code>should_panic</code>. Тестова оболонка забезпечить, щоб повідомлення про провал містило наданий текст. Наприклад, розгляньте модифікований код <code>Guess</code> у Блоці коду 11-9, де функція <code>new</code> панікує з різними повідомленнями залежно від того, значення занадто мале або занадто велике.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                &quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                &quot;Guess value must be less than or equal to 100, got {}.&quot;,
                value
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre>
<p><span class="caption">Блок коду 11-9: тестування <code>panic!</code> з повідомленням паніки, що містить зазначену підстрічку</span></p>
<p>Цей тест пройде, оскільки значення, яке ми додали в параметр <code>expected</code> атрибуту <code>should_panic</code> є підстрічкою повідомлення, з яким панікує функція <code>Guess::new</code>. Ми могли б вказати повне повідомлення паніки, яке очікуємо, яке у цьому випадку буде <code>Guess value must be less than or equal to 100, got 200.</code> Те, що саме ви зазначите, залежить від того, яка частина повідомлення паніки є унікальною чи динамічним і наскільки точним тест ви хочете зробити. У цьому випадку підстрічки повідомлення паніки достатньо, щоб переконатися, що код у тестовій функції обробляє випадок <code>else if value &gt; 100</code>.</p>
<p>Щоб побачити, що трапиться, якщо тест <code>should_panic</code> з повідомленням <code>expected</code> провалюється, знову додамо ваду у наш код, обмінявши тіла блоків <code>if value &lt; 1</code> та <code>else if value &gt; 100</code>:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                &quot;Guess value must be less than or equal to 100, got {}.&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                &quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                value
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;less than or equal to 100&quot;)]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Цього разу, коли ми запускаємо тест <code>should_panic</code>, він провалиться:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'main' panicked at 'Guess value must be greater than or equal to 1, got 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `&quot;Guess value must be greater than or equal to 1, got 200.&quot;`,
 expected substring: `&quot;less than or equal to 100&quot;`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Повідомлення про провал вказує на те, що цей тест дійсно панікував, як ми очікували, але повідомлення про паніку не містить очікувану стрічку <code>'Guess value must be less than or equal to 100'</code>. Повідомлення про паніку, яке ми взяли, в цьому випадку було <code>Guess value must be greater than or equal to 1, got 200.</code> Тепер ми можемо почати з'ясуоввати, де знаходиться наша помилка!</p>
<h3 id="Використання-resultt-e-у-тестах"><a class="header" href="#Використання-resultt-e-у-тестах">Використання <code>Result&lt;T, E&gt;</code> у тестах</a></h3>
<p>Всі наші тести поки що панікують, коли провалюються. Ми також можемо написати тести, які використовують <code>Result&lt;T, E&gt;</code>! Ось тест зі Блоку коду 11-1, переписаний для використання <code>Result&lt;T, E&gt;</code>, який повертає <code>Err</code> замість паніки:</p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;two plus two does not equal four&quot;))
        }
    }
}
</code></pre>
<p>Функція <code>it_works</code> зараз повертає тип <code>Result&lt;(), String&gt;</code>. У тілі функції, замість того, щоб викликати макрос <code>assert_eq!</code>, ми повертаємо <code>Ok(())</code>, коли тест пройшов і <code>Err</code> зі <code>String</code> всередині, коли тест провалено.</p>
<p>Написання тестів, щоб вони повертали <code>Result&lt;T, E&gt;</code>, дозволить вам використовувати оператор знак питання у тілі тестів, що може бути зручним способом писати тести, що мають провалитися, якщо будь-яка операція всередині них повертає варіант <code>Err</code>.</p>
<p>Ви не можете використовувати анотацію <code>#[should_panic]</code> в тестах, які використовують <code>Result&lt;T, E&gt;</code>. Щоб ствердити, що операція повертає варіант <code>Err</code>, <em>не</em> використовуйте оператор знак питання значенні на <code>Result&lt;T, E&gt;</code>. Натомість, використовуйте <code>assert!(value.is_err())</code>.</p>
<p>Тепер, коли ви знаєте кілька способів писати тести, подивімося на те, що відбувається, коли ми запускаємо наші тести і дослідимо різні опції, як ми можемо використовувати з <code>cargo test</code>.
ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro ch11-02-running-tests.html#controlling-how-tests-are-run</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Контроль-над-запуском-тестів"><a class="header" href="#Контроль-над-запуском-тестів">Контроль над запуском тестів</a></h2>
<p>Так само як <code>cargo run</code> компілює ваш код і запускає утворений виконуваний файл, <code>cargo test</code> компілює ваш код у режимі тестів і запускає утворений тестовий виконуваний файл. За замовчанням виконуваний файл, згенерований <code>cargo test</code>, запускає всі тести паралельно і перехоплює вивід, згенерований під час виконання тестів, запобігаючи виведенню на екран і спрощуючи читання виведення, яке стосується результатів тестів. Однак ви можете вказати опції командного рядка, щоб змінити таку поведінку за замовчанням.</p>
<p>Деякі опції командного рядка стосуються <code>cargo test</code>, а деякі - вихідного тестового виконуваного файла. Щоб розділити ці два типи аргументів, треба вказати аргументи, що стосуються <code>cargo test</code>, далі розділювач <code>--</code>, а потім ті, що стосуються тестового виконуваного файлу. Запуск <code>cargo test --help</code> покаже опції, що можна використовувати з <code>cargo test</code>, а запуск <code>cargo test -- --help</code> покаже опції, що можна вказувати після розділювача.</p>
<h3 id="Запуск-тестів-паралельно-чи-послідовно"><a class="header" href="#Запуск-тестів-паралельно-чи-послідовно">Запуск тестів паралельно чи послідовно</a></h3>
<p>Коли ви запускаєте декілька тестів, за замовчуванням вони запускаються паралельно у кількох потоках, тобто вони закінчують роботу швидше і ви скоріше отримуєте зворотний зв'язок. Оскільки тести виконуються одночасно, ви повинні переконатися, що ваші тести не залежать один від одного або від будь-якого спільного стану, включно зі спільним середовищем, наприклад поточною робочою текою чи змінною середовища.</p>
<p>Наприклад, нехай кожен з ваших тестів запускає певний код, що створює файл на диску з назвою <em>test-output.txt</em> і записує якісь дані в цей файл. Потім кожен тест зчитує дані з цього файлу та перевіряє, що файл містить певне значення, яке різниться в кожному тесті. Оскільки тести виконуються одночасно, один тест може перезаписати файл у час між тим, коли інший тест пише і читає цей файл. Другий тест тоді провалиться - не тому, що код неправильний, але тому, що тести втручалися в роботу один одного під час паралельної роботи. Одне можливе рішення - переконатися, що кожен тест пише в окремий файл; інше рішення - запускати тести по одному за раз.</p>
<p>Якщо ви не хочете запускати тести паралельно, або якщо хочете мати більш докладний контроль над кількістю потоків, ви можете встановити прапорець <code>--test-threads</code> і кількість потоків, які Ви хочете використовувати для тестування. Погляньте на наступний приклад:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>Ми встановили кількість потоків тестів на значення <code>1</code>, які повідомляють програмі не використовувати паралелізм. Виконання тестів за допомогою одного потоку займе більше часу, ніж запуск їх паралельно, але тести не будуть втручатися один одного, якщо вони мають спільний стан.</p>
<h3 id="Показування-виведення-функції"><a class="header" href="#Показування-виведення-функції">Показування виведення функції</a></h3>
<p>За замовчуванням, якщо тест проходить вдало, бібліотека тестування Rust перехоплює все, що виводиться у стандартний вихідний потік. Наприклад, якщо ми викличемо <code>println!</code> у тесті й тест проходить, ми не побачимо виведення з <code>println!</code> терміналі; ми побачимо тільки рядок, який каже, що тест пройдено. Якщо тест провалено, ми побачимо все, що було виведено до стандартного потоку виведення з рештою повідомлення про помилку.</p>
<p>Як приклад, Блок коду 11-10 має простеньку функцію, яка друкує значення свого параметра і повертає 10, а також і тест, що проходить і тест, що провалюється.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;I got the value {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
</code></pre>
<p><span class="caption">Блок коду 11-10: Тести для функції, що викликає <code>println!</code></span></p>
<p>Коли ми запустимо ці тести за допомогою <code>cargo test</code>, то побачимо таке:</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Зверніть увагу, що у виведеному ніде немає <code>I got the value 4</code> - того, що виводиться в тесті, що проходить. Це виведення було перехоплено. Виведення з тесту, що провалився, <code>I got the value 8</code>, з'являється в розділі підсумків тесту, де також показана і причина провалу тесту.</p>
<p>Якщо ми хочемо вивести значення і для тестів, що пройшли, ми можемо сказати Rust також показати виведення з успішних тестів за допомогою <code>--show-output</code>.</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>Коли ми запустимо тести з Блоку коду 11-10 знову, вказавши прапорець <code>--show-output</code>, то побачимо таке:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<h3 id="Запуск-підмножини-тестів-по-імені"><a class="header" href="#Запуск-підмножини-тестів-по-імені">Запуск підмножини тестів по імені</a></h3>
<p>Іноді виконання повного набору тестів може тривати довго. Якщо ви працюєте над кодом у певній області, то можете захотіти запускати лише тести, що містять цей код. Ви можете обирати, які тести виконати, передавши <code>cargo test</code> ім'я чи імена тесту(ів), які хочете запустити, як аргумент.</p>
<p>Щоб продемонструвати, як запустити частину тестів, ми спершу створимо три тести для нашої функції <code>add_two</code>, як показано у Блоці коду 11-11, і оберемо, які з них запустити.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
</code></pre>
<p><span class="caption">Блок коду 11-11: Три тести з різними іменами</span></p>
<p>Якщо ми запустимо тести, не передавши жодних аргументів, то, як ми бачили раніше, всі тести запустяться паралельно:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h4 id="Запуск-одного-тесту"><a class="header" href="#Запуск-одного-тесту">Запуск одного тесту</a></h4>
<p>Ми можемо передати назву будь-якої тестової функції <code>cargo test</code>, щоб запустити тільки цей тест:</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<p>Лише тест з ім'ям <code>one_hundred</code> було виконано; інші два тести мають невідповідні імена. Вивід тесту дає нам знати, що ми мали більше тестів, що не були запущені, показавши наприкінці <code>2 filtered out</code>.</p>
<p>Ми не можемо таким чином вказувати імена кількох тестів; буде використане лише перше значення, передане <code>cargo test</code>. Але є спосіб запустити кілька тестів.</p>
<h4 id="Фільтрування-для-запуску-кількох-тестів"><a class="header" href="#Фільтрування-для-запуску-кількох-тестів">Фільтрування для запуску кількох тестів</a></h4>
<p>Ми можемо вказати частину назви тесту, і всі тести, чиї імена відповідають цьому значенню, будуть запущені. Наприклад, оскільки дві назви наших тестів містять <code>add</code>, ми можемо виконати ці два тести, запустивши <code>cargo test add</code>:</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
<p>Ця команда виконала всі тести, що містили <code>add</code> у назві й відфільтрувала тест з назвою <code>one_hundred</code>. Також зверніть увагу, що модуль, в якому з'являється тест, перетворюється на частину імені тесту, тож ми можемо запустити усі тести в модулі, відфільтрувавши тести за ім’ям модуля.</p>
<h3 id="Ігнорування-деяких-тестів-якщо-не-було-спеціального-запиту"><a class="header" href="#Ігнорування-деяких-тестів-якщо-не-було-спеціального-запиту">Ігнорування деяких тестів, якщо не було спеціального запиту</a></h3>
<p>Іноді кілька специфічних тестів можуть витрачати дуже багато часу для виконання, так що ви можете захотіти виключити їх під час більшості запусків <code>cargo test</code>. Замість того, щоб перелічувати всі тести, які ви хочете запустити, як аргументи, ви можете натомість додати анотацію трудомістких тестів, додавши атрибут <code>ignore</code>, щоб виключити їх, як показано тут:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
</code></pre>
<p>Після <code>#[test]</code> ми додаємо рядок <code>#[ignore]</code> до тесту, що його ми хочемо виключити. Тепер, коли ми запускаємо наші тести, <code>it_works</code> запускається, а <code>expensive_test</code> - ні:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Функція <code>expensive_test</code> показана як <code>ignored</code>. Якби ми захотіли запустити лише ігноровані тести, то могли б запустити <code>cargo test -- --ignored</code>:</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Контролюючи, які тести запустити, ви можете забезпечити швидкість результатів <code>cargo test</code>. Коли ви дістанетеся до етапу, коли матиме сенс перевірити результати тестів <code>ignored</code> і матимете час дочекатися результатів, то зможете натомість запустити <code>cargo test -- --ignored</code>. Якщо ви хочете запустити усі тести, ігноровані чи ні, то можете запустити <code>cargo test -- --include-ignored</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Організація-тестів"><a class="header" href="#Організація-тестів">Організація тестів</a></h2>
<p>Як зазначено на початку розділу, тестування є складною дисципліною, і різні люди використовують різну термінологію та організацію. Спільнота Rust думає про тести з точки зору двох основних категорій: модульні тести та інтеграційні тести. <em>Модульні тести</em> є невеликими та більш сфокусованими, ізольовано тестують один модуль за один раз, і можуть тестувати приватні інтерфейси. <em>Інтеграційні тести</em> є повністю зовнішніми до вашої бібліотеки та використовують ваш код так само як будь-який інший зовнішній код, використовуючи тільки публічний інтерфейс і потенційно випробовуючи багато модулів під час тесту.</p>
<p>Написання обох типів тестів є важливим, щоб переконатися, що частини вашої бібліотеки роблять те, на що ви очікували від них, окремо і разом.</p>
<h3 id="Модульні-тести"><a class="header" href="#Модульні-тести">Модульні тести</a></h3>
<p>Мета модульних тестів — перевірити кожну одиницю коду ізольованою від решти коду, щоб швидко визначити точку, де код не працює як очікувалося. Модульні тести розташовуються в теці <em>src</em> в кожному файлі коду, який вони тестують. За домовленістю, у кожному файлі, що містить функції для тестування, створюється модуль з назвою <code>tests</code>, анотований <code>cfg(test)</code>.</p>
<h4 id="Модуль-tests-і-cfgtest"><a class="header" href="#Модуль-tests-і-cfgtest">Модуль tests і <code>#[cfg(test)]</code></a></h4>
<p>Анотація модуля tests <code>#[cfg(test)]</code> каже Rust компілювати і виконувати тестовий код лише коли ви запускаєте <code>cargo test</code>, а не <code>cargo build</code>. Це зберігає час компіляції, коли ви хочете зібрати бібліотеку, і зберігає місце у отриманому скомпільованому артефакті, бо тести не до нього не включені. Як ви побачите, оскільки інтеграційні тести розміщуються в іншій теці, вони не потребують анотації <code>#[cfg(test)]</code>. Однак, оскільки модульні тести розміщуються у тих самих файлах, що й код, вам треба вказувати <code>#[cfg(test)]</code>, щоб позначити, що їх не треба включати у результат компіляції.</p>
<p>Згадайте, що коли ми створили новий проєкт <code>adder</code> у першому підрозділу цього розділу, Cargo згенерував для нас цей код:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
</code></pre>
<p>Цей код є автоматично згенерованим модульним тестом. Атрибут <code>cfg</code> означає <em>конфігурація</em> і каже Rust, що наступний елемент має включатися лише з певною опцією конфігурації. У цьому випадку опцією конфігурації є <code>test</code>, що надається Rust для компіляції і запуску тестів. Використовуючи атрибут <code>cfg</code>, ми вказуємо Cargo компілювати наш тестовий код лише коли ми явно запускаємо тести за допомогою <code>cargo test</code>. Це стосується і будь-яких допоміжних функцій, що можуть бути в цьому модулі, на додачу до функцій, анотованих <code>#[test]</code>.</p>
<h4 id="Тестування-приватних-функцій"><a class="header" href="#Тестування-приватних-функцій">Тестування приватних функцій</a></h4>
<p>У тестовій спільноті є дискусія про те, чи мають приватні функції тестуватися безпосередньо, і інші мови ускладнюють або унеможливлюють тестування приватних функцій. Незалежно від того, якої тестової ідеології ви дотримуєтеся, правила приватності Rust дозволяють вам тестувати приватні функції. Розгляньте код у Блоці коду 11-12 з приватною функцією <code>internal_adder</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
</code></pre>
<p><span class="caption">Блок коду 11-12: тестування приватної функції</span></p>
<p>Зверніть увагу, що функція <code>internal_adder</code> не позначена як <code>pub</code>. Тести - це просто код Rust, а модуль <code>tests</code> - це просто ще один модуль. Як ми вже говорили в підрозділі <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Способи звернутися до елементу в дереві модулів”</a><!-- ignore -->
, елементи дочірніх модулів можуть використовувати елементи своїх батьківських модулів. У цьому тесті, ми вводимо всі елементи батьківського для <code>test</code> модуля в область видимості за допомогою <code>use super::*</code>, і тоді тест може викликати <code>internal_adder</code>. Якщо ви не вважаєте, що приватні функції мають бути протестовані, немає нічого в Rust, що змусить вас це робити.</p>
<h3 id="Інтеграційні-тести"><a class="header" href="#Інтеграційні-тести">Інтеграційні тести</a></h3>
<p>У Rust, інтеграційні тести є цілковито зовнішніми відносно до вашої бібліотеки. Вони використовують вашу бібліотеку так само як це робив би будь-який інший код, що означає, що вони можуть викликати лише функції, які є частиною публічного API вашої бібліотеки. Їхнє призначення - перевірити, чи правильно різні частини вашої бібліотеки працюють разом. Фрагменти коду, які правильно самі по собі працюють, можуть мати проблеми при інтеграції, тому покриття інтегрованого коду тестами також важливе. Для створення інтеграційних тестів вам знадобиться для початку тека <em>tests</em>.</p>
<h4 id="Тека-tests"><a class="header" href="#Тека-tests">Тека <em>tests</em></a></h4>
<p>Ми створимо теку <em>tests</em> на верхньому рівні тек нашого проєкту, поруч із <em>src</em>. Cargo знає, що файли інтеграційних тестів треба шукати в цій теці. Ми можемо зробити стільки тестових файлів, скільки захочемо, і Cargo скомпілює кожен з файлів як окремий крейт.</p>
<p>Створімо інтеграційний тест. Поки у файлі <em>src/lib.rs</em> все ще код з Блоку коду 11-12, створіть теку <em>tests</em>, а в ній - новий файл, з назвою <em>tests/integration_test.rs</em>. Структура вашої теки має виглядати ось так:</p>
<pre><code class="language-text">adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
        └── integration_test.rs
</code></pre>
<p>Введіть код з Блоку коду 11-13 у файл <em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Файл: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><span class="caption">Блок коду 11-13: інтеграційний тест функції з крейту <code>adder</code></span></p>
<p>Кожен файл у теці <code>tests</code> є окремим крейтом, тож нам потрібно ввести нашу бібліотеку до області видимості кожного тестового крейту. Саме тому ми додаємо <code>use adder</code> на початку коду, чого не робили в модульних тестах.</p>
<p>Нам не треба додавати до коду у <em>tests/integration_test.rs</em> анотацію <code>#[cfg(test)]</code>. Cargo розглядає теку <code>tests</code> окремо і компілює файли у цій теці лише коли ми запускаємо <code>cargo test</code>. Запустімо зараз <code>cargo test</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Три секції виводу містять модульні тести, інтеграційні тести та документаційні тести. Зверніть увагу, що якщо будь-який тест у секції провалиться, наступна секція не буде запущена. Наприклад, якщо провалиться модульний тест, для інтеграційних і документаційних тестів не буде виведено нічого, бо ці тести будуть запущені лише якщо всі модульні тести пройдуть.</p>
<p>Перша секція для модульних тестів така сама, яку ми вже бачили: по рядку для кожного модульного тесту (один, що зветься <code>internal</code>, який ми додали у Блоці коду 11-12) і далі рядок підсумку для модульних тестів.</p>
<p>Секція інтеграційних тестів починається рядком <code>Running tests/integration_test.rs</code>. Далі по рядку для кожної тестової функції у інтеграційному тесті і рядок підсумку для результатів інтеграційних тестів прямо перед початком секції <code>Doc-tests adder</code>.</p>
<p>Кожен файл інтеграційного тесту має свою власну секцію, тому якщо ми додамо більше файлів до теки <em>tests</em>, буде більше секцій інтеграційних тестів.</p>
<p>Ми все ще можемо запустити певну функцію інтеграційного тесту, вказавши назву тестової функції як аргумент до <code>cargo test</code>. Щоб запустити всі тести з певного файлу інтеграційних тестів, вкажіть <code>cargo test</code> аргумент <code>--test</code> із назвою файлу:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Ця команда виконає лише тести у файлі <em>tests/integration_test.rs</em>.</p>
<h4 id="Підмодулі-у-інтеграційних-тестах"><a class="header" href="#Підмодулі-у-інтеграційних-тестах">Підмодулі у інтеграційних тестах</a></h4>
<p>При додаванні інтеграційних тестів для кращої організації ви можете захотіти створити більше файлів у теці <em>tests</em>; наприклад, ви можете згрупувати тестові функції за функціоналом, який вони тестують. Як згадувалося раніше, кожен файл у теці <em>tests</em> компілюється як окремий крейт, що є корисним для створення окремих областей видимості для більш ретельного наслідування того, як кінцеві користувачі будуть використовуючи ваш крейт. Проте це означає, що файли в теці <em>tests</em> не виявляють таку ж поведінку як файли у <em>src</em>, як ви дізналися в Розділі 7 щодо того, як відокремити код в модулі та файли.</p>
<p>Відмінна поведінка каталогу <em>tests</em> є найбільш помітною, коли ви маєте набір допоміжних функцій, які використовуються в декількох файлах інтеграційних тестів і ви намагаєтесь слідувати крокам з підрозділу <a href="">&quot;Розподіл модулів на різні файли&quot;</a><!-- ignore --> Розділу 7, щоб винести їх у спільний модуль. Наприклад, якщо ми створимо <em>tests/common.rs</em> і розмістимо там функцію з назвою <code>setup</code>, ми можемо додати в цю функцію код, що ми хочемо викликати з декількох тестових функцій у декількох тестових файлах:</p>
<p><span class="filename">Файл: src/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // setup code specific to your library's tests would go here
}
</code></pre>
<p>Коли ми знову запустимо тести, то побачимо нову секцію у виведенні тестів для файлу <em>common.rs</em>, хоча цей файл не містить жодних тестових функцій і ми нізвідки не викликали функцію <code>setup</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Побачити <code>common</code> серед результатів тестів з уточненням <code>running 0 tests</code> - ми не цього хотіли. Ми хотіли лише мати код, спільний для кількох файлів інтеграційних тестів.</p>
<p>Щоб <code>common</code> не з'являвся в результатах тестів, замість створення <em>tests/common.rs</em> ми створимо <em>tests/common/mod.rs</em>. Тека проєкту тепер виглядає так:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── src
│    └── lib.rs
└── tests
     ├── common
     │    └── mod.rs
     └── integration_test.rs
</code></pre>
<p>Це давніше правило іменування, яке Rust також розуміє, про яке ми згадували у підрозділі <a href="ch07-05-separating-modules-into-different-files.html#alternate-file-paths">&quot;Альтернативні шляхи файлів&quot;</a><!-- ignore --> Розділу 7. Те, що файл названо у цей спосіб, каже Rust не розглядати модуль <code>common</code> як файл інтеграційного тесту. Коли ми перемістимо код функції <code>setup</code> до <em>tests/common/mod.rs</em> і видалимо файл <em>tests/common.rs</em>, секція для цього файлу більше не показуватиметься. Файли в підтеках теки <em>tests</em> не компілюються як окремі крейти і не мають секції в виведенні тестів.</p>
<p>Після того, як ми створили <em>tests/common/mod.rs</em>, ми можемо використовувати його з будь-якого з тестових файлів як модуль. Ось приклад виклику функції <code>setup</code> з тесту <code>it_adds_two</code> в <em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Файл: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>Зверніть увагу, що проголошення <code>mod common;</code> - те саме, що й проголошення модуля, продемонстроване в Блоці коду 7-21. Тоді з тестової функції ми можемо викликати функцію <code>common::setup()</code>.</p>
<h4 id="Інтеграційні-тести-для-двійкових-крейтів"><a class="header" href="#Інтеграційні-тести-для-двійкових-крейтів">Інтеграційні тести для двійкових крейтів</a></h4>
<p>Якщо наш проєкт є двійковим крейтом, що містить лише файл <em>src/main.rs</em> і не має файлу <em>src/lib.rs</em>, ми не можемо створювати інтеграційні тести у теці <em>tests</em> і вводити в область видимості функції, визначені у файлі <em>src/main.rs</em>, за допомогою інструкції <code>use</code>. Лише бібліотечні крейти надають функції для використання в інших крейтах; двійкові крейти призначені лише для запуску.</p>
<p>Це - одна з причин, чому проєкти Rust, що створюють двійковий файл, мають простий файл <em>src/main.rs</em>, що викликає логіку з файлу <em>src/lib.rs</em>. За такої структури інтеграційні тести <em>можуть</em> тестувати бібліотечний крейт, використовуючи <code>use</code>, щоб дістатися до важливого функціоналу. Якщо важливий функціонал працює, невеликий код у файлі <em>src/main.rs</em> також працюватиме, і цей невеликий код не треба тестувати.</p>
<h2 id="Підсумок-10"><a class="header" href="#Підсумок-10">Підсумок</a></h2>
<p>Можливості тестування Rust надають можливість вказати, як код має працювати, щоб переконатися, що він і надалі працює як очікувалося, навіть якщо ви його зміните. Модульні тести випробовують різні частини бібліотеки окремо і можуть тестувати приватні деталі реалізації. Інтеграційні тести перевіряють, що різні частини бібліотеки коректно працюють разом, і вони використовують публічний API бібліотеки для тестування коду, так само, як це робитиме сторонній код. Попри те, що система типів Rust і правила власності допомагають уникнути деяких видів помилок, тести все одно є важливими для зменшення логічних помилок, які стосуються очікуваної поведінки вашого коду.</p>
<p>Застосуймо усі знання, отримані в цьому та попередніх розділах, щоб попрацювати над проєктом!
ch07-05-separating-modules-into-different-files.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Проєкт-з-введеннямвиведенням-створення-програми-командного-рядка"><a class="header" href="#Проєкт-з-введеннямвиведенням-створення-програми-командного-рядка">Проєкт з введенням/виведенням: створення програми командного рядка</a></h1>
<p>Цей розділ підсумовує багато навичок, які ви отримали досі, та досліджує ще декілька можливостей стандартної бібліотеки. Ми розробимо інструмент командного рядка, що взаємодіятиме введенням/виведенням до файлів і командного рядка, щоб потренуватися з уже вивченими концепціями Rust.</p>
<p>Швидкість, безпека, єдиний двійковий файл як результат компіляції та підтримка багатоплатформеності роблять Rust ідеальною мовою для створення інструментів командного рядка, отже, для нашого проєкту ми створимо власну версію класичного інструменту для пошуку через командний рядок <code>grep</code> (<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint, глобальний пошук регулярного виразу і виведення). У найпростішому випадку <code>grep</code> шукає вказану стрічку у вказаному файлі. Для цього <code>grep</code> приймає параметрами шлях до файлу і стрічку,  а далі читає файл, знаходить рядки що містять параметр-стрічку і друкує ці рядки.</p>
<p>Дорогою ми покажемо як залучити до нашого інструмента командного рядка поширені функції термінала, які використовуються в багатьох інших інструментах командного рядка. Ми прочитаємо значення змінної середовища, щоб дозволити користувачеві сконфігурувати поведінку нашого інструменту. Також ми виведемо повідомлення про помилки до стандартного потоку виведення помилок (<code>stderr</code>), а замість стандартного потоку виведення (<code>stdout</code>), щоб, скажімо, користувач міг перенаправити вдалий результат до файлу і все ж побачив повідомлення про помилки на екрані.</p>
<p>Один з членів спільноти Rust, Andrew Gallant, вже створив повнофункціональну, дуже швидку версію <code>grep</code>, що зветься <code>ripgrep</code>. Наша версія, як порівняти, буде доволі простою, але цей розділ дасть вам певні початкові знання, що знадобляться для розуміння реальних проєктів як-от <code>ripgrep</code>.</p>
<p>Наш проєкт <code>grep</code> об'єднає низку концепцій, що ви вже вивчили:</p>
<ul>
<li>Організація коду (застосування того, що ви вже вивчили про модулі у <a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Розділі 7</a><!--
  ignore -->)</li>
<li>Використання векторів та стрічок (колекцій, <a href="ch08-00-common-collections.html">Розділ 8</a><!-- ignore -->)</li>
<li>Обробка помилок (<a href="ch09-00-error-handling.html">Розділ 9</a><!-- ignore -->)</li>
<li>Використання трейтів і часів життя, де це потрібно (<a href="ch10-00-generics.html">Розділ 10</a><!-- ignore
  -->)</li>
<li>Написання тестів (<a href="ch11-00-testing.html">Розділ 11</a><!-- ignore -->)</li>
</ul>
<p>Ми також коротко представимо замикання, ітератори і трейтові об'єкти, про які детальніше йтиметься в розділах <a href="ch13-00-functional-features.html">13</a><!-- ignore --> і <a href="ch17-00-oop.html">17</a><!-- ignore --> .</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Приймання-аргументів-командного-рядка"><a class="header" href="#Приймання-аргументів-командного-рядка">Приймання аргументів командного рядка</a></h2>
<p>Створімо новий проєкт за допомогою, як завжди, <code>cargo new</code>. Ми назвемо наш проєкт <code>minigrep</code>, щоб вирізнити його від інструменту <code>grep</code>, що вже може бути встановлено у вашій системі.</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>Перше завдання - зробити, щоб <code>minigrep</code> приймав два аргументи командного рядка: шлях до файлу і стрічку для пошуку. Тобто ми хочемо, щоб нашу програму можна було запускати за допомогою <code>cargo run</code>, двох рисок на позначення що подальші аргументи стосуються нашої програми, а не <code>cargo</code>, стрічки для пошуку і шляху до файлу, в якому треба шукати, ось так:</p>
<pre><code class="language-console">$ cargo run -- searchstring example-filename.txt
</code></pre>
<p>Наразі програма, створена <code>cargo new</code>, не може обробляти аргументи, передані їй. Певні бібліотеки з <a href="https://crates.io/">crates.io</a> можуть допомогти писати програму, що приймає аргументи командного рядка, але оскільки ви лише вивчаєте цю концепцію, запровадимо цю можливість самостійно.</p>
<h3 id="Читання-значень-параметрів"><a class="header" href="#Читання-значень-параметрів">Читання значень параметрів</a></h3>
<p>Щоб дозволити <code>minigrep</code> читати значення аргументів командного рядка, переданих йому, нам знадобиться функція <code>std::env::args</code> зі стандартної бібліотеки Rust. Ця функція поверне ітератор аргументів командного рядка, переданих <code>minigrep</code>. Повніше про ітератори піде у <a href="ch13-00-functional-features.html">Розділі 13</a><!-- ignore
-->. Поки що вам лише треба знати про ітератори дві речі: ітератори створюють послідовність значень, і ми можемо викликати метод </p>
<p><code>collect</code> для ітератора, щоб перетворити його на колекцію, таку як вектор, що міститиме всі елементи, створені ітератором.</p>
<p><code>collect</code> method on an iterator to turn it into a collection, such as a vector, that contains all the elements the iterator produces.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    dbg!(args);
}
</code></pre></pre>
<p><span class="caption">Listing 12-1: Collecting the command line arguments into a vector and printing them</span></p>
<p>Спершу ми вводимо модуль <code>std::env</code> до області видимості за допомогою інструкції <code>use</code>, щоб можна було скористатися функцію <code>args</code> з цього модуля. Зверніть увагу, що функція <code>std::env::args</code> вкладена у два рівні модулів. Як ми вже говорили у <a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths">Розділі 7</a><!-- ignore -->, у випадках, коли потрібна функція, вкладена глибше одного модуля, краще ввести в область видимості її батьківський модуль, аніж саму функцію. Таким чином, ми зможемо легко використовувати інші функції з <code>std::env</code>. Також це дещо менш двозначне, ніж додавання <code>use std::env::args</code> і виклик функції як просто <code>args</code>, бо просто <code>args</code> можна легко переплутати з функцією, визначеною в поточному модулі.</p>
<blockquote>
<h3 id="Функція-args-і-некоректний-юнікод"><a class="header" href="#Функція-args-і-некоректний-юнікод">Функція <code>args</code> і некоректний юнікод</a></h3>
<p>Зверніть увагу, що <code>std::env::args</code> запанікує, якщо якийсь із аргументів містить некоректний юнікод. Якщо вашій програмі треба приймати аргументи з некоректним юнікодом, скористайтеся натомість функцією <code>std::env::args_os</code>. Вона повертає ітератор, що створює значення <code>OsString</code> замість <code>String</code>. Ми вирішили скористатися <code>std::env::args</code> для простоти, бо значення <code>OsString</code> різняться між платформами і з ними складніше працювати, ніж зі <code>String</code>.</p>
</blockquote>
<p>У першому рядку <code>main</code> ми викликаємо <code>env::args</code> і одразу ж використовуємо <code>collect</code>, щоб перетворити ітератор на вектор, що містить усі значення, вироблені ітератором. Ми можемо використати функцію <code>collect</code>, щоб створити багато видів колекцій, тому явно позначаємо тип <code>args</code>, щоб вказати, що нам потрібен вектор стрічок. Хоча в Rust дуже нечасто треба позначати типи, <code>collect</code> є однією з функцій, яка часто потребує анотацій, бо Rust неспроможний вивести потрібний тип колекції.</p>
<p>В кінці ми виводимо вектор за допомогою макросу для зневаджування. Спробуймо тепер запустити код спершу без аргументів, а тоді з двома аргументами:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5] args = [
    &quot;target/debug/minigrep&quot;,
]
</code></pre>
<pre><code class="language-console">$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5] args = [
    &quot;target/debug/minigrep&quot;,
    &quot;needle&quot;,
    &quot;haystack&quot;,
]
</code></pre>
<p>Зверніть увагу, що перше значення у векторі - <code>&quot;target/debug/minigrep&quot;</code>, тобто назва нашого двійкового файлу. Це відповідає поведінці списку параметрів у C, що дозволяє програмам використовувати ім'я, за яким їх викликано, під час виконання. Часто буває зручно мати доступ до імені програми, якщо ви хочете вивести його у повідомленнях чи змінити поведінку програми залежно від того, який псевдонім був використаний у командному рядку для запуску програми. Але задля потреб нашого розділу ми пропустимо його і збережемо лише два потрібні параметри.</p>
<h3 id="Збереження-значень-параметрів-у-змінних"><a class="header" href="#Збереження-значень-параметрів-у-змінних">Збереження значень параметрів у змінних</a></h3>
<p>Програма вже може отримати значення, задані аргументами командного рядка. Тепер нам треба зберегти значення двох аргументів у змінних, щоб можна було використати ці значення далі в програмі. Це ми робимо у Блоці коду 12-2.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let file_path = &amp;args[2];

    println!(&quot;Searching for {}&quot;, query);
    println!(&quot;In file {}&quot;, file_path);
}
</code></pre>
<p><span class="caption">Listing 12-2: Creating variables to hold the query argument and file path argument</span></p>
<p>Як ми бачили, коли виводили вектор, ім'я програми займає перше значення у векторі за індексом <code>args[0]</code>, тому ми починаємо аргументи з індексу <code>1</code>. Перший аргумент, що приймає <code>minigrep</code> - це шукана стрічка, тож ми розміщуємо посилання на перший аргумент у змінній <code>query</code>. Другий аргумент буде шляхом до файлу, тож ми розміщуємо посилання на другий аргумент у змінній <code>file_path</code>.</p>
<p>Ми тимчасово виводимо значення цих змінних, щоб підтвердити, що код працює, як ми очікували. Запустімо цю програму знову з аргументами <code>test</code> і <code>sample.txt</code>:</p>
<pre><code class="language-console">$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Чудово, програма працює! Значення потрібних нам аргументів зберігаються у правильних змінних. Пізніше ми додамо трохи обробки помилок, щоб розібратися з певними потенційними помилковими ситуаціями, на кшталт коли користувач не надає жодних параметрів; а поки що ігноруватимемо цю ситуацію і натомість займемося додаванням можливостей для читання файлів.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Читання-файлу"><a class="header" href="#Читання-файлу">Читання файлу</a></h2>
<p>Тепер додамо функціональність для читання файлу, заданого параметром <code>file_path</code>. Для початку нам знадобиться файл для тестування, і ми скористаємося файлом із невеликим текстом у кілька рядків із повторенням слів. Блок коду 12-3 містить вірш Емілі Дікінсон, що добре підійде для цього! Створіть файл <em>poem.txt</em> у кореневому рівні вашого проєкту, і введіть вірш &quot;Я ніхто! А ти хто?&quot;</p>
<p><span class="filename">Файл: poem.txt</span></p>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Listing 12-3: A poem by Emily Dickinson makes a good test case</span></p>
<p>Підготувавши текст, відредагуйте <em>src/main.rs</em> і додайте код для читання файлу, як вказано у Блоці коду 12-4.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use std::env;
use std::fs;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let file_path = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, query);
</span>    println!(&quot;In file {}&quot;, file_path);

    let contents = fs::read_to_string(file_path)
        .expect(&quot;Should have been able to read the file&quot;);

    println!(&quot;With text:\n{contents}&quot;);
}
</code></pre>
<p><span class="caption">Блок коду 12-4: Читання вмісту файлу, вказаного другим параметром</span></p>
<p>Спершу, ми вводимо в область видимості відповідну частину стандартної бібліотеки за допомогою інструкції <code>use</code>: для обробки файлів потрібен <code>std::fs</code>.</p>
<p>У <code>main</code> нова інструкція <code>fs::read_to_string</code> бере <code>file_path</code>, відкриває цей файл і повертає <code>std::io::Result&lt;String&gt;</code> з його вмістом.</p>
<p>По тому знову додаємо тимчасову інструкцію <code>println!</code>, що видрукує значення <code>contents</code> після читання файлу, щоб ми змогли перевірити, як програма працює.</p>
<p>Запустімо цей код з будь-якою стрічкою першим параметром командного рядка (бо ми ще не додали частину для пошуку) і <em>poem.txt</em> другим параметром:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Чудово! Код прочитав і надрукував вміст файлу. Але код має кілька недоліків. Наразі функція <code>main</code> відповідає за багато різних речей. В цілому, функції стають зрозумілішими і їх легше підтримувати, якщо кожна функція відповідає за лише одну ідею. Інша проблема полягає в тому, що ми не обробляємо помилки так добре, як могли б. Програма все ще невелика, тому ці недоліки не становлять великої проблеми, але зі зростанням програми стане важчим їх акуратно виправити. Є гарна порада - починати рефакторити код на ранній стадії розробки програми, бо значно легше рефакторити невеликі фрагменти коду. Цим ми й займемося.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Рефакторизація-для-покращення-модульності-та-обробки-помилок"><a class="header" href="#Рефакторизація-для-покращення-модульності-та-обробки-помилок">Рефакторизація для покращення модульності та обробки помилок</a></h2>
<p>Для покращення програми ми розв'яжемо чотири проблеми, пов’язані зі структурою програми та тим, як вона обробляє потенційні помилки. По-перше, наша функція <code>main</code> тепер виконує два завдання: розбирає параметри та читає файли. Зі зростанням нашої програми кількість окремих завдань, які обробляє функція <code>main</code>, збільшуватиметься. Зі збільшенням відповідальності функції її стає складніше розуміти, важче тестувати, важче змінювати, не порушуючи інших її частин. Найкраще розділити функціональність, щоб кожна функція відповідала за одне завдання.</p>
<p>Це питання також пов'язане з другою проблемою: у той час, як змінні <code>query</code> та <code>file_path</code> є конфігураційними змінними нашої програми, змінні на кшталт <code>contents</code> використовуються для реалізації логіки програм. Що довшим ставатиме <code>main</code>, то більше змінних треба буде додати в область видимості; що більше змінних в області видимості, тим складніше буде відстежувати призначення кожної з них. Найкраще згрупувати конфігураційні змінні в одну структуру, щоб унаочнити їнє призначення.</p>
<p>Третя проблема полягає в тому, що ми використали <code>expect</code>, щоб вивести повідомлення про помилку, коли не вдається прочитати файл, але саме повідомлення лише каже <code>Should have been able to read the file</code>. Читання файлу може бути невдалим через багато причин: скажімо, такого файлу може не існувати, або у нас може не бути прав відкривати його. Поки що, незалежно від ситуації, ми виводимо те саме повідомлення про помилку для будь-якої причини, що не дає користувачеві жодної інформації!</p>
<p>По-четверте, ми використовуємо <code>expect</code> знову і знову для обробки різних помилок, і якщо користувач запустить програму, не вказавши потрібні параметри, то побачить лише повідомлення Rust про помилку <code>index out of bounds</code>, що не дуже чітко описує проблему. Найкраще буде, якщо код обробки помилок буде в одному місці, щоб той, хто підтримуватиме код у майбутньому, мав зазирнути лише в одне місце в коді, якщо треба буде змінити логіку обробки помилок. Те, що код обробки помилок знаходиться в одному місці, також гарантує, що ми друкуємо повідомлення, зрозумілі для наших кінцевих користувачів.</p>
<p>Щоб виправити ці чотири проблеми, зробімо рефакторинг нашого проєкту.</p>
<h3 id="Розділення-зон-інтересів-у-двійкових-проєктах"><a class="header" href="#Розділення-зон-інтересів-у-двійкових-проєктах">Розділення зон інтересів у двійкових проєктах</a></h3>
<p>Організаційна проблема поділу відповідальності за різні завдання у функції <code>main</code> є спільною для багатьох двійкових проєктів. У результаті спільнота Rust розробила рекомендації для поділу окремих інтересів у двійковій програмі, коли функція <code>main</code> починає ставати великою. Процес складається з наступних кроків:</p>
<ul>
<li>Поділіть свою програму на <em>main.rs</em> та <em>lib.rs</em> і перенесіть логіку програми до <em>lib.rs</em>.</li>
<li>Поки логіка для аналізу командного рядка невелика, вона може залишатися в <em>main.rs</em>.</li>
<li>Коли обробка логіки командного рядка починає ускладнюватись, витягніть її з <em>main.rs</em> і перемістіть до <em>lib.rs</em>.</li>
</ul>
<p>Відповідальність коду, що залишиться в функції <code>main</code> після цього, має бути обмеженою до такого:</p>
<ul>
<li>Виклик логіки аналізу командного рядка і передача їй значень аргументів</li>
<li>Налаштування решти конфігурації</li>
<li>Виклик функції <code>run</code> із <em>lib.rs</em></li>
<li>Обробка помилок, якщо <code>run</code> поверне помилку</li>
</ul>
<p>Цей шаблон стосується поділу інтересів: <em>main.rs</em> обробляє запуск програми, а <em>lib.rs</em> обробляє всю логіку основного завдання. Оскільки функцію <code>main</code> неможливо тестувати напряму, ця структура дозволяє вам тестувати усю логіку вашої програми, перенісши її до функцій у <em>lib.rs</em>. Код, що залишився в <em>main.rs</em> буде досить маленьким, щоб перевірити його правильність, прочитавши його. Переробімо нашу програму відповідно до цього процесу.</p>
<h4 id="Перенесення-аналізатора-аргументів"><a class="header" href="#Перенесення-аналізатора-аргументів">Перенесення аналізатора аргументів</a></h4>
<p>Ми перенесемо функціональність для аналізу аргументів у функцію, котру буде викликати <code>main</code>, щоб підготувати переміщення логіки розбору командного рядка до <em>src/lib. s</em>. Блок коду 12-5 показує початок нової функції <code>main</code>, яка викликає нову функцію <code>parse_config</code>, котру ми скоро визначимо в <em>src/main.rs</em>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, query);
</span><span class="boring">    println!(&quot;In file {}&quot;, file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}
</code></pre>
<p><span class="caption">Блок коду 12-5: Вилучення функції <code>parse_config</code> з <code>main</code></span></p>
<p>Ми все ще збираємо аргументи командного рядка до вектора, але замість присвоювати значення аргументу з індексом 1 змінній <code>query</code>, а значення аргументу з індексом 2 змінній <code>file_path</code> у функції <code>main</code>, ми передаємо весь вектор до функції <code>parse_config</code>. Функція <code>parse_config</code> містить логіку, що визначає, який аргумент потрапляє до якої змінної і передає значення на назад до <code>main</code>. Ми все ще створюємо змінні <code>query</code> та <code>file_path</code> у <code>main</code>, але <code>main</code> більше не відповідає за визначення, як співвідносяться аргументи командного рядка та змінні.</p>
<p>Це перероблення може виглядати надмірним для нашої програми, але ми робимо рефакторизацію невеликими поступовими кроками. Після внесення цієї зміни знову запустіть програму, щоб перевірити, що аналіз аргументів все ще працює. Дуже добра ідея - часто перевіряти ваш прогрес, щоб легше було визначити причину проблем, коли вони з'являться.</p>
<h4 id="Групування-конфігураційних-значень"><a class="header" href="#Групування-конфігураційних-значень">Групування конфігураційних значень</a></h4>
<p>Ми можемо зробити ще один невеликий крок, щоб поліпшити функцію <code>parse_config</code>. На цей момент вона повертає кортеж, а потім ми відразу ж розбираємо цей кортеж на окремі частини. Це ознака того, що, можливо, ми ще не досягли правильної абстракції.</p>
<p>Інший показник, що вказує на місце для покращення - це частина <code>config</code> функції <code>parse_config</code>, яка має на увазі, що два значення, що ми повертаємо, пов'язані і є частинами одного конфігураційного значення. Наразі ми передаємо це в структурі даних простим групуванням двох значень у кортеж, що не дуже виразно; натомість покладімо два значення в одну структуру і дамо кожному з полів змістовну назву. Таким чином ми полегшимо тим, хто підтримуватиме цей код у майбутньому, розуміння, як різні значення стосуються одне одного і яке їхнє призначення.</p>
<p>Блок коду 12-6 показує покращення до функції <code>parse_config</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect(&quot;Should have been able to read the file&quot;);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}
</code></pre>
<p><span class="caption">Блок коду 12-6: Рефакторизація функції <code>parse_config</code>, що тепер повертає екземпляр структури <code>Config</code></span></p>
<p>Ми додали структуру, що зветься <code>Config</code>, у якій визначили поля, що звуться <code>query</code> та <code>file_path</code>. Сигнатура <code>parse_config</code> тепер показує, що вона повертає значення типу <code>Config</code>. У тілі <code>parse_config</code>, де раніше ми повертали стрічкові слайси, які посилалися на значення <code>String</code> у <code>args</code>, тепер ми задаємо значення <code>String</code>, якими володіє <code>Config</code>. Змінна <code>args</code> у <code>main</code> є власником значень аргументів і лише дозволяє функції <code>parse_config</code> позичити їх, тобто ми б порушили правила позичання Rust якби <code>Config</code> пробував взяти володіння значеннями з <code>args</code>.</p>
<p>Є багато способів, як ми могли б керувати даними <code>String</code>; найпростіший, хоча і дещо неефективний спосіб - викликати метод <code>clone</code> для значень. Це зробить повну копію даних для надання володіння екземпляра <code>Config</code>, що потребує більше часу і пам'яті, ніж зберігання посилання на дані стрічки. Однак клонування даних також робить наш код вкрай прямолінійним, бо нам не треба керувати часами існування посилань; за цих обставин, віддати трохи продуктивності задля спрощення є гідним компромісом.</p>
<blockquote>
<h3 id="Використання-clone-як-компроміс"><a class="header" href="#Використання-clone-як-компроміс">Використання <code>clone</code> як компроміс</a></h3>
<p>Існує тенденція, якої дотримується багато растацеанців, уникати використання <code>clone</code> для виправлення проблем із володінням через його ціну часу виконання. У  <a href="ch13-00-functional-features.html">Розділі 13</a><!-- ignore -->ви дізнаєтеся, як застосовувати ефективніші методи для ситуацій на кшталт цієї. Та поки що цілком прийнятно скопіювати кілька стрічок для продовження розробки, бо ці копії робляться лише один раз і шлях до файлу та стрічка запиту дуже маленькі. Краще мати дещо неефективну робочу програму, ніж намагатися з першого разу переоптимізувати код. Як ви ставатимете досвідченішими з Rust, ставатиме легше починати з найефективнішого рішення, та поки що цілком прийнятно викликати <code>clone</code>.</p>
</blockquote>
<p>Ми змінили <code>main</code>, і тепер він розміщує екземпляр <code>Config</code>, повернутий <code>parse_config</code>, у змінну з назвою <code>config</code>, і змінили код, що раніше розділяв змінні <code>query</code> та <code>file_path</code>, щоб він натомість використовував поля у структурі <code>Config</code>.</p>
<p>Тепер наш код ясніше передає, що <code>query</code> та <code>file_path</code> пов'язані, і що їхнє призначення - конфігурувати роботу програми. Будь-який код, що використовує ці значення, знає, що їх треба шукати у екземплярі <code>config</code> у полях з назвами, що відповідають їхньому призначенню.</p>
<h4 id="Створення-конструктора-для-config"><a class="header" href="#Створення-конструктора-для-config">Створення конструктора для <code>Config</code></a></h4>
<p>Ми вже перенесли логіку, що відповідає за обробку аргументів командного рядка, з <code>main</code> і помістили її у функції <code>parse_config</code>. Це допомогло нам побачити, що змінні <code>query</code> та <code>file_path</code> пов'язані і цей зв'язок має бути показаним у коді. Потім ми додали структуру <code>Config</code>, щоб назвати об'єднані за призначенням змінні <code>query</code> та <code>file_path</code> і щоб можна було повертати імена значень як поля структури з функції <code>parse_config</code>.</p>
<p>Тож тепер, оскільки призначення функції <code>parse_config</code> - створити екземпляр <code>Config</code>, ми можемо змінити <code>parse_config</code> зі звичайної функції на функцію, що зветься <code>new</code>, асоційонвану зі структурою <code>Config</code>. Ця зміна зробить код більш ідіоматичним. Ми можемо створювати екземпляри типів зі стандартної бібліотеки, такі як <code>String</code>, викликом <code>String::new</code>. Подібним чином, змінивши <code>parse_config</code> на функцію <code>new</code>, асоційовану з <code>Config</code>, ми зможемо створювати екземпляри <code>Config</code> викликом <code>Config::new</code>. Блок коду 12-7 показує, які зміни треба зробити.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}
</code></pre>
<p><span class="caption">Listing 12-7: Зміна <code>parse_config</code> на <code>Config::new</code></span></p>
<p>Ми замінили у <code>main</code> виклик <code>parse_config</code> на виклик <code>Config::new</code>. Ми змінили назву <code>parse_config</code> на <code>new</code> і перенесли її в блок <code>impl</code>, асоціювавши функцію <code>new</code> з <code>Config</code>. Спробуйте скомпілювати цей код ще раз, щоб переконатися, що він працює.</p>
<h3 id="Виправлення-обробки-помилок"><a class="header" href="#Виправлення-обробки-помилок">Виправлення обробки помилок</a></h3>
<p>Тепер ми попрацюємо над виправленням обробки помилок. Згадайте, що спроби отримати доступ до значень у векторі <code>args</code> за індексами 1 чи 2 призведе до паніки програми, якщо у векторі менш ніж три елементи. Спробуйте запустити програму без будь-яких аргументів; це виглядатиме так:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Рядок <code>index out of bounds: the len is 1 but the index is 1</code> - це повідомлення про помилку, призначене для програмістів. Воно не допоможе кінцевим користувачам зрозуміти, що вони мають робити. Полагодьмо це.</p>
<h4 id="Поліпшення-повідомлення-про-помилку"><a class="header" href="#Поліпшення-повідомлення-про-помилку">Поліпшення повідомлення про помилку</a></h4>
<p>У Блоці коду 12-8 ми додаємо перевірку у функцію <code>new</code>, що підтверджує, що слайс достатньо довгий, перед тим як звертатися до індексів 1 та 2. Якщо слайс недостатньо довгий, програма панікує і показує краще повідомлення про помилку.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;not enough arguments&quot;);
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 12-8: Додавання перевірки на число аргументів</span></p>
<p>Цей код подібний до <a href="ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation">функції <code>Guess::new</code>, яку ми написали у Блоці коду 9-13</a><!-- ignore -->, де ми викликали <code>panic!</code>, коли аргумент <code>value</code> був поза діапазоном припустимих значень. Тут, замість перевірки діапазону значень, ми перевіряємо, що довжина <code>args</code> є принаймні 3, і решта функції може працювати з припущенням, що ця умова виконується. Якщо <code>args</code> має менш ніж три елементи, ця умова буде істинною, і ми викличемо макрос <code>panic!</code>, щоб негайно завершити програму.</p>
<p>Після додавання цих кількох рядків коду до <code>new</code> знову запустімо програму без аргументів, щоб побачити, як помилка виглядатиме тепер:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Це вже краще: тепер ми маємо зрозуміле повідомлення про помилку. Однак, ми також маємо побічну інформацію, яку не хочемо надавати нашим користувачам. Мабуть, техніка, яку ми використовували в Блоці коду 9-13, не найліпше підходить сюди: виклик <code>panic!</code> більш доречний для проблеми з програмуванням, ніж до проблеми з використанням, <a href="ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">що обговорювалося в Розділі 9</a><!-- ignore -->. Натомість ми використаємо іншу техніку, про яку ви дізналися з Розділу 9 - <a href="ch09-02-recoverable-errors-with-result.html">повернення <code>Result</code></a><!-- ignore --> , що позначає успіх чи помилку.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="returning-a-result-from-new-instead-of-calling-panic"></a></p>
<h4 id="Повертаємо-result-замість-виклику-panic"><a class="header" href="#Повертаємо-result-замість-виклику-panic">Повертаємо <code>Result</code> замість виклику <code>panic!</code></a></h4>
<p>Ми можемо натомість повернути значення <code>Result</code>, що мітитиме екземпляр <code>Config</code> при успіху і описуватиме проблему у випадку помилки. Ми також збираємося змінити назву функції з <code>new</code> на <code>build</code>, бо багато програмістів очікують, що функції <code>new</code> ніколи не зазнають невдачі. Коли <code>Config::build</code> передає повідомлення до <code>main</code>, ми можемо використати тип <code>Result</code>, щоб сигналізувати про проблему. Потім ми можемо змінити <code>main</code>, щоб перетворити варіант <code>Err</code> на більш практичне повідомлення для наших користувачів без зайвого тексту про <code>thread 'main'</code> і <code>RUST_BACKTRACE</code>, як робить виклик <code>panic!</code>.</p>
<p>Блок коду 12-9 показує зміни до функції, що тепер зветься <code>Config::build</code>, які ми маємо зробити, щоб значення, що повертається з неї, було типу <code>Result</code>, і відповідне тіло функції. Зверніть увагу, що цей код не скомпілюється, доки ми не змінимо також і <code>main</code>, що ми робимо в наступному блоці коду.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}
</code></pre>
<p><span class="caption">Блок коду 12-9: Повертання <code>Result</code> з <code>Config::build</code></span></p>
<p>Наша функція <code>build</code> повертає <code>Result</code> з екземпляром <code>Config</code> у разі успіху і <code>&amp;'static str</code> у разі помилки. Значення наших помилок завжди будуть стрічковими літералами з часом існування <code>'static</code>.</p>
<p>Ми зробили дві зміни у тілі функції: замість виклику <code>panic!</code>, коли користувач не надав достатньо аргументів, ми тепер повертаємо значення <code>Err</code>, і ми обгорнули значення <code>Config</code>, що ми повертаємо, у <code>Ok</code>. Ці зміни узгоджують функцію з новою сигнатурою типу.</p>
<p>Повертання значення <code>Err</code> з <code>Config::build</code> дозволяє функції <code>main</code> обробити значення <code>Result</code>, повернуте з функції <code>build</code>, і вийти з процесу чистіше у випадку помилки.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="calling-confignew-and-handling-errors"></a></p>
<h4 id="Виклик-configbuild-і-обробка-помилок"><a class="header" href="#Виклик-configbuild-і-обробка-помилок">Виклик <code>Config::build</code> і обробка помилок</a></h4>
<p>Щоб обробити випадок з помилкою і вивести дружнє для користувача повідомлення, нам треба змінити <code>main</code>, щоб обробити <code>Result</code>, повернений <code>Config::build</code>, як показано у Блоці коду 12-10. Ми також візьмемо відповідальність за вихід з інструменту командного рядка з ненульовим кодом помилки з <code>panic!</code> і реалізуємо його самостійно. Ненульовий статус на виході - це угода, щоб повідомити процесу, який викликав нашу програму, що програма завершилася з помилкою.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 12-10: Вихід з кодом помилки, якщо збірка <code>Config</code> була невдалою</span></p>
<p>У цьому блоці коду ми скористалися методом, про який ще детально не розповідали - <code>unwrap_or_else</code>, що визначено на <code>Result&lt;T, E&gt;</code> у стандартній бібліотеці. <code>unwrap_or_else</code> дозволяє визначати власну обробку помилок, без <code>panic!</code>. Якщо <code>Result</code> є значенням <code>Ok</code>, цей метод робить те саме, що й <code>unwrap</code>: повертає внутрішнє значення, загорнуте в <code>Ok</code>. Але якщо значення є <code>Err</code>, цей метод викликає код у <em>замиканні</em>, тобто анонімній функції, що ми визначаємо і передаємо аргументом до <code>unwrap_or_else</code>. Про замикання детальніше піде у <a href="ch13-00-functional-features.html">Розділі 13</a><!-- ignore -->. Поки що вам лише слід знати, що <code>unwrap_or_else</code> передасть внутрішнє значення <code>Err</code>, тобто у нашому випадку статичну стрічку <code>&quot;not enough arguments&quot;</code>, що ми додали в Блоці коду 12-9, нашому замиканню, як аргумент <code>err</code>, що визначається між вертикальними лініями. Код у замиканні зможе під час виконання використати значення <code>err</code>.</p>
<p>Ми додали новий рядок <code>use</code>, щоб ввести <code>process</code> зі стандартної бібліотеки до області видимості. Код у замиканні, що буде виконано у випадку помилки, складається лише з двох рядків: ми виводимо значення <code>err</code> і потім викликаємо <code>process::exit</code>. Функція <code>process::exit</code> негайно зупиняє програму і повертає передане число як код статусу виходу. Це схоже на обробку помилок за допомогою <code>panic!</code>, як ми робили в Блоці коду 12-8, але ми більше не отримуємо зайвий вивід. Спробуймо:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Чудово! Це повідомлення набагато дружніше до наших користувачів.</p>
<h3 id="Перенесення-логіки-з-main"><a class="header" href="#Перенесення-логіки-з-main">Перенесення логіки з <code>main</code></a></h3>
<p>Тепер, коли ми закінчили рефакторизацію аналізу конфігурації, повернімося до логіки програми. Як ми казали в <a href="ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects">&quot;Розділення зон інтересів у двійкових проєктах&quot;</a><!-- ignore -->, ми виділимо функцію, що зветься <code>run</code>, що міститиме всю логіку, наразі розміщену у функції <code>main</code>, яка не бере участі у встановленні конфігурації чи обробці помилок. Коли ми закінчимо, <code>main</code> стане виразним і легким для перевірки на помилки простим переглядом, і ми зможемо написати тести для решти логіки програми.</p>
<p>Блок коду 12-11 показує виокремлену функцію <code>run</code>. Поки що, ми робимо маленькі, поступові покращення при виділенні функції. Ми все ще визначаємо цю функцію у <em>src/main.rs</em>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect(&quot;Should have been able to read the file&quot;);

    println!(&quot;With text:\n{contents}&quot;);
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 12-11: Виділення функції <code>run</code>, що містить решту логіки програми</span></p>
<p>Функція <code>run</code> тепер містить решту логіки з <code>main</code>, починаючи з читання файлу. Функція <code>run</code> приймає аргументом екземпляр <code>Config</code>.</p>
<h4 id="Повертання-помилок-з-функції-run"><a class="header" href="#Повертання-помилок-з-функції-run">Повертання помилок з функції <code>run</code></a></h4>
<p>Для решти логіки програми, виділеної в функцію <code>run</code>, ми можемо покращити обробку помилок, як ми зробили з <code>Config::build</code> у Блоці коду 12-9. Замість дозволяти програмі панікувати викликом <code>expect</code>, функція <code>run</code> повертатиме <code>Result&lt;T, E&gt;</code>, коли щось піде не так. Це дозволить нам об'єднати логіку обробки помилок у <code>main</code> у дружній для користувача спосіб. Блок коду 12-12 показує зміни, які нам треба зробити в сигнатурі і тілі <code>run</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!(&quot;With text:\n{contents}&quot;);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 12-12: Зміна функції <code>run</code>, що повертає <code>Result</code></span></p>
<p>Ми зробили тут три суттєві зміни. По-перше, ми змінили тип, що повертає функція <code>run</code>, на <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>. Ця функція раніше повертала одиничний тип, <code>()</code>, і ми залишаємо це значення у випадку <code>Ok</code>.</p>
<p>Для типу помилок, ми використовуємо <em>трейтовий об'єкт</em> <code>Box&lt;dyn Error&gt;</code> (і ми внесли <code>std::error::Error</code> до області видимості за допомогою інструкції <code>use</code> на початку). Ми розкажемо про трейтові об'єкти у <a href="ch17-00-oop.html">Розділі 17</a><!-- ignore -->. Поки що, вам достатньо знати, що <code>Box&lt;dyn Error&gt;</code> означає, що функція поверне тип, що реалізує трейт <code>Error</code>, але ми не маємо зазначати який це буде конкретний тип значення. Це надає нам гнучкості, щоб повертати значення, які можуть бути різних типів у випадках різних помилок. Ключове слово <code>dyn</code> - це скорочення для &quot;динамічний&quot; (“dynamic”).</p>
<p>По-друге, ми прибрали виклик <code>expect</code>, замінивши його натомість оператором <code>?</code>, як ми й говорили у <a href="ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">Розділі 9</a><!-- ignore -->. Замість виклику <code>panic!</code> при помилці, <code>?</code> поверне значення помилки з поточної функції тому, хто її викликав, для обробки.</p>
<p>По-третє, функція <code>run</code> тепер повертає значення <code>Ok</code> у випадку успіху. Ми проголосили у сигнатурі, що тип успіху функції <code>run</code> - <code>()</code>, що означає, що нам потрібно обгорнути значення одиничного типу у значення <code>Ok</code>. Цей запис <code>Ok(())</code> може спершу видаватися трохи дивним, але використання <code>()</code> подібним чином є ідіоматичним способом позначити, що ми викликаємо <code>run</code> лише задля його побічних ефектів; він не повертає потрібного значення.</p>
<p>Коли ви запускаєте цей код, він скомпілюється, але покаже попередження:</p>
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `minigrep` (bin &quot;minigrep&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust каже нам, що наш код проігнорував значення <code>Result</code> і що це значення <code>Result</code> може показувати, що сталася помилка. Але ми не перевіряємо, чи не було помилки, і компілятор нагадує нам, що ми, мабуть, хотіли б додати сюди код для обробки помилок! Виправмо одразу цю проблему.</p>
<h4 id="Обробка-помилок-повернутих-з-run-до-main"><a class="header" href="#Обробка-помилок-повернутих-з-run-до-main">Обробка помилок, повернутих з <code>run</code> до <code>main</code></a></h4>
<p>Ми перевірятимемо на помилки і оброблятимемо їх за допомогою техніки, подібної до тої, якою ми скористалися з <code>Config::build</code>, з невеликою відмінністю:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.file_path);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {e}&quot;);

        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Ми використовуємо <code>if let</code> замість <code>unwrap_or_else</code> для перевірки, чи <code>run</code> повертає значення <code>Err</code> і викликаємо в цьому випадку <code>process::exit(1)</code>. Функція <code>run</code> не повертає значення, яке б ми хотіли отримати за допомогою <code>unwrap</code>, на відміну від <code>Config::build</code>, що повертає екземпляр <code>Config</code>. Оскільки <code>run</code> у випадку успіху повертає <code>()</code>, нас турбує лише виявлення помилки, тож нам не потрібен <code>unwrap_or_else</code> для отримання видобутого значення, яке може бути лише <code>()</code>.</p>
<p>Тіла <code>if let</code> та функції <code>unwrap_or_else</code> однакові в обох випадках: ми виводимо помилку і виходимо.</p>
<h3 id="Виділення-коду-у-бібліотечний-крейт"><a class="header" href="#Виділення-коду-у-бібліотечний-крейт">Виділення коду у бібліотечний крейт</a></h3>
<p>Наш проєкт <code>minigrep</code> поки що має непоганий вигляд! Тепер ми поділимо файл <em>src/main.rs</em> і перенесемо частину коду у файл <em>src/lib.rs</em>. Таким чином, ми зможемо тестувати код, залишивши файлу <em>src/main.rs</em> менше відповідальності.</p>
<p>Перенесімо весь код, крім функції <code>main</code>, з <em>src/main.rs</em> до <em>src/lib.rs</em>:</p>
<ul>
<li>Визначення функції <code>run</code></li>
<li>Відповідні інструкції <code>use</code></li>
<li>Визначення <code>Config</code></li>
<li>Визначення функції <code>Config::build</code></li>
</ul>
<p>Вміст <em>src/lib.rs</em> має містити сигнатури, показані в Блоці коду 12-13 (ми опустили тіла функцій для стислості). Зверніть увагу, що цей код не скомпілюється, поки ми не змінимо <em>src/main.rs</em> у Блоці коду 12-14.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --snip--
<span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}
</code></pre>
<p><span class="caption">Блок коду 12-13: Перенесення <code>Config</code> і <code>run</code> до <em>src/lib.rs</em></span></p>
<p>Ми дещо вільно використали ключове слово <code>pub</code>: для <code>Config</code>, його полів і його методу <code>build</code>, а також для функції <code>run</code>. Тепер ми маємо бібліотечний крейт, що має публічний API, який ми можемо тестувати!</p>
<p>Now we need to bring the code we moved to <em>src/lib.rs</em> into the scope of the binary crate in <em>src/main.rs</em>, as shown in Listing 12-14.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --snip--
<span class="boring">        println!(&quot;Application error: {e}&quot;);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span>    }
}
</code></pre>
<p><span class="caption">Блок коду 12-14: Використання бібліотечного крейту <code>minigrep</code> у <em>src/main.rs</em></span></p>
<p>Ми додали рядок <code>use minigrep::Config</code>, щоб внести тип <code>Config</code> з бібліотечного крейту до області видимості двійкового крейту, і додали перед функцією <code>run</code> назву нашого крейту. Тепер уся функціональність має бути з'єднана і мусить працювати. Запустіть програму за допомогою <code>cargo run</code> і переконайтеся, що все працює правильно.</p>
<p>Хух! Добряче попрацювали, але налаштували себе на успіх у майбутньому. Тепер буде значно легше обробляти помилки, і ми зробили код більш модульним. Майже вся наша робота з цього моменту буде виконуватися в <em>src/lib.rs</em>.</p>
<p>Скористаймося з цієї новоствореної модульності, зробивши дещо, що було б складним зі старим кодом, але легко з новим: напишемо кілька тестів!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Розробка-Функціонала-Бібліотеки-із-test-driven-development"><a class="header" href="#Розробка-Функціонала-Бібліотеки-із-test-driven-development">Розробка Функціонала Бібліотеки із Test-Driven Development</a></h2>
<p>Тепер, коли ми перенесли логіку в <em>src/lib.rs</em> та залишили збір аргументів та обробку помилок в <em>src/main.rs</em>, стало набагато простіше писати тести для основного функціонала нашого коду. Ми можемо викликати функції напряму із різноманітними аргументами та перевіряти повернуті значення без потреби виклику нашого двійкового файлу із командного рядка.</p>
<p>У цій секції ми додамо пошукову логіку до програми <code>minigrep</code>, використовуючи стиль розробки через тестування (TDD) із наступними кроками:</p>
<ol>
<li>Напишіть тест, який дає збій і запустить його, щоб переконатися, що він це робить через очікувану причину.</li>
<li>Напишіть або змініть мінімум коду, щоб новий тест пройшов.</li>
<li>Відрефакторіть щойно доданий або змінений код та впевніться, що тести продовжують проходити.</li>
<li>Повторіть з першого кроку!</li>
</ol>
<p>Хоча це лише один з багатьох способів написання програмного забезпечення, TDD може допомагати надавати потрібного напрямку оформленню коду. Створення тесту перед тим, як написати код, який забезпечить проходження тесту, допомагає підтримувати високий рівень покриття тестуванням протягом всього процесу розробки.</p>
<p>Ми протестуємо імплементацію функціоналу який буде робити пошуковий запит стрічки у вмісті файлу та створювати список рядків, які відповідають запиту. Ми додамо цей функціонал у функцію під назвою <code>search</code>.</p>
<h3 id="Написання-Провального-Тесту"><a class="header" href="#Написання-Провального-Тесту">Написання Провального Тесту</a></h3>
<p>Видалімо інструкції <code>println!</code> які ми використовували для перевірки поведінки програми з <em>src/lib.rs</em> та <em>src/main.rs</em>, бо нам вони більше не потрібні. Потім додамо в <em>src/lib.rs</em> модуль <code>tests</code> із тестовою функцією, як ми зробили в <a href="ch11-01-writing-tests.html#the-anatomy-of-a-test-function">Розділі 11</a><!-- ignore -->. Тестова функція визначає бажану поведінку функції <code>search</code>: вона отримає запит та текст для пошуку, і вона буде повертати лише рядки з тексту, які містять запит. Блок коду 12-15 показує цей тест, який ще не компілюється.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
    }
}
</code></pre>
<p><span class="caption">Блок коду 12-15: Створення невдалого тесту для функції <code>search</code>, яку ми хотіли б мати</span></p>
<p>Цей тест шукає рядок <code>&quot;duct&quot;</code>. Текст, в якому ми робимо пошук, це три рядки, лише один з яких містить <code>&quot;duct&quot;</code> (Зауважте, що зворотний слеш після першої подвійної лапки каже Rust не розміщувати символ нового рядку на початку цієї стрічки). Ми стверджуємо, що значення, повернене з функції <code>search</code> містить тільки рядки, які ми очікуємо.</p>
<p>Ми ще не готові запустити цей тест та подивитися, як він дає збій, бо тест навіть не компілюється: функція <code>search</code> ще не існує! Згідно з принципами TDD, ми додамо лише мінімум коду, щоб тест почав компілюватися та виконуватися, додав визначення функції <code>search</code>, яке завжди повертає порожній вектор, як показано в Блоці коду 12-16. Тоді тест повинен скомпілюватися та провалитися, бо порожній вектор не зіставляється з вектором, який містить рядок <code>&quot;safe, fast, productive.&quot;</code></p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 12-16: Визначення функції <code>search</code>, якого досить для проходження тесту</span></p>
<p>Зауважте, що нам потрібно явно визначити час існування <code>'a</code> в сигнатурі <code>search</code> та використати цей час існування з аргументом <code>contents</code> та поверненим значенням. Згадаємо <a href="ch10-03-lifetime-syntax.html">Розділ 10</a><!-- ignore --> де час існування параметрів вказував, який час існування аргументу пов'язаний з поверненим значенням. У цьому випадку, ми вказуємо, що повернутий вектор має містити слайси стрічки, які посилаються на слайси аргументу <code>contents</code> (замість аргументу <code>query</code>).</p>
<p>Інакше кажучи, ми повідомляємо Rust, що дані, отримані <code>search</code> функцією будуть існувати допоки вони передаються в <code>search</code> функцію аргументом <code>contents</code>. Це важливо! Дані, на які посилається <em>слайс</em> мають бути валідними, щоб посилання було валідним; якщо компілятор вважає, що ми робимо строкові слайси <code>query</code> замість <code>contents</code>, він зробить перевірку безпеки некоректно.</p>
<p>Якщо ми забудемо анотації часу існування і спробуємо скомпілювати цю функцію, ми отримаємо цю помилку:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` due to previous error
</code></pre>
<p>Rust не має можливості дізнатися, який з двох аргументів нам потрібен, тому ми маємо явно це вказати. Оскільки <code>contents</code> це аргумент, який містить увесь наш текст і ми хочемо повертати відповідні частини цього тексту, ми розуміємо, що <code>contents</code> це аргумент який має бути пов'язаний з поверненим значенням використовуючи синтаксис часу існування.</p>
<p>Інші мови програмування не вимагають від вас пов'язувати аргументи із поверненим значенням в сигнатурі функції, але ця практика з часом стане легшою. Ви можете захотіти порівняти цей приклад із <a href="">“Validating References with Lifetimes”</a><!-- ignore --> Розділу 10.</p>
<p>Тепер запустимо тест:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `[&quot;safe, fast, productive.&quot;]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Чудово, тест провалюється, як ми й очікували. Нумо зробимо тест, який пройде!</p>
<h3 id="Написання-Коду-Щоб-Тест-Пройшов"><a class="header" href="#Написання-Коду-Щоб-Тест-Пройшов">Написання Коду, Щоб Тест Пройшов</a></h3>
<p>Наразі наш тест провалюється, бо він завжди повертає порожній вектор. Щоб виправити це та імплементувати <code>search</code>, наша програма має виконати такі дії:</p>
<ul>
<li>Ітерувати через кожний рядок вмісту.</li>
<li>Перевірити, чи містить цей рядок нашу стрічку запиту.</li>
<li>Якщо так, то додати його до списку значень який ми повертаємо.</li>
<li>Якщо ні, то нічого не робити.</li>
<li>Повернути отриманий список рядків, які збігаються.</li>
</ul>
<p>Пройдімо кожен крок, починаючи з ітерації по рядках.</p>
<h4 id="Ітерація-Рядками-із-Методом-lines"><a class="header" href="#Ітерація-Рядками-із-Методом-lines">Ітерація Рядками із Методом <code>lines</code></a></h4>
<p>Rust має корисний метод для керування ітерацією по стрічці рядок за рядком який зручно названий <code>lines</code>, який працює як показано в Блоці Коду 12-17. Зверніть увагу, це ще не буде компілюватися.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 12-17: Ітерація по кожному рядку в <code>contents</code> </span></p>
<p>Метод <code>lines</code> повертає ітератор. Ми поговоримо про ітератори більш детально в <a href="ch13-02-iterators.html">Розділі 13</a><!-- ignore -->, але пригадайте, що ви бачили цей спосіб використання ітератора в <a href="ch03-05-control-flow.html#looping-through-a-collection-with-for">Блоці Коду 3-5</a><!-- ignore -->, де ми використовували цикл <code>for</code> з ітератором для виконання деякого коду на кожному елементі колекції.</p>
<h4 id="Пошук-Запиту-в-Кожному-Рядку"><a class="header" href="#Пошук-Запиту-в-Кожному-Рядку">Пошук Запиту в Кожному Рядку</a></h4>
<p>Далі, ми перевіримо, чи містить поточний рядок стрічку запиту. На щастя, стрічки мають корисний метод названий <code>contains</code>, який робить це для нас! Додайте виклик методу <code>contains</code> в функцію <code>search</code>, як показано в Блоці Коду 12-18. Зауважте, що це ще не буде компілюватися.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 12-18: Adding functionality to see whether the line contains the string in <code>query</code></span></p>
<p>Ми зараз створюємо функціонал. Щоб він компілювався, нам потрібно повертати значення з вмісту функції, як ми вказали в її сигнатурі.</p>
<h4 id="Зберігання-Відповідних-Рядків"><a class="header" href="#Зберігання-Відповідних-Рядків">Зберігання Відповідних Рядків</a></h4>
<p>Щоб завершити цю функцію, нам потрібен спосіб зберігання зіставлених рядків, які ми хочемо повертати. Для цього, ми можемо створити мутабельний вектор перед циклом <code>for</code> та викликати метод <code>push</code>, щоб зберегти <code>line</code> в векторі. Після циклу <code>for</code>, ми повертаємо вектор, як показано в Блоці Коду 12-19.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 12-19: Storing the lines that match so we can return them</span></p>
<p>Тепер функція <code>search</code> повинна повертати тільки рядки, що містять <code>query</code>, і наш тест повинен пройти. Запустимо тест:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Наш тест пройшов, тому ми знаємо, що він працює!</p>
<p>На цьому етапі ми могли б розглянути можливості рефакторингу імплементації функції пошуку, зберігаючи проходження тестів та зберігаючи той самий функціонал. Код функції пошуку не настільки й поганий, але він не використовує переваги деяких корисних особливостей ітераторів. Ми повернемось до цього прикладу в <a href="ch13-02-iterators.html">Розділі 13</a><!-- ignore -->, де ми дослідимо ітератори детальніше та розглянемо, як ми можемо їх вдосконалити.</p>
<h4 id="Використовування-Функції-search-в-Функції-run"><a class="header" href="#Використовування-Функції-search-в-Функції-run">Використовування Функції <code>search</code> в Функції <code>run</code></a></h4>
<p>Тепер, коли функція <code>search</code> працює та протестована, нам потрібно викликати <code>search</code> з нашої функції <code>run</code>. Нам потрібно передати значення <code>config.query</code> та <code>contents</code> яке <code>run</code> читає з файлу в функцію <code>search</code>. Потім <code>run</code> виведе в консолі кожен рядок повернений з <code>search</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{line}&quot;);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Ми досі використовуємо цикл <code>for</code> для повернення кожного рядка із <code>search</code> та його виводу в консолі.</p>
<p>Тепер вся програма має працювати! Нумо спробуємо, спочатку зі словом, яке має повертати річно один рядок із поеми Емілі Дікінсон, &quot;frog&quot;:</p>
<pre><code class="language-console">$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Круто! Спробуємо слово, яке зіставлятиметься з кількома рядками, наприклад &quot;body&quot;:</p>
<pre><code class="language-console">$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>And finally, let’s make sure that we don’t get any lines when we search for a word that isn’t anywhere in the poem, such as “monomorphization”:</p>
<pre><code class="language-console">$ cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Блискуче! Ми побудували нашу власну мініверсію класичного інструменту та багато дізналися про структурування застосунків. Ми також дізналися дещо про ввід у файл, вивід файлу, часи існування, тестування та парсинг командного рядка.</p>
<p>To round out this project, we’ll briefly demonstrate how to work with environment variables and how to print to standard error, both of which are useful when you’re writing command line programs. ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
ch10-03-lifetime-syntax.html#validating-references-with-lifetimes</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Робота-зі-Змінними-Середовища"><a class="header" href="#Робота-зі-Змінними-Середовища">Робота зі Змінними Середовища</a></h2>
<p>Ми покращимо <code>minigrep</code>, додавши екстра функціонал: можливість нечутливого до регістру пошуку, який користувач може увімкнути використавши змінну середовища. Ми могли б зробити цю особливість опцією командного рядку та вимагати, щоб користувачі вводили її кожного разу, коли вони хотіли б її застосувати, але, замість цього, зробивши її змінною середовища, ми дозволяємо нашим користувачам встановлювати змінну середовища одноразово і мати будь-який пошук в цій сесії терміналу нечутливим до регістру.</p>
<h3 id="Написання-Провального-Тесту-для-Нечутливої-до-Регістру-Функції-search"><a class="header" href="#Написання-Провального-Тесту-для-Нечутливої-до-Регістру-Функції-search">Написання Провального Тесту для Нечутливої до Регістру Функції <code>search</code></a></h3>
<p>Спочатку ми додаємо нову функцію <code>search_case_insensitive</code>, яка буде викликатися, коли змінна середовища має якесь значення. Ми продовжимо дотримуватися процесу TDD, так що, знову, перший крок це написати провальний тест. Ми додамо новий тест новій функції <code>search_case_insensitive</code> та перейменуємо наш старий тест із <code>one_result</code> в <code>case_sensitive</code> для уточнення відмінностей між двома тестами, як показано в Блоці Коду 12-20.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
</code></pre>
<p><span class="caption">Listing 12-20: Adding a new failing test for the case-insensitive function we’re about to add</span></p>
<p>Зверніть увагу, що ми також відредагували <code>зміст</code> старого тесту. Ми додали новий рядок із текстом <code>&quot;Duct tape.&quot;</code> використавши велику літеру D, яка має не зіставлятися з запитом <code>&quot;duct&quot;</code> коли ми шукаємо в чутливому до регістра режимі. Зміна старого тексту таким чином допомагає нам гарантувати, що ми не зламаємо функціонал чутливого до регістру пошуку, який ми вже імплементували. Цей тест зараз має пройти та має продовжувати проходити допоки ми працюємо над нечутливим до регістру пошуком.</p>
<p>Новий тест для <em>нечутливого до регістру</em> пошуку використовує <code>&quot;rUsT&quot;</code> як запит. В функції <code>search_case_insensitive</code>, яку ми незабаром додамо, запит <code>&quot;rUsT&quot;</code> має зіставлятися з рядком який містить <code>&quot;Rust:&quot;</code> із великою літерою R та рядком <code>&quot;Trust me.&quot;</code>, попри те, що обидва мають різний від запиту регістр. Це наш провальний тест і він не зможе вдало компілюватися, бо ми ще не визначили функцію <code>search_case_insensitive</code>. Не соромтесь додати каркас імплементації, яка завжди повертає порожній вектор, подібно до використаного способу в функції <code>search</code> із Блока Коду 12-16, щоб побачити, що тест компілюється та провалюється.</p>
<h3 id="Імплементація-Функції-search_case_insensitive"><a class="header" href="#Імплементація-Функції-search_case_insensitive">Імплементація Функції <code>search_case_insensitive</code></a></h3>
<p>Функція <code>search_case_insensitive</code>, показана в Блоці Коду 12-21, буде майже така сама, як функція <code>search</code>. Різниця лише в тому, що ми зробимо текст в <code>query</code> і в кожній <code>line</code> малими літерами, тому незважаючи на регістр вхідних аргументів, вони будуть однакового регістру коли ми будемо перевіряти, чи містить рядок запит.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 12-21: Defining the <code>search_case_insensitive</code> function to lowercase the query and the line before comparing them</span></p>
<p>Спочатку ми зменшуємо регістр стрічки <code>query</code> та зберігаємо в затіненій змінній з такою ж назвою. Виклик <code>to_lowercase</code> на запиті необхідне, щоб незалежно від того, чи запит користувача <code>&quot;rust&quot;</code>, <code>&quot;RUST&quot;</code>, <code>&quot;Rust&quot;</code>, чи <code>&quot;rUsT&quot;</code>, ми обробляли запит, ніби він <code>&quot;rust&quot;</code> і були не чутливі до регістру. Хоча <code>to_lowercase</code> буде обробляти базовій Unicode, він не буде 100% чітким. Якщо ми писали б справжній застосунок, ми б хотіли додатково попрацювати тут, але ця секція про змінні середовища, а не Unicode, тому ми зупинимось на цьому.</p>
<p>Зауважте, що <code>query</code> тепер є <code>String</code>, а не строковим слайсом, бо виклик до <code>to_lowercase</code> створює нові дані, а не посилається на ті, що існують. Скажімо запит це, наприклад, <code>&quot;rUsT&quot;</code>: слайс стрічки не містить малі літери <code>u</code> або <code>t</code>, щоб ми це використали, тому ми зробимо алокацію нової <code>String</code> яка буде містити <code>&quot;rust&quot;</code>. Ми зараз передамо <code>query</code>, як аргумент методу <code>contains</code> і нам потрібно додати амперсанд, бо сигнатура <code>contains</code> призначена отримувати слайс стрічки.</p>
<p>Далі, ми додамо виклик <code>to_lowercase</code> кожній <code>line</code>, щоб зробити всі символи малими. Тепер, коли ми перетворили <code>line</code> та <code>query</code> в нижній регістр, ми знайдемо збіги, незважаючи на регістр запиту.</p>
<p>Подивимось, чи ця імплементація пройде тести:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Чудово! Вони пройшли. Тепер викличемо нову функцію <code>search_case_insensitive</code> з функції <code>run</code>. Спочатку ми додамо опцію конфігурації в структуру <code>Config</code> для перемикання між чутливим та не чутливим до регістру пошуком. Додавання цього поля призведе до помилки компілятора, оскільки ми ще ніде не ініціювали це поле:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Ми додали поле <code>ignore_case</code>, яке містить Boolean. Далі, нам потрібно, щоб функція <code>run</code> перевіряла значення поля <code>ignore_case</code> та використовувала це, щоб вирішити, чи викликати функцію <code>search</code> чи функцію <code>search_case_insensitive</code>, як показано в Блоці Коду 12-22. Проте, це ще не буде компілюватися.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{line}&quot;);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 12-22: Виклик <code>search</code> або <code>search_case_insensitive</code> на основі значення в <code>config.ignore_case</code></span></p>
<p>Наостанок, нам потрібно перевірити змінну середовища. Функції для роботи зі змінними середовища є в модулі <code>env</code> стандартної бібліотеки, тому ми внесемо цей модуль в область видимості зверху файлу <em>src/lib.rs</em>. Потім ми використаємо функцію <code>var</code> з модуля <code>env</code> для перевірки наявності значення в змінній середовища з ім'ям <code>IGNORE_CASE</code>, як показано в Блоці коду 12-23.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::env;
// --snip--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 12-23: Перевірка, чи є якесь значення в змінній середовища з назвою <code>IGNORE_CASE</code></span></p>
<p>Тут ми створюємо нову змінну <code>ignore_case</code>. Щоб встановити її значення, нам потрібно викликати функцію <code>env::var</code> та передати їй ім'я змінної середовища <code>IGNORE_CASE</code>. Функція <code>env::var</code> повертає <code>Result</code>, який буде вдалим варіантом <code>Ok</code>, що містить значення змінної середовища, якщо їй встановлено будь-яке значення. Він поверне варіант <code>Err</code> якщо змінна середовища не встановлена.</p>
<p>Ми використовуємо метод <code>is_ok</code> на <code>Result</code>, щоб перевірити чи встановлена змінна середовища, яка буде означати, що програма буде здійснювати чутливий до регістру пошук. Якщо змінній середовища <code>IGNORE_CASE</code> нічого не встановлено, <code>is_ok</code> поверне false та програма виконуватиме чутливий до регістру пошук. Нас не хвилює <em>значення</em> змінної середовища, лише чи воно встановлене чи ні, тому ми перевіряємо з <code>is_ok</code> замість використовування <code>unwrap</code>, <code>expect</code>, або будь-якого іншого метода, який ми бачили в <code>Result</code>.</p>
<p>Ми передаємо значення змінної <code>ignore_case</code> екземпляру <code>Config</code>, щоб функція <code>run</code> могла прочитати це значення і вирішити, чи викликати <code>search_case_insensitive</code> або <code>search</code>, як ми реалізували у Блоці коду 12-22.</p>
<p>Спробуймо! Спочатку ми запустимо нашу програму без встановленої змінної середовища та з запитом <code>to</code>, яке буде зіставлятися з будь-яким рядком, який містить слово “to” малими літерами:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Схоже, що це все ще працює! Тепер запустимо програму з <code>IGNORE_CASE</code> встановленим на <code>1</code>, але із тим самим запитом <code>to</code>.</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>Якщо ви використовуєте PowerShell, вам потрібно встановити змінну оточення і запустити програму як окремі команди:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>Це зробить <code>IGNORE_CASE</code> збереженим до кінця вашої сесії в консолі. Це налаштування можна вимкнути з командлетом <code>Remove-Item</code>:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>Ми повинні отримати рядки, які містять &quot;to&quot; та які мають бути великими літерами:</p>
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Чудово, ми також отримуємо рядки, що містять &quot;To&quot;! Наша програма <code>minigrep</code> тепер може робити нечутливий до регістру пошук контрольований змінною середовища. Тепер ви знаєте як керувати опціями встановленими із використанням як аргументів командного рядка, так і змінних середовища.</p>
<p>Деякі програми дозволяють аргументи <em>та</em> змінні середовища для однієї й тієї ж конфігурації. У цих випадках програма вирішує, що з цього має перевагу. Для іншої самостійної вправи, спробуйте контролювати чутливість до регістру через або аргумент командного рядка або змінну середовища. Вирішуйте, чи аргумент командного рядка має бути пріоритетніше чи змінна середовища, якщо програма запускається як чутлива до регістра, а інша як нечутлива.</p>
<p>Модуль <code>std::env</code> містить ще багато корисного в роботі зі змінними середовища: перегляньте її документацію, щоб побачити що є можливим.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Написання-Повідомлень-Про-Помилки-в-standard-error-Замість-Стандартного-Виводу"><a class="header" href="#Написання-Повідомлень-Про-Помилки-в-standard-error-Замість-Стандартного-Виводу">Написання Повідомлень Про Помилки в Standard Error Замість Стандартного Виводу</a></h2>
<p>Наразі ми записуємо увесь наш вивід в термінал використовуючи макрос <code>println!</code>. В більшості терміналів є два типи виводу: <em>standard output</em> (<code>stdout</code>) для загальної інформації та <em>standard error</em> (<code>stderr</code>) для повідомлень про помилки. Це розділення дозволяє користувачам направити вдалий вивід програми в файл, але все ще виводити повідомлення про помилки на екрані.</p>
<p>The <code>println!</code> macro is only capable of printing to standard output, so we have to use something else to print to standard error.</p>
<h3 id="Перевірка-Де-Написані-Помилки"><a class="header" href="#Перевірка-Де-Написані-Помилки">Перевірка Де Написані Помилки</a></h3>
<p>Спочатку, нумо побачимо, як контент який <code>minigrep</code> виводить в консолі наразі записується в стандартний вивід, включаючи будь-які повідомлення про помилки, які замість цього ми хочемо записувати в Standard Error. Ми зробимо це перенаправивши потік стандартного виводу в файл водночас із навмисним спричиненням помилки. Ми не будемо перенаправляти стандартний помилковій потік, тому будь-який контент відправлений в Standard Error буде продовжувати показуватися на екрані.</p>
<p>Очікується, що програми командного рядка надсилатимуть помилкові повідомлення в потік Standard Error, щоб ми все ще могли бачити помилкові повідомлення на екрані, навіть якщо ми перенаправляємо потік стандартного виводу в файл. Наразі наша програма не добре налаштована: ми побачимо, як вона збереже вивід помилкового повідомлення в файл натомість!</p>
<p>Щоб продемонструвати цю поведінку, ми запустимо програму з <code>&gt;</code> і шляхом до файлу, <em>output.txt</em>, якому ми хочемо перенаправити потік стандартного виводу. Ми не будемо передавати аргументи, що спричинить помилку:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p>Синтаксис <code>&gt;</code> вказує shell писати вміст стандартного виводу в <em>output.txt</em> замість екрана. Ми не бачимо помилкове повідомлення, яке ми очікували виведеним на екран, тому це означає, що воно опинилося в файлі. Це те, що містить <em>output.txt</em>:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Так, наше помилкове повідомлення виводиться в консолі стандартного виводу. Це набагато корисніше для таких помилкових повідомлень, щоб вони виводилися в консолі Standard Error та щоб тільки дані від вдалих запусків опинялися в файлі. Ми змінимо це.</p>
<h3 id="Вивід-в-Консолі-Помилок-в-standard-error"><a class="header" href="#Вивід-в-Консолі-Помилок-в-standard-error">Вивід в Консолі Помилок в Standard Error</a></h3>
<p>Ми використаємо код в Блоці Коду 12-24 для зміни виводу помилкових повідомлень в консолі. Через рефакторінг, який ми робили раніше в цьому розділі, увесь код який виводить помилкові повідомлення перебуває в одній функції, <code>main</code>. Стандартна бібліотека надає макрос <code>eprintln!</code> який виводить в консолі потоку Standard Error, тому змінимо два місця, де ми викликаємо <code>println!</code>, використовуючи замість цього <code>eprintln!</code> для виводу в консолі.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {e}&quot;);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">Блок коду 12-24: Запис повідомлень про помилки до стандартного помилкового виводу, замість стандартного, за допомогою <code>eprintln!</code></span></p>
<p>Тепер запустимо програму ще раз таким же чином, без будь-яких аргументів і перенаправивши стандартний вивід за допомогою <code>&gt;</code>:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Тепер ми бачимо помилку на екрані і <em>output.txt</em> нічого не містить, і саме такої поведінки ми очікуємо від програм командного рядка.</p>
<p>Запустімо програму ще раз з аргументами, які не викликають помилки, але все ж таки перенаправивши стандартний вивід у файл, ось так:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt &gt; output.txt
</code></pre>
<p>Ми не побачимо жодного виводу в терміналі та <em>output.txt</em> буде містити наші результати:</p>
<p><span class="filename">Файл: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Це демонструє, що тепер ми використовуємо стандартний вивід для успішного виводу і стандартну помилку для виводу помилок у відповідних випадках.</p>
<h2 id="Підсумок-11"><a class="header" href="#Підсумок-11">Підсумок</a></h2>
<p>В цьому розділі ми пригадали деякі основні концепти, які ви вивчили раніше та розглянули як виконувати базові I/O операції в Rust. Використовуючи аргументи командного рядка, файли, змінні середовища та макрос <code>eprintln!</code> для виведення помилок в консолі, тепер ви готові написати застосунок для командного рядка. Поєднавши це з концептами з попередніх розділів, ваш код буде добре організованим, ефективно збирати дані в відповідні структури даних, вдало обробляти помилки та буде добре перевіреним.</p>
<p>Далі ми детальніше розглянемо деякі функції Rust, на які вплинули функціональні мови: замикання та ітератори.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Функціональні-можливості-мови-Ітератори-та-Замикання"><a class="header" href="#Функціональні-можливості-мови-Ітератори-та-Замикання">Функціональні можливості мови: Ітератори та Замикання</a></h1>
<p>Розробка мови Rust була натхненна багатьма мовами та техніками, і суттєвий вплив на неї мало <em>функціональне програмування</em>. Програмування у функціональному стилі зазвичай вбачає у собі використання функцій як значень, передаючи їх в аргументи, повертаючи як результат інших функцій, присвоюючи до змінних для подальшого застосування і так далі.</p>
<p>У цьому розділі, ми не обговорюватимемо питання того, що є функціональним програмуванням, а що ні. Натомість, ми обговоримо деякі можливості Rust, що схожі на можливості багатьох мов, які часто називають функціональними.</p>
<p>Зокрема, ми розглянемо:</p>
<ul>
<li><em>Замикання</em>, функціональну конструкцію, яку можна зберігати у змінній</li>
<li><em>Ітератори</em>, спосіб обробки послідовності елементів</li>
<li>Як використовувати замикання та ітератори для покращення операцій вводу/виводу для проекту з 12 розділу</li>
<li>Швидкість замикань та ітераторів (Спойлер: вони швидші ніж ви думаєте!)</li>
</ul>
<p>Ми вже розглянули деякі можливості Rust, такі як зіставлення зі шаблоном та енуми, які теж були створені з оглядом на ідеї функціонального стилю. Оскільки опановування замикань та ітераторів це важлива частина написання ідіоматичного та швидкого коду на Rust, ми виділимо для них увесь цей розділ.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a></p>
<h2 id="Замикання-анонімні-функції-що-захоплюють-своє-середовище"><a class="header" href="#Замикання-анонімні-функції-що-захоплюють-своє-середовище">Замикання: анонімні функції, що захоплюють своє середовище</a></h2>
<p>У Rust замикання -- це анонімні функції, які можна зберігати у змінній або передавати як аргументи до інших функцій. Ви можете створити замикання в одному місці, а потім викликати деінде для обчислення в іншому контексті. На відміну від функції, замикання здатні використовувати значення з області видимості в якій вони були визначені. Ми продемонструємо, як наявність замикань дозволяє повторно використовувати код та змінювати поведінку програми.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a></p>
<h3 id="Захоплення-середовища-за-допомогою-замикань"><a class="header" href="#Захоплення-середовища-за-допомогою-замикань">Захоплення середовища за допомогою замикань</a></h3>
<p>Спочатку ми розглянемо, як можна використовувати замикання для фіксації значень середовища, в якому вони визначені, для подальшого використання. Ось сценарій: Час від часу, наша компанія по виробництву футболок роздає ексклюзивну футболку, випущену ексклюзивним тиражем, комусь із нашого списку розсилки як рекламу. Люди зі списку розсилки можуть за бажанням додати свій улюблений колір до свого профілю. Якщо людина, якій надіслали безплатну футболку, обрала свій улюблений колір, вона отримає футболку такого ж кольору. Якщо людина не зазначила свій улюблений колір, то вона отримає футболку такого кольору, якого в компанії найбільше всього.</p>
<p>Існує багато способів це реалізувати. Для цього прикладу, ми використаємо енум <code>ShirtColor</code>, який складається з варіантів <code>Red</code> та <code>Blue</code> (обмежимо кількість доступних кольорів для простоти). Ми представлятимемо товарні запаси компанії за допомогою структури <code>Inventory</code>, яка має поле, що зветься <code>shirts</code>, яке містить <code>Vec&lt;ShirtColor&gt;</code>, що представляє кольори наявних на складі футболок. Метод <code>giveaway</code>, визначений для <code>Inventory</code>, отримує опціональний бажаний колір футболки для вручення переможцю та повертає колір футболки, яку цей переможець отримає. Ця ситуація показана в Блоці коду 13-1:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        &quot;The user with preference {:?} gets {:?}&quot;,
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        &quot;The user with preference {:?} gets {:?}&quot;,
        user_pref2, giveaway2
    );
}
</code></pre>
<p><span class="caption">Блок коду 13-1: роздача подарунків у компанії по виробництву футболок</span></p>
<p>Змінна <code>store</code>, визначена в <code>main</code>, містить дві сині футболки і одну червону футболку, які лишилися для роздачі у рекламній акції. Ми викликаємо метод <code>giveaway</code> для користувача, що віддає перевагу червоній футолці, і для користувача, що не має особливих побажань.</p>
<p>Знову ж таки, цей код може бути реалізований багатьма способами, і тут, щоб сфокусуватися на замиканнях, ми дотримуватимемося концепцій, які ви вже вивчили, окрім тіла методу <code>giveaway</code>, який використовує замикання. У методі <code>giveaway</code> ми отримуємо параметром побажання типу <code>Option&lt;ShirtColor&gt;</code> і викликаємо на <code>user_preference</code> метод <code>unwrap_or_else</code>. Метод <a href="../std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code> для <code>Option&lt;T&gt;</code></a><!-- ignore --> визначений у стандартній бібліотеці. Він приймає один аргумент: замикання без аргументів, що повертає значення типу <code>T</code> (того ж типу, що міститься у варіанті <code>Some</code> <code>Option&lt;T&gt;</code>, у цьому випадку <code>ShirtColor</code>). Якщо <code>Option&lt;T&gt;</code> є варіантом <code>Some</code>, <code>unwrap_or_else</code> поверне значення, що міситься у <code>Some</code>. Якщо ж <code>Option&lt;T&gt;</code> є варіантом <code>None</code>, <code>unwrap_or_else</code> викликає замикання і повертає значення, повернене з замикання.</p>
<p>Ми зазначаємо вираз замикання <code>|| self.most_stocked()</code>аргументом <code>unwrap_or_else</code>. Це замикання не приймає параметрів (якби замикання мало параметри, вони б з'явилися між вертикальними лініями). Тіло замикання викликає <code>self.most_stocked()</code>. Тут ми визначаємо замикання, і реалізація <code>unwrap_or_else</code> обчислить це замикання пізніше, якщо знадобиться його результат.</p>
<p>Виконання цього коду виводить:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>Тут один цікавий момент полягає в тому, що ми вже передали замикання, яке викликає <code>self.most_stocked()</code> для поточного екземпляра <code>Inventory</code>. Стандартній бібліотеці непотрібно нічого знати про типи <code>Inventory</code> або <code>ShirtColor</code>, які ми визначили, або про логіку, яку ми бажаємо використати у даному сценарії. Замикання захоплює немутабельне посилання на езкемпляр <code>Inventory</code> <code>self</code> і передає його з написаним нами кодом у метод <code>unwrap_or_else</code>. Функції, з іншого боку, не можуть захоплювати своє середовище у такий спосіб.</p>
<h3 id="Виведення-типів-та-анотації-для-замикань"><a class="header" href="#Виведення-типів-та-анотації-для-замикань">Виведення типів та анотації для замикань</a></h3>
<p>Між функціями та замиканнями існує більше відмінностей. Замикання зазвичай не потребують анотації типів параметрів чи типу, який вони повертають, на відміну від функцій <code>fn</code>. Анотації типів потрібні функціям, бо типи є частиною явного інтерфейсу, відкритого вашим користувачам. Жорстке визначення інтерфейсу важливе для забезпечення того, щоб всі погоджувались з тим, які значення функція приймає та повертає. Замикання, з іншого боку, не використовуються у подібному відкритому інтерфейсі: вони зберігаються у змінних і використовуються без назв і відкривання їх користувачам ваших бібліотек.</p>
<p>Замикання зазвичай короткі та актуальні тільки у конкретному контексті, а не в будь-якому довільному сценарії. У цих обмежених контекстах компілятор може вивести типи параметрів і типу, що повертається, так само як може вивести типи більшості змінних (трапляються рідкісні випадки, коли компілятор потребує також анотації типів замикань).</p>
<p>Як і зі змінними, ми можемо за бажання додати анотації типів, коли хочемо збільшити виразність і ясність ціною більшої багатослівності, ніж потрібно. Анотування типів для замикання виглядатиме як визначення, наведене у Блоці коду 13-2. У цьому прикладі ми визначаємо замикання і зберігаємо його у змінній замість визначення замикання у місці, де ми передаємо його як аргумент, як ми робили у Блоці коду 13-1.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!(&quot;Today, do {} pushups!&quot;, expensive_closure(intensity));
</span><span class="boring">        println!(&quot;Next, do {} situps!&quot;, expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Today, run for {} minutes!&quot;,
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 13-2: додавання необов'язкових анотацій типу параметра і значення, яке повертає замикання</span></p>
<p>Із анотаціями типів синтаксис замикань виглядає більш схожим на синтаксис функцій. Тут ми визначаємо функцію, що додає 1 до свого параметра і замикання, що має таку саму поведінку, для порівняння. Ми додали кілька пробілів для вирівнювання відповідних частин. Це ілюструє, чим синтаксис замикань подібний до синтаксису функцій, за виключенням використання вертикальних ліній і обсягу необов'язкового синтаксису:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>У першому рядку визначення функції, а в другому анотоване визначення замикання. На третьому рядку ми прибираємо анотацію типу з визначення замикання. На четвертому рядку ми прибираємо дужки, які є опціональними через те, що замикання містить в собі тільки один вираз. Усе це є коректними визначеннями, які будуть демонструвати під час їх виклику одну й ту саму поведінку. Рядки <code>add_one_v3</code> та <code>add_one_v4</code> вимагають, щоб замикання викликали для компіляції, бо типи будуть виведені з того, як їх використовують. Це схоже на те, як <code>let v = Vec::new();</code> потребує або анотацію типів, або додати значення певного типу у <code>Vec</code>, щоб Rust міг вивести тип.</p>
<p>Для визначень замикань компілятор виведе один конкретний тип для кожного параметра і для значення, що повертається. Наприклад, у Блоці коду 13-3 показано визначення замикання, що повертає значення, переданого йому як параметр. Це замикання не дуже корисне, окрім як для цього прикладу. Зауважте, що ми не додавали анотації типів до визначення. Оскільки тут немає анотації типів, ми можемо викликати замикання для будь-якого типу, що ми тут вперше і зробили з <code>String</code>. Якщо ми потім спробуємо викликати <code>example_closure</code> з цілим параметром, то дістанемо помилку.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from(&quot;hello&quot;));
    let n = example_closure(5);
<span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 13-3: спроба викликати замикання, чиї типи вже виведені, із двома різними типами</span></p>
<p>Компілятор повідомляє про таку помилку:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^- help: try using a conversion method: `.to_string()`
  |                             |
  |                             expected struct `String`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
</code></pre>
<p>Коли ми уперше викликали <code>example_closure</code> зі значенням <code>String</code>, компілятор вивів, що тип <code>x</code> і тип, що повертається із замикання, як <code>String</code>. Ці типи були зафіксовані для замикання <code>example_closure</code>, і ми отримаємо помилку типу, коли ще раз намагаємося використати інший тип для цього ж замикання.</p>
<h3 id="Захоплення-посилань-чи-переміщення-володіння"><a class="header" href="#Захоплення-посилань-чи-переміщення-володіння">Захоплення посилань чи переміщення володіння</a></h3>
<p>Замикання можуть захоплювати значення зі свого середовища у три способи, що прямо відповідають трьом способам передачі параметра у функцію: немутабельне позичання, мутабельне позичання і взяття володіння. Замикання вирішує, яким способом скористатися, виходячи з того, що тіло функції робить із захопленими значеннями.</p>
<p>У Блоці коду 13-4 ми визначаємо замикання, яке захоплює немутабельне посилання на вектор з назвою <code>list</code>, тому що йому потрібно лише немутабельне посилання для виведення значення:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {:?}&quot;, list);

    let only_borrows = || println!(&quot;From closure: {:?}&quot;, list);

    println!(&quot;Before calling closure: {:?}&quot;, list);
    only_borrows();
    println!(&quot;After calling closure: {:?}&quot;, list);
}
</code></pre></pre>
<p><span class="caption">Блок коду 13-4: визначення і виклик замикання, що захоплює немутабельне посилання</span></p>
<p>Цей приклад також ілюструє, що змінна може бути зв'язана з визначенням замикання, і ми можемо пізніше викликати замикання, використовуючи назву змінної та дужки та, якби назва змінної була назвою функції.</p>
<p>Оскільки ми можемо мати одночасно декілька немутабельних посилань на <code>list</code>, до нього можливий доступ до визначення замикання, після визначення, але до виклику замикання і після виклику замикання. Цей код компілюється, виконується і виводить:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p>Далі в Блоці коду 13-5 ми змінюємо тіло замикання, щоб воно додавало елемент до вектора <code>list</code>. Це замикання тепер захоплює мутабельне посилання:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {:?}&quot;, list);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!(&quot;After calling closure: {:?}&quot;, list);
}
</code></pre></pre>
<p><span class="caption">Блок коду 13-5: визначення і виклик замикання, що захоплює мутабельне посилання</span></p>
<p>Цей код компілюється, виконується і виводить:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p>Зверніть увагу, що тепер немає <code>println!</code> між визначенням і викликом замикання <code>borrows_mutably</code>: коли визначається <code>borrows_mutably</code>, воно захоплює мутабельне посилання на <code>list</code>. Ми не використовуємо замикання знову після його виклику, тож мутабельне позичання закінчується. Між визначенням замикання і його викликом не дозволене немутабельне позичання, потрібне для виведення, оскільки ніякі інші позичання не дозволені, коли є немутабельне позичання. Спробуйте додати туди <code>println!</code>, щоб побачити, яке повідомлення про помилку ви дістанете!</p>
<p>Якщо ви хочете змусити замикання прийняти володіння значеннями, яке воно використовує у середовищі навіть якщо тіло замикання не обов'язково потребує володіння, ви можете використати ключове слово <code>move</code> перед списком параметрів.</p>
<p>Ця техніка особливо корисна при передачі замикання новому потоку, щоб переміщеними даними володів цей новий потік. Ми обговоримо потоки і нащо вам хотілося б користуватися ними у Розділі 16, коли ми говоримо про одночасне виконання, але поки що давайте коротко дослідимо створення нового потоку за допомогою замикання, що вимагає ключове слово <code>move</code>. Блок коду 13-6 показує змінений Блок коду 13-4, що виводить вектор у новому потоці, а не у головному:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

// ANCHOR: here
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(&quot;Today, do {} pushups!&quot;, expensive_closure(intensity));
        println!(&quot;Next, do {} situps!&quot;, expensive_closure(intensity));
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}
// ANCHOR_END: here

fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
</code></pre></pre>
<p><span class="caption">Блок коду 13-6: Використання <code>move</code> для того, щоб змусити замикання для потоку взяти володіння <code>list</code></span></p>
<p>Ми створюємо новий потік, надаючи йому замикання для виконання як аргумент. Тіло замикання виводить список. У Блоці коду 13-4 це замикання захоплює лише <code>list</code> за допомогою немутабельного посилання, бо це найменша кількість доступу до <code>list</code>, потрібна для його виведення. У цьому прикладі, попри те, що тіло замикання все ще потребує лише немутабельного посилання, нам потрібно вказати, що <code>list</code> слід перемістити у замикання, додавши ключове слово <code>move</code> на початку визначення замикання. Новий потік може завершитися до завершення решти головного потоку, чи основний потік може завершитися першим. Якщо основний потік утримував володіння <code>list</code>, але завершився до завершення нового потоку і скинув <code>list</code>, немутабельне посилання у тому потоці стає некоректним. Відповідно, компілятор вимагає, щоб <code>list</code> буде переміщений у замикання, що передається у новий потік, щоб посилання буде коректним. Спробуйте видалити ключове слово <code>move</code> або використати <code>list</code> в основному потоці після закриття, щоб побачити помилки компілятора, які ви отримуєте!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a></p>
<h3 id="Переміщення-захоплених-значень-із-замикань-і-трейти-fn"><a class="header" href="#Переміщення-захоплених-значень-із-замикань-і-трейти-fn">Переміщення захоплених значень із замикань і трейти <code>Fn</code></a></h3>
<p>Коли замикання захопило посилання чи володіння значенням у місці, де це замикання визначене (таким чином впливаючи на те, що було переміщено <em>в</em> замикання), код у тілі замикання визначає, що відбувається з посиланнями або значеннями, коли пізніше замикання обчислюється (тим самим впливаючи на те, що буде переміщено <em>із</em> замикання). Тіло замикання може робити одне з: перемістити захоплене значення із замикання, змінити захоплене значення, не перемішати ані змінювати значення, чи взагалі нічого не захоплювати з середовища.</p>
<p>Те, як замикання захоплює і обробляє значення з середовища, впливає на те, які трейти реалізовує замикання, а трейти - спосіб функціям і структурам зазначити, які види замикань вони можуть використовувати. Замикання автоматично реалізують один, два чи всі три ці трейти <code>Fn</code> із накопиченням, залежно від того, як тіло замикання поводиться зі значеннями:</p>
<ol>
<li><code>FnOnce</code> застосовується до замикань, які можна викликати один раз. Усі замикання реалізовують щонайменше цей трейт, бо всі замикання можна викликати. Замикання, що переміщує захоплені значення зі свого тіла можуть реалізовувати лише <code>FnOnce</code> і жодного іншого з трейтів <code>Fn</code>, бо їх можна викликати лише один раз.</li>
<li><code>FnMut</code> застосовується до замикань, які не переміщують захоплені значення зі свого тіла, але можуть їх змінювати. Ці замикання можуть бути викликані більше ніж один раз.</li>
<li><code>Fn</code> застосовується до замикань, що не переміщують захоплені значення зі свого тіла і їх не змінюють, а також до замикань, що нічого не захоплюють із середовища. Ці замикання можуть бути викликані більше одного разу без змін середовища, що важливо у таких випадках, як одночасний виклик замикання багато разів.</li>
</ol>
<p>Погляньмо на визначення методу <code>unwrap_or_else</code> для <code>Option&lt;T&gt;</code>, який ми використовували в Блоці Коду 13-1:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}
</code></pre>
<p>Згадайте, що <code>T</code> - це узагальнений тип, що представляє тип значення з варіанта <code>Some</code> із <code>Option</code>. Цей тип <code>T</code> також є типом, який повертає поверненим функція <code>unwrap_or_else</code>: код, що викликає <code>unwrap_or_else</code>, наприклад, для <code>Option&lt;String&gt;</code> отримає <code>String</code>.</p>
<p>Далі, зверніть увагу, що функція <code>unwrap_or_else</code> має додатковий параметр узагальненого типу <code>F</code>. Тип <code>F</code> є типом параметра <code>f</code>, який є замиканням, яке ми надаємо під час виклику <code>unwrap_or_else</code>.</p>
<p>Трейтове обмеження, вказане для узагальненого типу <code>F</code>, <code>FnOnce() -&gt; T</code>, що означає, що <code>F</code> має бути можливо викликати один раз, вона не приймає аргументи, і повертає <code>T</code>. Використання <code>FnOnce</code> у трейтовому обмеженні виражає обмеження, що <code>unwrap_or_else</code> збирається викликати <code>f</code> не більше одного разу. У тілі <code>unwrap_or_else</code>, як ми можемо бачити, якщо <code>Option</code> є <code>Some</code>, <code>f</code> не буде викликано. Якщо <code>Option</code> є <code>None</code>, <code>f</code> буде викликана один раз. Оскільки всі замикання реалізують <code>FnOnce</code>, <code>unwrap_or_else</code> приймає найрізноманітніші типи замикань і гнучка настільки, наскільки це можливо.</p>
<blockquote>
<p>Примітка: функції також можуть реалізовувати усі три трейти <code>Fn</code>. Якщо те, що ми хочемо зробити, не потребує захоплення значення з середовища, ми можемо використовувати ім'я функції замість замикання там, де нам потрібне щось, що реалізує один з трейтів <code>Fn</code>. Скажімо, для значення <code>Option&lt;Vec&lt;T&gt;&gt;</code> ми можемо викликати <code>unwrap_or_else(Vec:new)</code>, щоб отримати новий порожній вектор, якщо значення буде <code>None</code>.</p>
</blockquote>
<p>Тепер подивімося на метод зі стандартної бібліотеки <code>sort_by_key</code>, визначений для слайсів, щоб побачити, як це відрізняється від <code>unwrap_or_else</code>, і чому <code>sort_by_key</code> використовує <code>FnMut</code> замість <code>FnOnce</code> як трейтове обмеження. Замикання приймає один аргумент у формі посилання на поточний елемент у слайсі, і повертає значення типу <code>K</code>, яке можна впорядкувати. Ця функція корисна, коли вам треба відсортувати слайс за певним атрибутом кожного елемента. У Блоці коду 13-7 ми маємо список екземплярів <code>Rectangle</code> і використовуємо <code>sort_by_key</code>, щоб впорядкувати їх за атрибутом <code>width</code> за зростанням:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!(&quot;{:#?}&quot;, list);
}
</code></pre></pre>
<p><span class="caption">Блок коду 13-7: Використання <code>sort_by_key</code> для впорядкування прямокутників за шириною</span></p>
<p>Цей код виведе:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p><code>sort_by_key</code> визначено для замикання <code>FnMut</code> тому, що вона викликає замикання кілька разів: один раз для кожного елемента у слайсі. Замикання <code>|r| r.width</code> не захоплює, не змінює і не переміщує нічого з його середовища, тож це відповідає вимогам трейтового обмеження.</p>
<p>На противагу цьому, у Блоці коду 13-8 наведено приклад замикання, яке реалізує тільки трейт <code>FnOnce</code>, тому що воно переміщує значення з середовища. Компілятор не дозволить нам використовувати це замикання у <code>sort_by_key</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from(&quot;by key called&quot;);

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!(&quot;{:#?}&quot;, list);
}
</code></pre>
<p><span class="caption">Блок коду 13-8: спроба використати замикання <code>FnOnce</code> у <code>sort_by_key</code></span></p>
<p>Це надуманий, заплутаний спосіб (який не працює) спробувати підрахувати кількість викликів <code>sort_by_key</code> при сортуванні <code>list</code>. Цей код намагається виконати підрахунок, виштовхуючи <code>value</code> - <code>String</code> з середовища замикання у вектор <code>sort_operations</code>. Замикання захоплює <code>value</code>, потім переміщує <code>value</code> із замикання, передаючи володіння <code>value</code> до вектора <code>sort_operations</code>. Це замикання може бути викликане один раз; спроба викликати вдруге не спрацює, оскільки <code>value</code> більше не буде в середовищі, щоб занести його до <code>sort_operations</code> знову! Таким чином це замикання реалізує лише <code>FnOnce</code>. Коли ми намагаємося скомпілювати цей код, то отримуємо помилку про те, що <code>value</code> не можна перемістити із замикання, оскільки замикання має реалізовувати <code>FnMut</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:27:30
   |
24 |       let value = String::from(&quot;by key called&quot;);
   |           ----- captured outer variable
25 | 
26 |       list.sort_by_key(|r| {
   |  ______________________-
27 | |         sort_operations.push(value);
   | |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
28 | |         r.width
29 | |     });
   | |_____- captured by this `FnMut` closure

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` due to previous error
</code></pre>
<p>Помилка вказує на рядок у тілі замикання, що переміщує <code>value</code> з середовища. Щоб виправити це, нам потрібно змінити тіло замикання так, щоб воно не переміщувало значення з середовища. Полічити кількість викликів <code>sort_by_key</code>, утримуючи лічильник у середовищі та збільшуючи його значення у тілі замикання є прямішим шляхом для цього обчислення. Замикання у Блоці коду 13-9 працює з <code>sort_by_key</code>, оскільки воно містить лише мутабельне посилання на лічильник <code>num_sort_operations</code> і тому може бути викликане більше ніж один раз:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!(&quot;{:#?}, sorted in {num_sort_operations} operations&quot;, list);
}
</code></pre></pre>
<p><span class="caption">Блок коду 13-9: використання замикання <code>FnMut</code> у <code>sort_by_key</code> дозволене</span></p>
<p>Трейти <code>Fn</code> мають важливе значення при визначенні або використанні функцій або типів, які використовують замикання. У наступному підрозділі ми обговоримо ітератори. Багато методів ітератора приймають аргументи-замикання, тому не забувайте, що дізналися про замикання, коли ми продовжимо!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Обробка-послідовностей-елементів-за-допомогою-ітераторів"><a class="header" href="#Обробка-послідовностей-елементів-за-допомогою-ітераторів">Обробка послідовностей елементів за допомогою ітераторів</a></h2>
<p>Шаблон ітератора дозволяє вам виконати певну задачу з послідовністю елементів по черзі. Ітератор відповідає за логіку ітерації по елементах і визначення, коли послідовність закінчується. Коли ви користуєтесь ітераторами, вам не треба самостійно реалізовувати цю логіку.</p>
<p>У Rust ітератори є <em>лінивими</em>, тобто вони нічого не роблять до того моменту, коли ви викличете метод, що поглине ітератор і використає його. Наприклад, код у Блоці коду 13-10 створює ітератор по елементах вектора <code>v1</code>, викликавши метод <code>iter</code>, визначений для <code>Vec&lt;T&gt;</code>. Цей код як такий не робить нічого корисного.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 13-10: створення ітератора</span></p>
<p>Ітератор зберігається у змінній <code>v1_iter</code>. Після того, як ми створили ітератор, ми можемо використовувати його у різні способи. У Блоці коду 3-5 з Розділу 3 ми ітерували по масиву за допомогою циклу <code>for</code>, щоб виконати певний код на кожному елементі. Під капотом тут неявно був створений і поглинутий ітератор, але до цього часу ми не звертали уваги на те, як саме це працює.</p>
<p>У прикладі з Блоку коду 13-11 ми відокремлюємо створення ітератора від його використання в циклі <code>for</code>. Коли цикл <code>for</code> викликають з ітератором у <code>v1_iter</code>, кожен елемент у ітераторі використовується одній ітерації циклу, який виводить кожне значення.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&quot;Got: {}&quot;, val);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 13-11: використання ітератора у циклі <code>for</code></span></p>
<p>In languages that don’t have iterators provided by their standard libraries, you would likely write this same functionality by starting a variable at index 0, using that variable to index into the vector to get a value, and incrementing the variable value in a loop until it reached the total number of items in the vector.</p>
<p>Ітератори обробляють всю цю логіку за вас, скорочуючи код, який ви потенційно можете зіпсувати. Ітератори дають вам більше гнучкості для використання тієї ж логіки з різними типами послідовностей, а не лише структурами даних, які ви можете індексувати, такими як вектори. Розгляньмо, як ітератори це роблять.</p>
<h3 id="Трейт-iterator-і-метод-next"><a class="header" href="#Трейт-iterator-і-метод-next">Трейт <code>Iterator</code> і метод <code>next</code></a></h3>
<p>Усі ітератори реалізують трейт, що зветься <code>Iterator</code>, визначений у стандартній бібліотеці. Визначення цього трейту виглядає ось так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // методи зі стандартною реалізацією пропущені
}
<span class="boring">}
</span></code></pre></pre>
<p>Зверніть увагу, що це визначення використовує новий синтаксис: <code>type Item</code> і <code>Self::Item</code>, які визначають <em>асоційований тип</em> цього трейта. Ми глибше поговоримо про асоційовані типи у Розділі 19. Поки що, все, що вам слід знати - це те, що цей код каже, що реалізація трейту <code>Iterator</code> також вимагає, щоб ви визначили тип <code>Item</code>, і цей тип <code>Item</code> використовується як тип, що повертається методом <code>next</code>. Іншими словами, тип <code>Item</code> буде типом, повернутим з ітератора.</p>
<p>Трейт <code>Iterator</code> потребує від того, хто його реалізовує, визначення лише одного методу: методу <code>next</code>, який повертає за раз один елемент ітератора, обгорнутий у <code>Some</code> і, коли ітерація закінчиться, повертає <code>None</code>.</p>
<p>Ми можемо викликати метод <code>next</code> для ітераторів безпосередньо; Блок коду 13-12 демонструє, які значення повертаються повторюваними викликами <code>next</code> для ітератора, створеного з вектора.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 13-12: виклик методу <code>next</code> для ітератора</span></p>
<p>Зверніть увагу, що нам потрібно зробити <code>v1_iter</code> мутабельним: виклик методу <code>next</code> для ітератора змінює його внутрішній стан, який використовується для відстеження, де він знаходиться в послідовності. Іншими словами, цей код <em>поглинає</em>, чи використовує, ітератор. Кожен виклик <code>next</code> з'їдає елемент з ітератора. Нам не треба було робити <code>v1_iter</code> мутабельним, коли ми використали його в циклі <code>for</code>, бо цикл взяв володіння <code>v1_iter</code> і зробив його мутабельним за лаштунками.</p>
<p>Також зверніть увагу, що значення, які ми отримуємо від викликів <code>next</code>, є немутабельними посиланнями на значення у векторі. Метод <code>iter</code> створює ітератор по незмінних посиланнях. Якщо ми хочемо створити ітератор, який приймає володіння <code>v1</code> і повертає значення, що належать нам, ми можемо викликати <code>into_iter</code> замість <code>iter</code>. Аналогічно, якщо ми хочемо ітерувати по мутабельних посиланнях, ми можемо викликати <code>iter_mut</code> замість <code>iter</code>.</p>
<h3 id="Методи-що-поглинають-ітератор"><a class="header" href="#Методи-що-поглинають-ітератор">Методи, що поглинають ітератор</a></h3>
<p>Трейт <code>Iterator</code> має ряд різних методів з реалізаціями по замовчуванню що надаються стандартною бібліотекою; ви можете дізнатися про ці методи в стандартній документації API для трейта <code>Iterator</code>. Деякі з цих методів викликають у своєму визначенні метод <code>next</code>, чому і необхідно визначити метод <code>next</code> при реалізації трейта <code>Iterator</code>.</p>
<p>Методи, що викликають <code>next</code>, звуться <em>поглинаючими адапторами</em>, бо їх виклик використовує ітератор. Один із прикладів - це метод <code>sum</code>, який бере володіння ітератором і ітерує по елементах, раз за разом викликаючи <code>next</code>, таким чином поглинаючи ітератор. Під час ітерації він додає кожен елемент до поточної загальної суми і повертає загальну суму, коли ітерація завершена. Блок коду 13-13 має тест, що ілюструє використання методу <code>sum</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 13-13: виклик методу <code>sum</code> для отримання загальної суми усіх елементів ітератора</span></p>
<p>Нам не дозволено використовувати <code>v1_iter</code> після виклику <code>sum</code>, оскільки <code>sum</code> перебирає володіння ітератором, на якому його викликано.</p>
<h3 id="Методи-що-створюють-інші-ітератори"><a class="header" href="#Методи-що-створюють-інші-ітератори">Методи, що створюють інші ітератори</a></h3>
<p><em>Адаптери ітераторів</em> - це методи, визначені для трейта <code>Iterator</code>, які не поглинають ітератор. Натомість вони створюють інші ітератори, змінюючи певний аспект оригінального ітератора.</p>
<p>Блок коду 13-14 показує приклад виклику метода-адаптора ітератора <code>map</code>, який приймає замикання, яке викличе для кожного елементу під час ітерації. Метод <code>map</code> повертає новий ітератор, який виробляє модифіковані елементи. Замикання створює новий ітератор, у якому кожен елемент вектора буде збільшено на 1:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 13-14: Виклик адаптора <code>map</code> для створення нового ітератора</span></p>
<p>Однак, цей код видає попередження:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

warning: `iterators` (bin &quot;iterators&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>Код у Блоці коду 13-14 нічого не робить; замикання, яке ми вказали, ніколи не було викликано. Попередження нагадує нам, чому: адаптори ітераторів ліниві, і нам потрібно поглинути ітератор.</p>
<p>Щоб виправити це попередження і поглинути ітератор, ми використаємо метод <code>collect</code>, який ми використовували у Розділі 12 із <code>env::args</code> у Блоці коду 12-1. Цей метод поглинає ітератор і збирає отримані в результаті значення в колекцію.</p>
<p>У Блоці коду 13-15 ми зібрали результати ітерування по ітератору, повернутому викликом <code>map</code>, у вектор. Цей вектор в результаті міститиме всі елементи оригінального вектора, збільшені на 1.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 13-15: виклик методу <code>map</code> для створення нового ітератора і виклик методу <code>collect</code> для поглинання цього нового ітератора і створення вектора</span></p>
<p>Оскільки <code>map</code> приймає замикання, ми можемо вказати будь-яку операцію, яку хочемо виконати з кожним елементом. Це чудовий приклад того, як замикання дозволяють вам встановити певну поведінку, використовуючи поведінку ітерацій, надану трейтом <code>Iterator</code>.</p>
<p>Ви можете з'єднати багато викликів адаптерів ітераторів для виконання складних дій, щоб це було читабельно. Але оскільки всі ітератори є ледачими, ви маєте викликати один з методів, що поглинають адаптер, щоб отримати результати викликів адаптерів ітераторів.</p>
<h3 id="Використання-замикань-що-захоплюють-своє-середовище"><a class="header" href="#Використання-замикань-що-захоплюють-своє-середовище">Використання замикань, що захоплюють своє середовище</a></h3>
<p>Багато адаптерів ітераторів приймають аргументами замикання, і зазвичай замикання, які ми вказуємо аргументами до адаптерів ітераторів будуть замиканнями, що захоплюють своє середовище.</p>
<p>Для цього прикладу ми скористаємося методом <code>filter</code>, що приймає замикання. Замикання отримає елемент з ітератора і повертає <code>bool</code>. Якщо замикання повертає <code>true</code>, значення буде включено в ітерації, вироблені <code>filter</code>. Якщо замикання повертає <code>false</code>, значення не буде включено.</p>
<p>У Блоці коду 13-16 ми використовуємо <code>filter</code> із замиканням, яке захоплює змінну <code>shoe_size</code> зі свого середовища для ітерування по колекції екземплярів структур <code>Shoe</code>. Воно поверне лише взуття зазначеного розміру.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from(&quot;sneaker&quot;),
            },
            Shoe {
                size: 13,
                style: String::from(&quot;sandal&quot;),
            },
            Shoe {
                size: 10,
                style: String::from(&quot;boot&quot;),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from(&quot;sneaker&quot;)
                },
                Shoe {
                    size: 10,
                    style: String::from(&quot;boot&quot;)
                },
            ]
        );
    }
}
</code></pre>
<p><span class="caption">Блок коду 13-16: використання методу <code>filter</code> із замиканням, що захоплює <code>shoe_size</code></span></p>
<p>Функція <code>shoes_in_size</code> приймає володіння вектором взуття і розмір взуття. Вона повертає вектор, що містить лише взуття зазначеного розміру.</p>
<p>У тілі <code>shoes_in_size</code> ми викликаємо <code>into_iter</code> для створення ітератора, що приймає володіння вектором. Тоді ми викликаємо <code>filter</code>, щоб адаптувати ітератор у новий ітератор, що містить лише елементи, для яких замикання повертає <code>true</code>.</p>
<p>Замикання захоплює параметр <code>shoe_size</code> із середовища і порівнює значення із розміром кожної пари взуття, лишаючи тільки взуття зазначеного розміру. Нарешті, виклик <code>collect</code> збирає значення, повернуті адаптованим ітератором, у вектор, який функція повертає.</p>
<p>Тест показує, що коли ми викликаємо <code>shoes_in_size</code>, ми отримуємо назад лише взуття, яке має розмір, що дорівнює вказаному значенню.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Покращуємо-наш-проєкт-з-введеннямвиведенням"><a class="header" href="#Покращуємо-наш-проєкт-з-введеннямвиведенням">Покращуємо наш проєкт з введенням/виведенням</a></h2>
<p>Використовуючи нові знання про ітератори, ми можемо покращити проєкт введення/виведення у Розділі 12, використовуючи ітератори, щоб зробити деякі місця в коді яснішими та виразнішими. Погляньмо, як ітератори можуть поліпшити нашу реалізацію функцій <code>Config::build</code> і <code>search</code>.</p>
<h3 id="Видалення-clone-за-допомогою-ітератора"><a class="header" href="#Видалення-clone-за-допомогою-ітератора">Видалення <code>clone</code> за допомогою ітератора</a></h3>
<p>У Блоці коду 12-6 ми додали код, що бере слайс зі значень <code>String</code> і створили екземпляр структури <code>Config</code> індексуванням слайса і клонуванням значень, дозволивши структурі <code>Config</code> володіти цими значеннями. У Блоці коду 13-17 ми відтворили реалізацію функції <code>Config::build</code> такою, як у Блоці коду 12-23:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 13-17: відтворення функції <code>Config::build</code> з Блоку коду 12-23</span></p>
<p>Тоді ми казали не хвилюватися через неефективні виклики <code>clone</code>, оскільки ми видалимо їх e майбутньому. Що ж, цей час настав!</p>
<p>Нам тут потрібен <code>clone</code>, тому що ми маємо слайс з елементами <code>String</code> у параметрі <code>args</code>, але функція <code>build</code> не володіє <code>args</code>. Щоб повернути володіння екземпляром <code>Config</code>, нам довелося клонувати значення з полів <code>query</code> та <code>file_path</code> з <code>Config</code>, щоб екземпляр <code>Config</code> міг володіти своїми значеннями.</p>
<p>За допомогою нових знань про ітератори см можемо змінити функцію <code>build</code>, щоб вона брала володіння ітератором як аргумент замість позичати слайс. Ми використаємо функціональність ітератора замість коду, що перевіряє довжину слайса і індексує конкретні місця. Це прояснить, що саме робить функція <code>Config::build</code>, бо доступ до значень забезпечуватиме ітератор.</p>
<p>Коли <code>Config::build</code> прийме володіння ітератором та припинить використовувати операції індексації, що позичають, ми зможемо перемістити значення <code>String</code> з ітератора в <code>Config</code> замість викликати <code>clone</code> і робити новий розподіл пам'яті.</p>
<h4 id="Використання-повернутого-ітератора-напряму"><a class="header" href="#Використання-повернутого-ітератора-напряму">Використання повернутого ітератора напряму</a></h4>
<p>Відкрийте файл <em>src/main.rs</em> з нашого проєкту введення/виведення, що виглядає ось так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Application error: {e}&quot;);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<p>Ми спочатку змінимо початок функції <code>main</code>, яка була в нас у Блоці коду 12-24, на коду з Блоку коду 13-18, який на цей раз використовує ітератор. Це не буде компілюватися, доки ми не оновимо також <code>Config::build</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Application error: {e}&quot;);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">Блок коду 13-18: передавання значення, повернутого <code>env::args</code>, до <code>Config::build</code></span></p>
<p>Функція <code>env::args</code> повертає ітератор! Замість того, щоб збирати значення ітератора до вектора і передавання слайс до <code>Config::build</code>, тепер ми передаємо володіння ітератором, повернутим з <code>env::args</code>, напряму до <code>Config::build</code>.</p>
<p>Далі, нам потрібно оновити визначення <code>Config::build</code>. У файлі <em>src/lib.rs</em> вашого проєкту введення/виведення змінімо сигнатуру <code>Config::build</code>, щоб вона виглядала як у Блоці коду 13-19. Це все ще не компілюється, оскільки нам потрібно оновити тіло функції.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 13-19: оновлення сигнатури <code>Config::build</code>, щоб приймала ітератор</span></p>
<p>The standard library documentation for the <code>env::args</code> function shows that the type of the iterator it returns is <code>std::env::Args</code>, and that type implements the <code>Iterator</code> trait and returns <code>String</code> values.</p>
<p>Ми оновили сигнатуру функції <code>Config::build</code>, зробивши параметр <code>args</code> узагальненого типу з обмеженням трейту <code>impl Iterator&lt;Item = String&gt;</code> замість <code>&amp;[String]</code>. Цей синтаксис <code>impl Trait</code>, який ми обговорили у підрозділі <a href="ch10-02-traits.html#traits-as-parameters">“Трейти як параметри”</a><!-- ignore --> Розділу 10, означає, що <code>args</code> може бути будь-якого типу, що реалізує тип <code>Iterator</code> і повертає елементи типу <code>String</code>.</p>
<p>Оскільки ми беремо володіння <code>args</code> і ми будемо змінювати <code>args</code>, ітеруючи крізь нього, ми можемо додати ключове слово <code>mut</code> в специфікацію параметра <code>args</code>, щоб зробити його мутабельним.</p>
<h4 id="Використання-методів-трейту-iterator-замість-індексування"><a class="header" href="#Використання-методів-трейту-iterator-замість-індексування">Використання методів трейту <code>Iterator</code> замість індексування</a></h4>
<p>Далі ми виправимо тіло <code>Config::build</code>. Оскільки <code>args</code> реалізує трейт <code>Iterator</code>, ми знаємо, що можемо викликати для нього метод <code>next</code>! Блок коду 13-20 оновлює код зі Блоку коду 12-23, використовуючи метод <code>next</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let file_path = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file path&quot;),
        };

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 13-20: зміна тіла <code>Config::build</code> з використанням методів ітератора</span></p>
<p>Згадайте, що перша стрічка в значенні, яке повертає <code>env::args</code>, є назвою програми. Ми хочемо проігнорувати його і дістатися до наступного значення, тож спершу викличемо <code>next</code> і нічого не зробимо з поверненим значенням. По-друге, ми викликаємо <code>next</code>, щоб отримати значення, ми хочемо вставити в поле <code>Config</code> <code>query</code>. Якщо <code>next</code> повертає <code>Some</code>, ми використовуємо <code>match</code>, щоб витягти значення. Якщо вона повертає <code>None</code>, це означає, що було недостатньо аргументів, і ми достроково виходимо, повертаючи значення <code>Err</code>. Те саме ми робимо і зі значенням <code>file_path</code>.</p>
<h3 id="Робимо-код-яснішим-за-допомогою-адаптерів-ітераторів"><a class="header" href="#Робимо-код-яснішим-за-допомогою-адаптерів-ітераторів">Робимо код яснішим за допомогою адаптерів ітераторів</a></h3>
<p>Ми також можемо скористатися ітераторами у функції <code>search</code> у нашому проєкті введення/виведення, який відтворений тут у Блоці коду 13-21 таким, як він був 12-19:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 13-21: реалізація функції <code>search</code> з Блоку коду 12-19</span></p>
<p>Ми можемо зробити цей код чіткішим за допомогою методів-адаптерів ітераторів. Це також дозволить нам уникнути проміжного мутабельного вектору <code>results</code>. Функціональний стиль програмування надає перевагу мінімізації кількості мутабельних станів, щоб зробити код чистішим. Видалення мутабельного стану може уможливити подальше покращення для здійснення паралельного пошуку, оскільки ми не змогли б керувати одночасним доступом до вектора <code>results</code>. Блок коду 13-22 показує ці зміни:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(
</span><span class="boring">        mut args: impl Iterator&lt;Item = String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let query = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;Didn't get a query string&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let file_path = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;Didn't get a file path&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 13-22: використання методів-адаптерів ітераторів у реалізації функції <code>search</code></span></p>
<p>Згадайте, що призначення функції <code>search</code> - повернути всі рядки в <code>contents</code>, що містять <code>query</code>. Так само як у прикладі <code>filter</code> з Блоку коду 13-16, цей код використовує адаптер <code>filter</code> для збереження тільки тих рядків, для яких <code>line.contains(query)</code> повертає <code>true</code>. Потім ми збираємо відповідні рядки у інший вектор за допомогою <code>collect</code>. Набагато простіше! Можете самі спробувати внести аналогічні зміни з використанням методів ітератора у функцію <code>search_case_insensitive</code>.</p>
<h3 id="Вибір-між-циклами-або-ітераторами"><a class="header" href="#Вибір-між-циклами-або-ітераторами">Вибір між циклами або ітераторами</a></h3>
<p>Наступне логічне питання - який стиль вам слід обрати у вашому власному коді й чому: оригінальна реалізація з Блоку коду 13-21 чи версія з ітераторами з Блоку коду 13-22. Більшість програмістів Rust вважають за краще використовувати ітераторний стиль. До нього дещо складніше призвичаїтися в перший час, але відколи ви набудете відчуття різноманітних ітераторів і що вони роблять, ітератори стають простішими для розуміння. Замість того, щоб займатися дрібними уточненнями в циклі й збирати нові вектори, код зосереджується на високорівневій меті циклу. Це дозволяє абстрагуватися від деякого банального коду, щоб легше було побачити концепції, унікальні для цього коду, такі як умови фільтрації, яку має пройти кожен елемент ітератора.</p>
<p>Але чи ці дві реалізації дійсно еквівалентні? Інтуїтивне припущення може казати, що більш низькорівневий цикл буде швидшим. Поговорімо про швидкодію.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Порівняння-швидкодії-цикли-проти-ітераторів"><a class="header" href="#Порівняння-швидкодії-цикли-проти-ітераторів">Порівняння швидкодії: цикли проти ітераторів</a></h2>
<p>Щоб визначити, використовувати цикли чи ітератори, вам треба знати, яка реалізація швидша: версія функції <code>search</code> з явним циклом <code>for</code> чи версія з ітераторами.</p>
<p>Ми запустили бенчмарк, завантаживши повний текст <em>&quot;Пригод Шерлока Голмса&quot;</em> сера Артура Конана Дойла в <code>String</code> і шукаючи там слово <em>the</em>. Ось результати бенчмарка на версії <code>search</code>, що використовує цикл <code>for</code>, і версії, що використовує ітератори:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>Версія з ітератором виявилася трохи швидшою! Ми не будемо тут пояснювати код бенчмарка, бо мета не довести, що дві версії еквівалентні, а отримати загальне уявлення про те, як ці дві реалізації порівнюються з точки зору продуктивності.</p>
<p>Для повнішого бенчмарку слід перевіряти, використовуючи як <code>contents</code> різні тексти різного розміру, різні слова і слова різної довжини як <code>query</code>, і всілякі інші варіації. Річ у тому, що ітератори, хоча і є високорівневою абстракцією, компілюються приблизно до приблизно такого ж коду, як ніби ви самі писали низькорівневий код. Ітератори - це одна з *абстракцій нульової вартості * Rust, що означає, що абстракція не накладає додаткових витрат часу виконання. Це аналогічно тому, як Б'ярне Строуструп, оригінальний дизайнер і реалізатор C++, визначає <em>нульові витрати</em> в &quot;Основах C++&quot; (2012):</p>
<blockquote>
<p>Загалом, реалізації C++ підкоряються принципу нульових витрат: якщо ви чогось не використовуєте, то не платите за це. І більше: те, що ви використовуєте, ви не змогли запрограмувати вручну краще.</p>
</blockquote>
<p>Як інший приклад, наступний код взятий з аудіо декодера. Алгоритм декодування використовує математичну операцію лінійного прогнозування для оцінки майбутніх значень на основі лінійної функції попередніх зразків. Цей код використовує ланцюг ітераторів для виконання математичних операцій на трьох змінних в області видимості: слайсі даних <code>buffer</code>, масиві з 12 <code>coefficients</code>, і значенні, на яке треба зсунути дані <code>qlp_shift</code>. Ми оголосили змінні, що знаходяться в цьому прикладі, але не дали їм жодних значень; хоча цей код не має особливого сенсу поза своїм контекстом, він є реальним лаконічним прикладом того, як Rust переносить високорівневі ідеї в низькорівневий код.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
</code></pre>
<p>Щоб обчислити значення <code>prediction</code>, цей код ітерує через кожне з 12 значень у <code>coefficients</code> і використовує метод <code>zip</code> для з'єднання значень коефіцієнтів з попередніми 12 значеннями з <code>buffer</code>. Потім для кожної пари ми множимо значення, додаємо усі результати, і зсуваємо біти в сумі на <code>qlp_shift</code> бітів праворуч.</p>
<p>Обчислення в застосунках на кшталт аудіо декодерів часто найвище цінують швидкодію. Тут ми створюємо ітератор, використовуючи два адаптери, а потім поглинаємо значення. У який асемблерний код скомпілюється цей код Rust? Ну, якщо щодо цього коду, то він компілюється у такий же асемблерний код, який ви б написали самі. Циклу, що відповідає ітераціям по значеннях у <code>coefficients</code>, не буде взагалі: Rust знає, що буде всього 12 ітерацій, тож він &quot;розгортає&quot; цикл. <em>Розгортання</em> - це оптимізація, яка видаляє накладні витрати на код, що керує циклом, а замість цього генерує код із повтореннями для кожної ітерації циклу.</p>
<p>Всі коефіцієнти зберігаються в регістрах, тобто доступ до значень є дуже швидким. Немає перевірок виходу за межі при доступі до масиву під час виконання. Всі ці оптимізації, які Rust може застосувати, роблять згенерований код надзвичайно ефективним. Тепер, коли ви це знаєте, ви можете використовувати ітератори та замикання без страху! Вони роблять код схожим на високорівневий, але не накладають за це штрафів на швидкодію часу виконання.</p>
<h2 id="Підсумок-12"><a class="header" href="#Підсумок-12">Підсумок</a></h2>
<p>Замикання та ітератори - це особливості Rust, натхнені ідеями мов функціонального програмування. Вони сприяють здатності Rust чітко виражати високорівневі ідеї при низькорівневій швидкодії. Реалізація замикань та ітераторів така, що швидкодія часу виконання не страждає. Це - частина мети Rust прагнути забезпечити абстракції нульової вартості.</p>
<p>Тепер, коли ми покращили виразність нашого проєкту введення/виведення, подивімося на деякі додаткові можливості <code>cargo</code>, які допоможуть нам поділитися проєктом зі світом.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Більше-про-cargo-та-cratesio"><a class="header" href="#Більше-про-cargo-та-cratesio">Більше про Cargo та Crates.io</a></h1>
<p>Досі ми використовували тільки основний функціонал Cargo для збірки, запуску та тестування, але він може робити набагато більше. В цьому розділі ми обговоримо дещо з решти його більш просунутого функціонала, щоб показати вам, як робити наступне:</p>
<ul>
<li>Налаштування вашої збірки із release профілями</li>
<li>Публікація бібліотек на <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Організація великих проєктів з робочими областями</li>
<li>Встановлення з <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Розширення Cargo, використовуючи користувацькі команди</li>
</ul>
<p>Cargo can do even more than the functionality we cover in this chapter, so for a full explanation of all its features, see <a href="https://doc.rust-lang.org/cargo/">its documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Налаштування-Збірок-з-release-Профілями"><a class="header" href="#Налаштування-Збірок-з-release-Профілями">Налаштування Збірок з Release Профілями</a></h2>
<p>В Rust, <em>release профілі</em> є попередньо визначені та настроюваними профілями з різними конфігураціями які дозволяють програмісту мати більше контролю над різними опціями для компіляції коду. Кожен профіль налаштований незалежно від інших.</p>
<p>Cargo має два основні профілі: профіль <code>dev</code> який використовується під час запуску <code>cargo build</code> і профіль <code>release</code>, який використовується під час запуску <code>cargo build --release</code>. Профіль <code>dev</code> визначено з хорошими параметрами за замовчуванням для розробки і профіль <code>release</code> має хороші параметри за замовчуванням для збірки для випуску.</p>
<p>Ці імена профілів можуть бути знайомі з виводу ваших збірок:</p>
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-->
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<p><code>dev</code> і <code>release</code> це різні профілі, які використовуються компілятором.</p>
<p>Cargo має налаштування за замовчуванням для кожного профілю, який застосовується, навіть, якщо ви ще явно не додали жодної секції <code>[profile.*]</code> в файл <em>Cargo.toml</em> проєкту. Додаючи секції <code>[profile.*]</code> будь-якому профілю, який ви бажаєте налаштувати, ви перевизначаєте будь-яку підмножину налаштувань за замовчуванням. Наприклад, ось значення за замовчуванням налаштування <code>opt-level</code> для профілів <code>dev</code> і <code>release</code>:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>Налаштування <code>opt-level</code> контролює кількість оптимізації, яку Rust буде застосовувати до вашого коду з діапазоном від 0 до 3. Чим більше оптимізацій застосовується, тим довше стає час компіляції, тому якщо ви часто компілюєте код під час розробки, вам знадобиться менше оптимізацій, щоб компілювати швидше, навіть якщо отриманий код повільніше. Тому <code>opt-level</code> для <code>dev</code> за замовчуванням <code>0</code>. Коли ви готові до випуску вашого коду, краще витратити більше часу на компіляцію. Ви будете компілювати в режимі випуску тільки раз, але ви запускатимете скомпільовану програму багато разів, тому режим випуску обмінює довший час компіляції на швидший код. Саме тому <code>opt-level</code> для профілю <code>release</code> за замовчуванням <code>3</code>.</p>
<p>Ви можете перевизначити налаштування за замовчуванням, додав інше значення в <em>Cargo.toml</em>. Наприклад, якщо ми хочемо використовувати оптимізацію 1-го рівня в профілі розробки, ми можемо додати ці два рядки в файл <em>Cargo.toml</em> нашого проєкту:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>Цей код перевизначає налаштування за замовчуванням <code>0</code>. Тепер, коли ми запустимо <code>cargo build</code>, Cargo буде використовувати за замовчуванням профіль <code>dev</code> плюс наше налаштування <code>opt-level</code>. Оскільки ви встановили <code>opt-level</code> на <code>1</code>, Cargo буде застосовувати більше оптимізацій за замовчуванням, але не настільки багато, як в режимі випуску.</p>
<p>For the full list of configuration options and defaults for each profile, see <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo’s documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Публікація-Крейта-на-cratesio"><a class="header" href="#Публікація-Крейта-на-cratesio">Публікація Крейта на Crates.io</a></h2>
<p>Ми використовували пакети з <a href="https://crates.io/">crates.io</a><!-- ignore --> як залежності проекту, але ви також можете поділитися своїм кодом з іншими людьми, опублікувавши ваші власні пакети. Реєстр крейтів на <a href="https://crates.io/">crates.io</a><!-- ignore --> поширює початковий код ваших пакетів, тому він в першу чергу розміщує open-source код.</p>
<p>Rust і Cargo мають функціонал, який полегшує пошук та використання вашого опублікованого пакета. Далі ми поговоримо про деякі з цих можливостей і потім пояснимо, як опублікувати пакет.</p>
<h3 id="Робимо-Корисні-Коментарі-в-Документації"><a class="header" href="#Робимо-Корисні-Коментарі-в-Документації">Робимо Корисні Коментарі в Документації</a></h3>
<p>Якісне документування ваших пакетів допоможе іншим користувачам знати, як і коли їх використовувати, тому варто вкладати час на написання документації. У Розділі 3, ми обговорювали як коментарі Rust коду використовують подвійний слеш, <code>//</code>. Rust також має особливий вид коментарів для документації, зручно відомий як <em>документаційні коментарі</em>, які також будуть створювати HTML документацію. HTML покаже зміст документаційних коментарів для елементів публічного API, розрахованих на програмістів, які зацікавлені в <em>використанні</em> вашого крейту на відміну від того, як ваш крейт <em>імплементовано</em>.</p>
<p>Документаційні коментарі використовують три слеші, <code>///</code>, замість двох та підтримують Markdown для форматування тексту. Розміщуйте документаційні коментарі безпосередньо перед елементом, який вони документують. Блок коду 14-1 показує документаційні коментарі для функції <code>add_one</code> крейту з назвою <code>my_crate</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p><span class="caption">Listing 14-1: A documentation comment for a function</span></p>
<p>Тут ми дамо опис того, що робить функція <code>add_one</code>, почнемо розділ з заголовком <code>Приклади</code>, і надамо код, який продемонструє, як використовувати функцію <code>add_one</code>. Ми можемо створити HTML документацію з документаційних коментарів, запустивши <code>cargo doc</code>. Ця команда запускає інструмент <code>rustdoc</code>, який поширюється з Rust і кладе згенеровану HTML документацію в директорії <em>target/doc</em>.</p>
<p>Для зручності, запуск <code>cargo doc --open</code> збере HTML для Вашої поточної документації (а також документації для всіх залежностей вашого крейту) і відкриє результат у браузері. Перейдіть до функції <code>add_one</code> та ви побачите, як текст коментарів документації відтворюється, як показано на Малюнку 14-1:</p>
<img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">Figure 14-1: HTML documentation for the <code>add_one</code> function</span></p>
<h4 id="Часто-Вживані-Розділи"><a class="header" href="#Часто-Вживані-Розділи">Часто Вживані Розділи</a></h4>
<p>Ми використовували Markdown заголовок <code># Examples</code> в Блоці Коду 14-1 для створення секції в HTML з назвою “Examples.” Ось ще кілька секцій, які автори крейтів зазвичай використовують у своїх документаціях:</p>
<ul>
<li><strong>Паніки</strong>: Сценарії, в яких документована функція може запанікувати. Користувачі, які будуть використовувати ці функції і які не хочуть, щоб їх програма панікувала, повинні бути впевнені, що вони не викликають функції в цих ситуаціях.</li>
<li><strong>Помилки</strong>: Якщо функція повертає <code>Result</code>, який описує різновиди можливих помилок та які умови можуть призвести до повернення цих помилок, користувачам функції може бути корисно, щоб вони могли написати код для обробки різних помилок різними способами.</li>
<li><strong>Безпека</strong>: Якщо функція <code>unsafe</code> (ми обговоримо небезпечність в Розділі 19), то має бути секція, в якій пояснюється, чому функція небезпечна та її інваріанти, які мають дотримуватися користувачі функції.</li>
</ul>
<p>Більшості документаційних коментарів не потрібні всі ці секції, але це хороший контрольний список, щоб нагадувати вам аспекти вашого коду, про які вашим користувачам буде цікаво дізнатися.</p>
<h4 id="Коментарі-Документації-як-Тести"><a class="header" href="#Коментарі-Документації-як-Тести">Коментарі Документації як Тести</a></h4>
<p>Додавання прикладу блоків коду в ваші коментарі документації може допомогти продемонструвати, як ви використовуєте вашу бібліотеку, і в цьому є додатковий бонус: запуск <code>cargo test</code> запускатиме приклади коду в вашій документації як тести! Немає нічого приємнішого ніж документація з прикладами. Але немає нічого гіршого ніж приклади, які не працюють, бо код змінився з моменту написання документації. Якщо ми запустимо <code>cargo test</code> із документацією для функції <code>add_one</code> з Блока Коду 14-1, ми побачимо секцію результатів тестів наступним чином:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>А тепер, якщо ми змінимо або функцію або приклад, щоб <code>assert_eq!</code> в прикладі запанікував та знову виконаємо <code>cargo test</code>, ми побачимо, що документаційні тести зловили, що приклад та код не синхронізовані між собою!</p>
<h4 id="Коментування-Присутніх-Елементів"><a class="header" href="#Коментування-Присутніх-Елементів">Коментування Присутніх Елементів</a></h4>
<p>Стиль документаційних коментарів <code>//!</code> додає документацію до елемента, який містить коментарі, аніж до елементів, що слідують за коментарями. Як правило, ми використовуємо документаційні коментарі всередині кореневого файлу крейта (<em>src/lib.rs</em> за домовленістю) або всередині модуля для документування крейта або модуля в цілому.</p>
<p>For example, to add documentation that describes the purpose of the <code>my_crate</code> crate that contains the <code>add_one</code> function, we add documentation comments that start with <code>//!</code> to the beginning of the <em>src/lib.rs</em> file, as shown in Listing 14-2:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 14-2: Documentation for the <code>my_crate</code> crate as a whole</span></p>
<p>Зауважте, що тут немає коду після останнього рядку, який починається з <code>//!</code>. Оскільки ми почали коментар з <code>//!</code> замість <code>///</code>, ми документуємо предмет який міститься в коментарі, замість предмета, який слідує за коментарем. У цьому випадку, цей елемент це файл <em>src/lib.rs</em>, який містить кореневий каталог. Ці коментарі описують увесь крейт.</p>
<p>Коли ви запускаєте <code>cargo doc --open</code>, ці коментарі будуть показані на головній сторінці документації <code>my_crate</code> вище списку публічних елементів крейту, як показано на Рисунку 14-2:</p>
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" />
<p><span class="caption">Рисунок 14-2: Оброблена документація <code>my_crate</code>, включно з коментарем, який описує крейт в цілому</span></p>
<p>Документаційні коментарі всередині елементів корисні для опису крейтів і особливо модулів. Використовуйте їх, щоб пояснювати загальну мету контейнера, щоб допомогти вашим користувачам зрозуміти організацію крейту.</p>
<h3 id="Експорт-Зручного-Публічного-api-з-pub-use"><a class="header" href="#Експорт-Зручного-Публічного-api-з-pub-use">Експорт Зручного Публічного API з <code>pub use</code></a></h3>
<p>Структура вашого публічного API має вирішальне значення, коли ви публікуєте крейт. Користувачі вашого крейту менш знайомі зі структурою ніж ви та можуть мати труднощі у пошуку бажаних частин, якщо у вашому крейті велика ієрархія модулів.</p>
<p>У Розділі 7 ми розглянули, як робити елементи публічними за допомогою ключового слова <code>pub</code> та вносити елементи в область видимості з ключовим словом <code>use</code>. Однак, структура, яка має сенс під час розробки крейту, може бути не дуже зручна для ваших користувачів. Ви можливо захочете організувати ваші структури в багаторівневій ієрархії, але потім люди які захочуть використати визначений глибоко в ієрархії тип можуть мати проблеми з з'ясуванням, що цей тип існує. Вони також можуть бути роздратованими через необхідність писати <code>use</code> <code>my_crate::some_module::another_module::UsefulType;</code> замість <code>use</code> <code>my_crate::UsefulType;</code>.</p>
<p>Хороші новини полягають в тому, що якщо іншим користувачам <em>не</em> зручно використовувати її з іншої бібліотеки, вам не потрібно переробляти вашу внутрішню організацію: натомість, ми можете повторно експортувати елементи, щоб зробити публічну структуру, яка відрізняється від вашої приватної структури використанням <code>pub use</code>. Повторне експортування бере публічний елемент з одного місця і робить його публічним в іншому місці, ніби це було визначено в іншій локації.</p>
<p>Скажімо, ми зробили бібліотеку з назвою <code>art</code> для моделювання художніх концепцій. Всередині цієї бібліотеки є два модулі: модуль <code>kinds</code>, який містить два енуми із назвами <code>PrimaryColor</code> та <code>SecondaryColor</code> і модуль <code>utils</code>, який містить функцію <code>mix</code>, як показано в Блоці Коду 14-3:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
<span class="boring">        unimplemented!();
</span>    }
}
</code></pre>
<p><span class="caption">Блок Коду 14-3: Бібліотека <code>art</code> з елементами організованими в модулі <code>kinds</code> та <code>utils</code></span></p>
<p>Рисунок 14-3 показує, як буде виглядати головна сторінка документації цього крейта згенерована з <code>cargo doc</code>:</p>
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
<p><span class="caption">Рисунок 14-3: Головна сторінка документації <code>art</code> зі списком модулів <code>kinds</code> and <code>utils</code></span></p>
<p>Зауважте, що типи <code>PrimaryColor</code> та <code>SecondaryColor</code> не вказані на головній сторінці, так само як і функція <code>mix</code>. Нам потрібно натиснути на <code>kinds</code> та <code>utils</code>, щоб побачити їх.</p>
<p>Іншому залежному від цієї бібліотеки крейту знадобиться інструкція <code>use</code>, яка приносить елементи з <code>art</code> в область видимості, вказавши визначену зараз структуру модуля. Блок коду 14-4 показує приклад крейта, який використовую елементи <code>PrimaryColor</code> та <code>mix</code> з крейту <code>art</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
</code></pre>
<p><span class="caption">Блок Коду 14-4: Крейт використовує елементи крейту <code>art</code> із його експортованою внутрішньою структурою</span></p>
<p>Автор коду в Блоці Коду 14-4, який використовує <code>art</code> крейт, має з'ясувати, що <code>PrimaryColor</code> в модулі <code>kinds</code>, а <code>mix</code> в модулі <code>utils</code>. Структура модуля <code>art</code> крейту є більш актуальною для розробників <code>art</code> крейту, ніж для його користувачів. Внутрішня структура не містить жодної корисної інформації для когось, хто намагається зрозуміти, як використовувати <code>art</code> крейт, радше викликає плутанину, бо розробники, які використовують цей крейт мають з'ясовувати, куди дивитися та мають вказувати назву модуля в інструкції <code>use</code>.</p>
<p>Щоб видалити внутрішню організацію з публічного API, ми можемо змінити код крейту <code>art</code>, як показано в Блоці Коду 14-3, щоб додати інструкції <code>pub use</code> для повторного експорту елементів на вищий рівень, як показано в Блоці Коду 14-5:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
<span class="boring">    /// The primary colors according to the RYB color model.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// The secondary colors according to the RYB color model.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --snip--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// Combines two primary colors in equal amounts to create
</span><span class="boring">    /// a secondary color.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">Блок Коду 14-5: Додавання інструкції <code>pub use</code> для повторного експорту елементів</span></p>
<p>Документація API, яку <code>cargo doc</code> створює для цього крейту, тепер буде мати повторно експортований список та посилання на головній сторінці, як показано на Малюнку 14-4, полегшуючи пошук типів <code>PrimaryColor</code>та <code>SecondaryColor</code> і функції <code>mix</code>.</p>
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" />
<p><span class="caption">Рисунок 14-4: Головна сторінка документації <code>art</code>, яка має список повторно експортованих елементів</span></p>
<p>Користувачі крейту <code>art</code> все ще можуть бачити і використовувати внутрішню структуру з Блоку Коду 14-3, як продемонстровано в Блоці Коду 14-4, або вони можуть використовувати біль зручну структуру з Блоку Коду 14-5, як показано в Блоці Коду 14-6:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::mix;
use art::PrimaryColor;

fn main() {
    // --snip--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}
</code></pre>
<p><span class="caption">Блок Коду 14-06: Програма, яка використовує експортовані елементи з крейту <code>art</code></span></p>
<p>У випадках, коли є багато вкладених модулів, повторне експортування типів на вищий рівень із <code>pub use</code> може зробити суттєву різницю в досвіді використання цього крейта. Ще одним поширеним використанням <code>pub use</code> є повторне експортування визначень залежностей в поточному крейті, щоб зробити визначення цього крейту частиною публічного API.</p>
<p>Створення корисної публічної структури API є скоріше мистецтвом ніж наукою, і ви можете ітерувати, щоб знайти API яке найкраще підходить для ваших користувачів. Вибір <code>pub use</code> дає вам гнучкість у тому, як ви внутрішньо структуруєте свій крейт та відділяє внутрішню структуру від того, що ви представляєте своїм користувачам. Подивімося на деякий код з встановлених вами крейтів, щоб побачити, чи їх структура відрізняється від їх публічного API.</p>
<h3 id="Налаштування-Облікового-Запису-cratesio"><a class="header" href="#Налаштування-Облікового-Запису-cratesio">Налаштування Облікового Запису Crates.io</a></h3>
<p>Перш ніж ви зможете опублікувати якісь крейти, вам потрібно створити обліковий запис на <a href="https://crates.io/">crates.io</a><!-- ignore --> і отримати API токен. Для цього, відвідайте домашню сторінку на <a href="https://crates.io/">crates.io</a><!-- ignore --> і увійдіть за допомогою вашого облікового запису Github. (Обліковий запис на GitHub наразі є вимогою, але сайт може підтримувати інші способи створення облікового запису в майбутньому.) Після входу перейдіть до налаштувань облікового запису на <a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> і отримайте ваш API ключ. Потім запустить команду <code>cargo login</code> із вашим API токеном наступним чином:</p>
<pre><code class="language-console">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>Ця команда повідомить Cargo про ваш API токен та збереже його локально в <em>~/.cargo/credentials</em>. Зауважте, що токен це <em>секрет</em>: не діліться ним з будь-ким іншим. Якщо ви поділитесь ним з будь-ким задля будь-якої причини, ви можете відкликати його та створити новий токен на <a href="https://crates.io/">crates.io</a><!-- ignore
-->.</p>
<h3 id="Додавання-Метаданих-до-Нового-Крейту"><a class="header" href="#Додавання-Метаданих-до-Нового-Крейту">Додавання Метаданих до Нового Крейту</a></h3>
<p>Скажімо ви маєте крейт який ви хочете опублікувати. Перед публікацією, вам буде потрібно додати деякі метадані в секції <code>[package]</code> файлу <em>Cargo.toml</em> вашого крейту.</p>
<p>Вашому крейту знадобиться унікальна назва. Поки ви працюєте над крейтом локально, ви можете називати його як завгодно. Однак, назва крейту на <a href="https://crates.io/">crates.io</a><!-- ignore --> виділяється в порядку живої черги(перший прийшов - перший отримав). Як тільки назва крейту обрана, ніхто інший не може опублікувати крейт із цією назвою. Перед спробою опублікувати крейт, пошукайте назву, яку ви бажаєте використовувати. Якщо назва зайнята, вам знадобиться обрати іншу назву та редагувати поле <code>name</code> в файлі <em>Cargo.toml</em> в секції <code>[package]</code>, щоб використати нову назву для публікації наступним чином:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<p>Навіть якщо ви обрали унікальну назву, коли ви запустите <code>cargo publish</code>, щоб опублікувати крейт, ви, наразі, отримаєте попередження та, потім, помилку:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
Перегляньте https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata для додатковох інформації.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error: missing or empty metadata fields: description, license. Будь ласка перегляньте https://doc.rust-lang.org/cargo/reference/manifest.html щодо того, як завантажити метадані
</code></pre>
<p>Це помилка, оскільки у вас відсутня деяка вирішальна інформація: опис та ліцензія які необхідні для того, щоб люди знали, що ваш крейт робить та на яких умовах вони можуть його використовувати. У <em>Cargo.toml</em>, додайте опис розміром з речення або два, оскільки воно з'явиться з вашим крейтом в результаті пошуку. Для поля <code>license</code> вам потрібно надати <em>значення ідентифікатора ліцензії</em>. <a href="http://spdx.org/licenses/">Linux Foundation’s Software Package Data Exchange (SPDX)</a> перелічує ідентифікатори які ви можете використати як це значення. Наприклад, щоб вказати, що ваш крейт використовує ліцензію MIT, додайте ідентифікатор <code>MIT</code>:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<p>Якщо ви хочете використовувати ліцензію, якої немає в SPDX, то вам потрібно місце де можна розмістити текст цієї ліцензії в файлі, включно із файлом вашого проєкту, а потім використайте поле <code>license-file</code>, щоб зазначити назву цього файлу замість ключа <code>license</code>.</p>
<p>Супровід щодо того, яка ліцензія підійде вашому проєкту, поза рамками цієї книги. Багато людей у спільноті Rust ліцензує їх проєкти так само як і Rust, використовуючи подвійну ліцензію <code>MIT OR Apache-2.0</code>. Ця практика демонструє, що ви також можете вказати декілька ідентифікаторів ліцензій, які відокремлені <code>OR</code>, щоб використовувати декілька ліцензій в вашому проєкті.</p>
<p>З унікальною назвою, версією, вашим описом і доданою ліцензією файл <em>Cargo.toml</em> для проєкту, готового до публікації, може виглядати так:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo’s documentation</a> describes other metadata you can specify to ensure others can discover and use your crate more easily.</p>
<h3 id="Публікація-на-cratesio"><a class="header" href="#Публікація-на-cratesio">Публікація на Crates.io</a></h3>
<p>Тепер, коли ви створили обліковий запис, зберегли ваш API токен, обрали назву вашого крейту та вказали необхідні метадані, ви готові до публікації! Публікація крейту завантажує конкретну версію на <a href="https://crates.io/">crates.io</a><!-- ignore --> для використовування іншими.</p>
<p>Будьте обережні, оскільки публікація <em>перманентна</em>. Версія ніколи не може бути перезаписана, а код ніколи не може бути видалений. Одна з основних цілей <a href="https://crates.io/">crates.io</a><!-- ignore --> це діяти як перманентний архів коду, щоб збірка кожного проекту залежного від крейту на <a href="https://crates.io/">crates.io</a><!-- ignore --> продовжувала працювати. Дозволяючи видалення версій ми робимо виконання цієї цілі неможливим. Однак, немає обмежень на кількість версій крейтів, які ви можете опублікувати.</p>
<p>Запустимо знову команду <code>cargo publish</code>. Тепер воно має бути вдалим:</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>Вітаємо! Ви зараз поділилися вашим кодом із Rust спільнотою та кожен може легко додати ваш крейт як залежність до його проєкту.</p>
<h3 id="Публікація-Нової-Версії-Існуючого-Крейту"><a class="header" href="#Публікація-Нової-Версії-Існуючого-Крейту">Публікація Нової Версії Існуючого Крейту</a></h3>
<p>Коли ви внесли зміни в ваш крейт та готові випустити нову версію ви змінюєте значення <code>version</code>, яке вказане в вашому файлі <em>Cargo.toml</em> та знову публікуйте. Використовуйте <a href="http://semver.org/">правила Семантичного Версіонування</a> для вирішення відповідного наступного номера версії, на основі зроблених вами змін. Потім запускайте <code>cargo publish</code> для завантаження нової версії.</p>
<!-- Old link, do not remove -->
<p><a id="removing-versions-from-cratesio-with-cargo-yank"></a></p>
<h3 id="Вилучаємо-Старі-Версії-з-cratesio-з-cargo-yank"><a class="header" href="#Вилучаємо-Старі-Версії-з-cratesio-з-cargo-yank">Вилучаємо Старі Версії з Crates.io з <code>cargo yank</code></a></h3>
<p>Хоча ми не можемо видалити попередні версії крейта, ми можемо запобігти будь-яким майбутнім проєктам додавати цих версій як нову залежність. Це корисно, коли версія крейту зламана по тій чи іншій причині. У таких ситуаціях Cargo підтримує <em>висмикування або yanking</em> версії крейту.</p>
<p>Висмикування версії перешкоджає залежність від цієї версії новими проєктами, дозволяючи усім чинним проєктам, які залежать від неї, продовжувати її використовувати. По суті, смик означає, що всі проєкти з <em>Cargo.lock</em> не зламаються та будь-який наступний створений файл <em>Cargo.lock</em> не буде використовувати висмикану версію.</p>
<p>Щоб висмикнути версію крейту в директорії, яку ви раніше публікували запустіть команду <code>cargo yank</code> та зазначте яку версію ви хочете висмикнути. Наприклад, якщо ви опублікуєте крейт з назвою <code>guessing_game</code> версії 1.0.1 та захочете висмикнути її, в теці вашого проєкту для <code>guessing_game</code> ви б виконали:</p>
<!-- manual-regeneration:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>Додаючи <code>--undo</code> до команди, ви також можете скасувати висмикування і дозволити проєктам знову почати залежати від версії:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
</code></pre>
<p>Висмикування <em>не</em> видаляє жодного коду. Воно не може, наприклад, випадково видалити завантажені секрети. Якщо таке станеться, вам буде потрібно негайно замінити ці секрети.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Робочі-Області-cargo"><a class="header" href="#Робочі-Області-cargo">Робочі Області Cargo</a></h2>
<p>В розділі 12, ми зібрали пакет, який включав двійковий крейт та бібліотечний крейт. В міру розвитку вашого проекту, ви можете виявити, що бібліотечний крейт продовжує становитися більшим і вам хочеться розділити ваш пакет на декілька бібліотечних крейтів. Cargo пропонує функціонал названий <em>робочими областями</em>, який може допомогти в керуванні кількома пов'язаними пакетами, які розробляються в тандемі.</p>
<h3 id="Створення-Робочої-Області"><a class="header" href="#Створення-Робочої-Області">Створення Робочої Області</a></h3>
<p><em>Робочий область</em> це набір пакетів, які мають спільний <em>Cargo.lock</em> та каталог для виводу. Створимо проєкт з використанням робочої області — ми будемо використовувати тривіальний код, щоб було легше сконцентруватися на структурі робочого простору. Існує безліч способів упорядкування робочої області, тож ми просто покажемо один з найпоширеніших способів. У нас буде робоча область, що містить двійковий файл і дві бібліотеки. Двійковий файл, який надасть основний функціонал, буде залежати від двох бібліотек. Одна бібліотека надаватиме функцію <code>add_one</code>, а друга функцію <code>add_two</code>. Ці три крейти будуть частиною одної робочої області. Ми почнемо зі створення нового каталогу для робочої області:</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>Далі, в каталозі <em>add</em>, ми створимо файл <em>Cargo.toml</em> який налаштує всю робочу область. Цей файл не матиме секції <code>[package]</code>. Натомість він розпочнеться з секції <code>[workspace]</code>, яка дозволить нам додавати учасників до робочої області, вказавши шлях до пакета із нашим двійковим крейтов; у цьому випадку, цей шлях <em>adder</em>:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<p>Next, we’ll create the <code>adder</code> binary crate by running <code>cargo new</code> within the <em>add</em> directory:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
rm -rf adder
cargo new adder
copy output below
-->
<pre><code class="language-console">$ cargo new adder
     Created binary (application) `adder` package
</code></pre>
<p>Наразі ми можемо зібрати робочу область запустивши <code>cargo build</code>. Файли в вашому каталозі <em>add</em> мають виглядати наступним чином:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>Робоча область має один каталог <em>target</em> на верхньому рівні, де будуть розміщені скомпільовані артефакти; пакет <code>adder</code> не має власного каталогу <em>target</em>. Навіть якщо ми запустимо <code>cargo build</code> зсередини каталогу <em>adder</em>, всі скомпільовані артефакти все одно з'являться в <em>add/target</em>, а не в <em>add/adder/target</em>. Cargo структурує каталог <em>target</em> в робочій області наступним чином, бо крейти в робочому просторі призначені для того, щоб залежати одне від одного. Якщо кожен крейт мав би власний каталог <em>target</em>, то кожен крейт мав би повторно компілювати кожен інший крейт в робочій області, щоб розмістити артефакти в власному каталозі <em>target</em>. При спільному використанні каталогу <em>target</em>, крейти можуть уникнути непотрібних повторних збірок.</p>
<h3 id="Створення-Другого-Пакета-в-Робочій-Області"><a class="header" href="#Створення-Другого-Пакета-в-Робочій-Області">Створення Другого Пакета в Робочій Області</a></h3>
<p>Далі створимо ще один (member) пакет в робочій області і назвемо його <code>add_one</code>. Змініть <em>Cargo.toml</em> верхнього рівня, вказав шлях до <em>add_one</em> в списку <code>members</code>:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add_one&quot;,
]
</code></pre>
<p>Потім згенеруйте новий бібліотечний крейт, названий <code>add_one</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
rm -rf add_one
cargo new add_one --lib
copy output below
-->
<pre><code class="language-console">$ cargo new add_one --lib
     Created library `add_one` package
</code></pre>
<p>Ваш каталог <em>add</em> тепер повинен мати ці каталоги та файли:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>У файлі <em>add_one/src/lib.rs</em>, додамо функцію <code>add_one</code>:</p>
<p><span class="filename">Файл: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>Тепер ми можемо мати пакет <code>adder</code> із нашим двійковим файлом, залежним від пакета <code>add_one</code>, який є в нашій бібліотеці. Спочатку нам потрібно додати шлях залежності <code>add_one</code> в <em>adder/Cargo.toml</em>.</p>
<p><span class="filename">Файл: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
add_one = { path = &quot;../add_one&quot; }
</code></pre>
<p>Cargo doesn’t assume that crates in a workspace will depend on each other, so we need to be explicit about the dependency relationships.</p>
<p>Далі, використаємо функцію <code>add_one</code> (з крейту <code>add_one</code>) в крейті <code>adder</code>. Відкрийте файл <em>adder/src/main.rs</em> і додайте рядок <code>use</code> зверху, щоб внести новий бібліотечний крейт <code>add_one</code> в область видимості. Потім змініть функцію <code>main</code> та викличте функцію <code>add_one</code>, як показано в Блоці Коду 14-7.</p>
<p><span class="filename">Файл: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">use add_one;

fn main() {
    let num = 10;
    println!(
        &quot;Hello, world! {num} plus one is {}!&quot;,
        add_one::add_one(num)
    );
}
</code></pre>
<p><span class="caption">Listing 14-7: Using the <code>add_one</code> library crate from the <code>adder</code> crate</span></p>
<p>Let’s build the workspace by running <code>cargo build</code> in the top-level <em>add</em> directory!</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<p>To run the binary crate from the <em>add</em> directory, we can specify which package in the workspace we want to run by using the <code>-p</code> argument and the package name with <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>Цей код в <em>adder/src/main.rs</em>, що залежить від крейту <code>add_one</code>.</p>
<h4 id="Залежність-від-Зовнішнього-Пакета-в-Робочій-Області"><a class="header" href="#Залежність-від-Зовнішнього-Пакета-в-Робочій-Області">Залежність від Зовнішнього Пакета в Робочій Області</a></h4>
<p>Зауважте, що робоча область має лише один файл <em>Cargo.lock</em> на верхньому рівні, замість того, щоб мати <em>Cargo.lock</em> в кожному каталозі крейту. Завдяки цьому всі крейти використовують однакову версію всіх залежностей. Якщо ми додамо пакет <code>rand</code> в файли <em>adder/Cargo.toml</em> та <em>add_one/Cargo.toml</em>, Cargo вирішить використовувати одну версію <code>rand</code> для обох та запише це в одному <em>Cargo.lock</em>. Використання одних і тих самих залежностей для всіх крейтів в одній робочій області означає, що крейти завжди будуть сумісні один з одним. Додамо крейт <code>rand</code> в секцію <code>[dependencies]</code> в файл <em>add_one/Cargo.toml</em>, щоб ми могли використовувати крейт <code>rand</code> в крейті <code>add_one</code>:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-->
<p><span class="filename">Файл: add_one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.3&quot;
</code></pre>
<p>Тепер ми можемо додати <code>use rand;</code> в файл <em>add_one/src/lib.rs</em> і збірка цілої робочої області, запустивши <code>cargo build</code> в каталозі <em>add</em>, принесе та скомпілює крейт <code>rand</code>. Ми отримаємо одне попередження, бо ми не посилаємось на принесений <code>rand</code> в нашій області видимості:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
   --snip--
   Compiling rand v0.8.5
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 --&gt; add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `add_one` (lib) generated 1 warning
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<p><em>Cargo.lock</em> на верхньому рівні тепер містить інформацію про залежність <code>add_one</code> від <code>rand</code>. Однак, навіть якщо <code>rand</code> використовується десь в робочій області, ми не можемо використовувати його в інших крейтах в робочій області, якщо також не додамо <code>rand</code> до їхніх файлів <em>Cargo.toml</em>. Наприклад, якщо ми додамо <code>use rand;</code> в файл <em>adder/src/main.rs</em> пакету <code>adder</code>, ми отримаємо помилку:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<p>Щоб це виправити, відредагуйте файл <em>Cargo.toml</em> пакету <code>adder</code> і вкажіть, що <code>rand</code> і для нього є залежністю. Збірка пакету <code>adder</code> додасть <code>rand</code> в список залежностей <code>adder</code> в <em>Cargo.lock</em>, але жодних додаткових копій <code>rand</code> не буде завантажено. Cargo має гарантувати, що кожен крейт у кожному пакеті в робочій області використовує пакет <code>rand</code> однакової версії, що збереже нам простір та запевнить, що крейти в робочій області будуть сумісними один з одним.</p>
<h4 id="Додавання-Тесту-до-Робочої-Області"><a class="header" href="#Додавання-Тесту-до-Робочої-Області">Додавання Тесту до Робочої Області</a></h4>
<p>For another enhancement, let’s add a test of the <code>add_one::add_one</code> function within the <code>add_one</code> crate:</p>
<p><span class="filename">Файл: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
</code></pre>
<p>Тепер запустіть <code>cargo test</code> в найвищому рівні каталогу <em>add</em>. Запуск <code>cargo test</code> в робочій області із подібною до цієї структурою буде запускати тести усіх крейтів цієї робочої області:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in
paths properly
-->
<pre><code class="language-console">$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running unittests src/lib.rs (target/debug/deps/add_one-f0253159197f7841)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/adder-49979ff40686fa8e)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Перша секція виводу показує, що тест <code>it_works</code> крейту <code>add_one</code> проходить. Наступна секція показує, що нуль тестів було знайдено в крейті <code>adder</code>, і потім, остання секція показує нуль документаційних тестів в крейті <code>add_one</code>.</p>
<p>We can also run tests for one particular crate in a workspace from the top-level directory by using the <code>-p</code> flag and specifying the name of the crate we want to test:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add_one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test -p add_one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/lib.rs (target/debug/deps/add_one-b3235fea9a156f74)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>This output shows <code>cargo test</code> only ran the tests for the <code>add_one</code> crate and didn’t run the <code>adder</code> crate tests.</p>
<p>Якщо ви опублікували крейти в робочій області до <a href="https://crates.io/">crates.io</a>, то кожен крейт в робочій області потрібно буде публікувати окремо. Як із <code>cargo test</code>, ми можемо публікувати певний крейт із нашої робочої області використовуючи позначку <code>-p</code> та вказуючи назву крейту, який ми хочемо опублікувати.</p>
<p>For additional practice, add an <code>add_two</code> crate to this workspace in a similar way as the <code>add_one</code> crate!</p>
<p>У міру зростання вашого проєкту, розгляньте можливість використання робочої області: легше зрозуміти менші, окремі компоненти ніж один великий блоб коду. Щобільше, зберігаючи крейти в робочій області можна зробити координацію між крейтами легшою, якщо вони часто та одночасно змінюються.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old link, do not remove -->
<p><a id="installing-binaries-from-cratesio-with-cargo-install"></a></p>
<h2 id="Встановлення-Двійкових-Файлів-з-cargo-install"><a class="header" href="#Встановлення-Двійкових-Файлів-з-cargo-install">Встановлення Двійкових Файлів з <code>cargo install</code></a></h2>
<p>Команда <code>cargo install</code> дозволяє встановлювати і використовувати бінарні крейти локально. Це не має на меті замінити системні пакети; Це має бути зручним способом для Rust розробників встановити інструменти, якими інші поділилися на <a href="https://crates.io/">crates.io</a><!-- ignore -->. Зауважте, що ви можете встановлювати лише пакети, які мають цільовий двійковий файл. <em>Цільовий двійковий файл</em> це запускаєма програма, яка створюється, якщо крейт має файл <em>src/main.rs</em> або інший файл вказаний, як двійковий, на відміну від цільового бібліотечного файлу, який не можна запускати сам по собі, але який є придатним для додавання всередину інших програм. Зазвичай крейти мають інформацію в файлі <em>README</em> про те, чи крейт це бібліотека, має двійкову ціль, або й те й інше.</p>
<p>Всі встановлені з <code>cargo install</code> двійкові файли зберігаються в теці <em>bin</em> кореневого каталогу встановлення. Якщо ви встановили Rust із <em>rustup.rs</em> і не маєте жодних користувацьких конфігурацій, то цей каталог буде <em>$HOME/.cargo/bin</em>. Переконайтеся, що каталог є в вашому <code>$PATH</code>, щоб мати можливість запускати встановленні з <code>cargo install</code> програми.</p>
<p>Наприклад, у Розділі 12 ми згадували, що існує Rust імплементація інструменту <code>grep</code> під назвою <code>ripgrep</code> для пошуку файлів. Щоб встановити <code>ripgrep</code>, ми запустимо наступне:</p>
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-->
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v13.0.0
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v13.0.0
--snip--
   Compiling ripgrep v13.0.0
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
</code></pre>
<p>Передостанній рядок виводу показує розташування і назву встановленого двійкового файлу, який у випадку <code>ripgrep</code> має назву <code>rg</code>. Допоки у вашому <code>$PATH</code> є каталог встановлення, як говорилося раніше, ви зможете запускати <code>rg --help</code> та починати використовувати швидший, іржавіший інструмент для пошуку файлів!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Розширення-cargo-із-Користувацькими-Командами"><a class="header" href="#Розширення-cargo-із-Користувацькими-Командами">Розширення Cargo із Користувацькими Командами</a></h2>
<p>Cargo розроблений таким чином, щоб ви могли розширювати його за допомогою нових підкоманд без необхідності модифікації Cargo. Якщо двійковий файл у вашому <code>$PATH</code> названий <code>cargo-something</code>, то ви можете запустити його, ніби це підкоманда Cargo, викликавши <code>cargo something</code>. Користувальницькі команди, такі як ця, також зазначені під час запуску <code>cargo --list</code>. Можливість використати <code>cargo install</code> для встановлення розширень, а потім запускати їх, так само як і вбудовані інструменти Cargo є дуже зручною перевагою дизайну Cargo!</p>
<h2 id="Підсумок-13"><a class="header" href="#Підсумок-13">Підсумок</a></h2>
<p>Обмін кодом використовуючи Cargo і <a href="https://crates.io/">crates.io</a><!-- ignore --> є частиною того, що робить екосистему Rust корисною для багатьох різноманітних задач. Стандартна бібліотека Rust маленька та стабільна, але крейтами легко ділитися, використовувати та покращувати за графіком, відмінним від графіка розвитку мови. Не соромтеся ділитися корисними для вас кодом на <a href="https://crates.io/">crates.io</a><!-- ignore
-->; цілком ймовірно, що це буде корисно і комусь іншому!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Розумні-вказівники"><a class="header" href="#Розумні-вказівники">Розумні вказівники</a></h1>
<p><em>Вказівник</em> - загальна концепція для змінної, що містить адресу в пам'яті. Ця адреса посилається, або &quot;вказує&quot;, на певну інформацію. Найбільш розповсюджений вид вказівника в Rust - це посилання, яке ви вивчили в Розділі 4. Посилання позначені символом <code>&amp;</code> та позичають значення, на яке вказують. Вони не мають інших можливостей, крім посилання на дані, та не мають накладних витрат.</p>
<p><em>Розумні вказівники</em>, з іншої сторони, є структурами даних що поводять себе як вказівник, але також мають додаткові метадані та можливості. Концепція розумних вказівників не унікальна для Rust: розумні вказівники виникли в C++ та також існують в інших мовах програмування. Rust має різні розумні вказівники, визначені стандартною бібліотекою, які надають додатковий функціонал, крім наданого посиланнями. Для роз'яснення основної концепції ми подивимось на різні приклади розумних вказівників, включно з типом розумних вказівників, що <em>підраховує посилання</em>. Цей вказівник дозволяє даним мати декілька володільців завдяки відстежуванню кількості володільців. Коли володільців не залишається, інформація буде видалена.</p>
<p>Оскільки Rust має власну концепцію володіння та позичання, є додаткова різниця між посиланнями та розумними вказівниками: посилання лише позичають значення, але в багатьох випадках розумні вказівники <em>володіють</em> значенням, на яке вказують.</p>
<p>Хоча ми й не називати їх так на той момент, ми вже зустрілись з деякими розумними вказівниками в цій книзі, включно зі <code>String</code> та <code>Ve&lt;T&gt;</code> у Розділі 8. Обидва типи вважаються розумними вказівниками, оскільки вони володіють деякою пам'яттю і дозволяють вам маніпулювати нею. Вони також мають метадані та додаткові можливості чи гарантії. <code>String</code>, наприклад, зберігає свою місткість як метадані та має додаткову спроможність гарантувати, що його дані будуть валідним UTF-8.</p>
<p>Розумні вказівники зазвичай реалізуються за допомогою структур. На відміну від звичайних структур, розумні вказівники реалізують трейти <code>Deref</code> та <code>Drop</code>. Трейт <code>Deref</code> дозволяє екземпляру структури розумного вказівника поводитись, як посилання, тож ви можете писати свій код, що працюватиме як із посиланнями, так і з розумними вказівниками. Трейт <code>Drop</code> дозволяє змінити код, що виконується при виході екземпляра розумного вказівника з області видимості. У цьому розділі буде розглянуто обидва трейта та продемонстровано, чому вони важливі для розумних вказівників.</p>
<p>Оскільки паттерн розумного вказівника є загальним паттерном проєктування, що часто використовується в Rust, цей розділ не розглядає усі можливі розумні вказівники. Багато бібліотек мають власні розумні вказівки, і ви навіть можете написати свої власні. Ми розглянемо найпоширеніші розумні вказівники стандартної бібліотеки:</p>
<ul>
<li><code>Box&lt;T&gt;</code> для розміщення значень в heap</li>
<li><code>Rc&lt;T&gt;</code>, тип з підрахунком посилань, який уможливлює множинне володіння</li>
<li><code>Ref&lt;T&gt;</code> та <code>RefMut&lt;T&gt;</code>, accessed through <code>RefCell&lt;T&gt;</code>, тип що забезпечує виконання правил запозичення під час виконання, а не компіляції</li>
</ul>
<p>Додатково ми розглянемо паттерн <em>внутрішньої мутабельності</em>, де немутабельний тип надає API для зміни внутрішнього значення. Також будуть розглянуті <em>зациклювання посилань</em>: як вони можуть розтратити пам'ять та як цьому запобігти.</p>
<p>Отже, вперед!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Використання-boxt-для-Вказування-на-Значення-в-heap"><a class="header" href="#Використання-boxt-для-Вказування-на-Значення-в-heap">Використання <code>Box&lt;T&gt;</code> для Вказування на Значення в Heap</a></h2>
<p>Найбільш простий розумний вказівник це <em>box</em>, тип якого записано в <code>Box&lt;T&gt;</code>. Box дозволяє зберігати дані в heap, а не на стеку. На стеку залишається вказівник на значення в Heap. Перегляньте Розділ 4, щоб побачити різницю між стеком та купою.</p>
<p>Коробки не мають накладних витрат, окрім як зберігання даних в heap замість того, щоб розміщувати дані на стеку. Але у них також немає багато додаткових можливостей. Найчастіше ви будете використовувати їх у таких ситуаціях:</p>
<ul>
<li>Якщо у вас є тип, розмір якого не може бути відомий при компілюванні і ви хочете використати значення цього типу в контексті, який вимагає точного розміру</li>
<li>Якщо у вас є велика кількість даних і ви хочете передати володіння, але хочете гарантії, що дані не будуть скопійовані після виконання</li>
<li>Коли ви бажаєте володіти значенням та вам важливо лише, що тип реалізує певний трейт, а не є певним типом</li>
</ul>
<p>Ми продемонструємо першу ситуацію в <a href="ch15-01-box.html#enabling-recursive-types-with-boxes">&quot;Рекурсивні типи з Box&quot;</a><!-- ignore --> секції. У другому випадку передача володіння великої кількості даних може зайняти багато часу тому, що дані копіюються зі стеку. Щоб підвищити продуктивність в такій ситуації, ми можемо зберігати велику кількість даних в Heap в box. Копіюється тільки невелика кількість даних вказівника у стеку, в той час як дані, на яких він посилається, залишається в одному місці в Heap. Третій випадок - відомий як трейт об'єкт **, займає весь розділ 17, <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">&quot;Використання трейт об'єктів, які допускають значення різних типів&quot;, </a><!--
ignore --> Отже, що ви знаєте тут, ви будете використовувати ще раз в Розділі 17!</p>
<h3 id="Використання-boxt-для-зберігання-Значення-в-heap"><a class="header" href="#Використання-boxt-для-зберігання-Значення-в-heap">Використання <code>Box&lt;T&gt;</code> для зберігання Значення в Heap</a></h3>
<p>Перед тим як обговорити випадок зберігання даних в Heap в <code>Box&lt;T&gt;</code>ми розглянемо синтаксис і як взаємодіяти зі значеннями, що зберігаються в <code>Box&lt;T&gt;</code>.</p>
<p>Блок коду 15-1 показує, як використовувати Box для збереження значення типу <code>i32</code> у купі:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-1: Збереження <code>i32</code> значення в Heap з використанням box</span></p>
<p>Ми визначили змінну <code>b</code> що має значення <code>Box</code>, яке вказує на значення <code>5</code>, яке виділяється в heap. Ця програма виведе на екран <code>b = 5</code>; в цьому випадку, ми можемо отримати доступ до даних у box, аналогічно до того, як ми могли б зробити так, якби дані були на стеку. Будь-яке значення, наприклад коли box виходить за scope, як це робить <code>b</code> в кінці <code>main</code>, буде звільнено. Звільнення відбувається як для коробки (на стеці), так і для значення на яке вказує (зберігаються в heap).</p>
<p>Розміщення одного значення в heap не дуже ефективно, тому таким чином ви будете робити не часто. Мати значення як один <code>i32</code> на стеку, де вони зберігаються за замовчуванням, більш підходить для більшості ситуацій. Розглянемо випадок, де box дозволяють нам використати типи які ми б не могли застосувати без box.</p>
<h3 id="Рекурсивні-типи-з-box"><a class="header" href="#Рекурсивні-типи-з-box">Рекурсивні типи з Box</a></h3>
<p>Складовою <em>рекурсивного типу</em> може бути значення того цього ж типу. Реалізація рекурсивного типу може бути проблемою, бо при компіляції Rust потрібно знати скільки місця займає тип. Однак вкладеність значень рекурсивних типів теоретично може тривати нескінченно, тому Rust не може знати, скільки пам'яті потребує значення. Оскільки box має відомий розмір, ми можемо реалізувати рекурсивні типи вставленням box у визначення рекурсивного типу.</p>
<p>Як приклад рекурсивного типу, давайте дослідимо <em>cons list</em>. Це тип даних, який зазвичай зустрічається у функціональних мовах програмування. Тип cons list ми визначимо його напряму, за винятком рекурсії. Концепції у прикладі, з якими ми працюватимемо, будуть корисними при потраплянні у складніші ситуації, що стосуються рекурсивних типів.</p>
<h4 id="Більше-інформації-про-cons-list"><a class="header" href="#Більше-інформації-про-cons-list">Більше інформації про cons list</a></h4>
<p><em>Cons list</em> — це структура даних, що прийшла із мови програмування Lisp та його діалектів. Структура складається з вкладених пар, і є різновидом зв'язаного списку в Lisp. Ця назва походить з <code>cons</code> функції (коротко для функції &quot;construct function&quot;) в Lisp, яка формує нову пару з двох аргументів. Викликанням <code>cons</code> до пари зі значенням та іншою парою, ми можемо створювати зв'язані списки з рекурсивних пар.</p>
<p>Наприклад, ось набір псевдокоду, що представляє зв'язаний список з 1, 2, 3 з кожною парою в дужках:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Кожен елемент у cons list містить два елементи: значення поточного елемента і наступного елементу. Останній елемент списку містить значення <code>Nil</code>, що означає відсутність наступного елемента. Cons list створюєтся рекурсивним викликанням функції <code>cons</code>. Канонічне ім'я для позначення загального випадку рекурсії <code>Nil</code>. Зверніть увагу, що це не те саме, що &quot;null&quot; або &quot;nil&quot; концепція у Розділі 6, яке є недійсним або відсутнім значенням.</p>
<p>Cons list не є загально вживаною структурою даних в Rust. В більшості випадків, коли у вас є список елементів в Rust, <code>Vec&lt;T&gt;</code> є кращим варіантом для використання. Більш складні типи рекурсивних даних <em>корисні в різних ситуаціях</em>, але починаючи з cons list у цьому розділі, ми можемо ясніше дослідити, як box дає змогу визначити тип рекурсивних даних.</p>
<p>Блок коду 15-2 містить визначення енума для cons list. Зверніть увагу, що цей код не скомпілюється, тому що тип <code>List</code> не має відомого розміру, що ми продемонструємо.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p><span class="caption">Блок коду 15-2: Перша спроба визначення енума що представляє cons list значень типу <code>i32</code></span></p>
<blockquote>
<p>Примітка: Ми реалізуємо cons list, який містить лише значення <code>i32</code> як приклад. Ми могли б реалізувати її за допомогою generic, які ми розглянули у розділі 10, щоб визначити cons list для збереження значення будь-якого типу.</p>
</blockquote>
<p>Використовування типу <code>List</code>, щоб зберегти список з <code>1, 2, 3</code> буде виглядати як код в Блоці коду 15-3:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<p><span class="caption">Роздрук 15-3: Використання енуму <code>List</code> для збереження списку <code>1, 2, 3</code></span></p>
<p>Перший <code>Cons</code> містить значення <code>1</code> та значення <code>List</code>. Цей <code>List</code> - інший <code>Cons</code>, який містить <code>2</code> і ще одне значення <code>List</code>. Значення <code>List</code> є ще одним <code>Cons</code>, яке містить <code>3</code> і <code>Cons</code> який нарешті <code>Nil</code>, нерекурсивний варіант, який сигналізує про кінець списку.</p>
<p>Якщо ми спробуємо скомпілювати код у Роздруку 15-3, ми отримаємо помилку, показану в Роздруку 15-4:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing drop-check constraints for `List`
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing drop-check constraints for `List` again
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, value: List } }`

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` due to 2 previous errors
</code></pre>
<p><span class="caption">Блок коду 15-4: Помилка, яку ми отримуємо при спробі визначити рекурсивний енум</span></p>
<p>Помилка показує, що цей тип &quot;має нескінченний розмір.&quot; Причина в тому, що ми визначили <code>List</code> з варіантом, який рекурсивний: він складається зі значення свого ж типу. Як результат, Rust не може визначити скільки місця йому потрібно для <code>List</code>. Розберімось, чому ми отримуємо цю помилку. Спочатку ми подивимось на те, як Rust вирішує, скільки місця їй потрібно зберегти значення не рекурсивного типу.</p>
<h4 id="Обчислення-Розміру-Нерекурсивного-Типу"><a class="header" href="#Обчислення-Розміру-Нерекурсивного-Типу">Обчислення Розміру Нерекурсивного Типу</a></h4>
<p>Розглянемо повторно <code>Message</code> енум з Розділу 6-2 коли ми дізнались про енум в Розділі 6:</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Щоб визначити скільки займати місця для <code>Message</code> Rust проходить через кожен з варіантів, щоб побачити, який варіант потребує найбільше місця. Rust бачить що <code>Message::Quit</code> не потрібно місця. <code>Message::Move</code> достатньо місця як для зберігання 2 <code>i32</code> значень, і так далі. Тому що використовуватиметься лише один варіант, <code>Message</code> буде займати як найбільший з можливих своїх варіантів.</p>
<p>Порівняйте це з тим, що відбувається, коли Rust намагається визначити скільки місця займає рекурсивний тип <code>Cons</code> в Роздруку 15-2. Компілятор дивиться на варіант <code>Cons</code> який містить значення типу <code>i32</code> та значення типу <code>Cons</code>. Відповідно, <code>Cons</code> потребує пам'яті, що дорівнює розміру <code>i32</code> плюс розмір <code>Cons</code>. Щоб дізнатись скільки пам'яті потребує <code>List</code>, компілятор дивиться на варіанти, починаючи з <code>Cons</code>. <code>Cons</code> є значенням типу <code>i32</code> і значення типу <code>Cons</code>, і цей процес нескінченно продовжується як показано на Рисунку 15-1.</p>
<img alt="Нескінченних список з Cons" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Рисунок 15-1: Нескінченний <code>List</code> що складається з безлічі <code>Cons</code> варіантів</span></p>
<h4 id="Використання-boxt-для-Рекурсивного-типу-з-Відомим-Розміром"><a class="header" href="#Використання-boxt-для-Рекурсивного-типу-з-Відомим-Розміром">Використання <code>Box&lt;T&gt;</code> для Рекурсивного типу з Відомим Розміром</a></h4>
<p>Оскільки Rust не може визначити скільки пам'яті для рекурсивно визначених типів, компілятор надає помилку з корисною пропозицією:</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>У цій пропозиції &quot;indirection&quot; (опосередкованість) означає, що замість того, щоб зберігати значення безпосередньо, ми повинні змінити структуру даних, щоб зберігати значення опосередковано, зберігаючи замість нього вказівник на значення.</p>
<p>Тому що <code>Box&lt;T&gt;</code> є вказівником, Rust завжди знає, скільки потрібно пам'яті для <code>Box&lt;T&gt;</code>: розмір вказівника не залежить від розміру типу даних, на які вказує. Це означає, що ми можемо розмістити <code>Cons</code> в <code>Box&lt;T&gt;</code> замість напряму <code>Cons</code>. <code>Box&lt;T&gt;</code> вказує на наступний <code>List</code>, яке буде в Heap, а не в <code>Cons</code>. Таким чином, у нас все ще є список, створений з іншими списками, що тримає інші списки, але ця реалізація тепер більше схожа на розміщення елементів один біля одного, а не всередині один одного.</p>
<p>Ми можемо змінити визначення енуму <code>List</code> з Роздруку 15-2 і використання <code>List</code> в Роздруку 15-3 до коду в Роздруку 15-5 що буде компілюватись в:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-5: визначення <code>List</code>, який використовує <code>Box&lt;T&gt;</code>, щоб мати відомий розмір</span></p>
<p><code>Cons</code> потрібно мати розмір <code>i32</code> плюс пам'ять для зберігання даних вказівника box. Варіант <code>Nil</code> не зберігає значення, тому йому потрібно менше місця, ніж <code>Cons</code>. Ми тепер знаємо, що будь-яке значення <code>Cons</code> займе розмір <code>i32</code> плюс розмір вказівника box. Використовуючи box, ми зламали нескінченний, рекурсивний ланцюжок, таким чином, компілятор може визначити розмір, який йому потрібно щоб зберегти <code>List</code>. Рисунок 15-2 показує як зараз виглядає варіант <code>Cons</code>.</p>
<img alt="Скінченний список з Cons" src="img/trpl15-02.svg" class="center" />
<p><span class="caption">Рисунок 15-2: <code>List</code> який не є нескінченним розміром, тому що <code>List</code> містить <code>Box</code></span></p>
<p>Box забезпечує лише розміщення в Heap; у них немає жодних інших спеціальних можливостей, які ми побачимо в інших розумних вказівниках. Також вони не мають накладних витрат на ці спеціальні можливості, тож вони можуть бути корисні у випадках як cons list, де розміщення в іншому місці для того, щоб мати вказівник відомого розміру - все що нам потрібно. Ми також розглянемо застосування box в Розділі 17.</p>
<p><code>Box&lt;T&gt;</code> є розумним вказівником, оскільки реалізує трейт <code>Deref</code> що дозволяє <code>Box&lt;T&gt;</code> застосовувати як посилання. Коли значення <code>Box&lt;T&gt;</code> виходить з області видимості, дані в купі, на які вказує box, видаляться через реалізацію трейту <code>Drop</code>. Ці трейти будуть ще важливіші для функціональності, які надають інші розумні вказівники, які ми обговоримо в інших главах цього розділу. Розгляньмо ці трейти детальніше.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Використання-розумних-вказівників-як-звичайних-посилань-за-допомогою-трейта-deref"><a class="header" href="#Використання-розумних-вказівників-як-звичайних-посилань-за-допомогою-трейта-deref">Використання розумних вказівників як звичайних посилань за допомогою трейта <code>Deref</code></a></h2>
<p>Реалізація трейта <code>Deref</code> дозволяє вам налаштувати поведінку <em>оператора розіменування</em> <code>*</code> (не плутати з оператором множення чи глобальним оператором). Релізувавши <code>Deref</code> таким чином, щоб розумний вказівник міг використовуватися як звичайне посилання, ви зможете писати код, що працює з посиланнями і використовувати цей код також із розумними вказівниками.</p>
<p>Спочатку подивімося, як оператор розіменування працює зі звичайними посиланнями. Потім ми спробуємо визначити власний тип, що поводиться як <code>Box&lt;T&gt;</code>, і побачимо, чому оператор розіменування не працює, як посилання, для нашого щойно визначеного типу. Ми дослідимо, як реалізація трейта <code>Deref</code> дозволяє розумним вказівникам працювати у спосіб, схожий на посилання. Тоді ми розглянемо таку особливість Rust, як <em>приведення при розіменуванні</em> і як вона дозволяє нам працювати як із посиланнями, так і з розумними вказівниками.</p>
<blockquote>
<p>Примітка: існує суттєва різниця між типом <code>MyBox&lt;T&gt;</code>, який ми збираємося описати, і справжнім <code>Box&lt;T&gt;</code>: наша версія не зберігатиме дані в купі. Ми зосередимося у цьому прикладі на  <code>Deref</code>, тож нам не так важливо, де насправді зберігаються дані, ніж поведінка, подібна до вказівника.</p>
</blockquote>
<!-- Old link, do not remove -->
<p><a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a></p>
<h3 id="Перехід-за-вказівником-до-значення"><a class="header" href="#Перехід-за-вказівником-до-значення">Перехід за вказівником до значення</a></h3>
<p>Звичайне посилання — це тип вказівника. Вказівник можна уявити як стрілку, що вказує на значення, розміщене деінде. У Блоці коду 15-6 ми створюємо посилання на значення <code>i32</code>, а потім використовуємо оператор розіменування, щоб перейти за посиланням до значення:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-6: використання оператор розіменування, щоб перейти за посиланням до значення <code>i32</code></span></p>
<p>Змінна <code>x</code> має значення <code>5</code> типу <code>i32</code>. Ми встановили значення <code>у</code> рівним посиланню на <code>x</code>. Ми можемо стверджувати, що <code>x</code> дорівнює <code>5</code>. Проте, якщо ми хочемо зробити твердження про значення в <code>y</code>, ми повинні виконати <code>*y</code>, щоб перейти за посиланням до значення, на яке воно вказує (тобто <em>розіменувати</em>), щоб компілятор міг порівняти фактичне значення. Розіменувавши <code>y</code>, ми отримуємо доступ до цілого значення, на яку <code>y</code> вказує, яке ми можемо порівняти з <code>5</code>.</p>
<p>Якби ми спробували написати натомість <code>assert_eq!(5, y);</code>, то отримали б помилку компіляції:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` due to previous error
</code></pre>
<p>Порівняння числа і посилання на число не дозволене, оскільки це різні типи. Ми маємо використовувати оператор розіменування, щоб перейти за посиланням до значення, на яке воно вказує.</p>
<h3 id="Використання-boxt-як-посилання"><a class="header" href="#Використання-boxt-як-посилання">Використання <code>Box&lt;T&gt;</code> як посилання</a></h3>
<p>Ми можемо переписати код у Блоці коду 15-6, щоб використовувати <code>Box&lt;T&gt;</code> замість посилання; оператор розіменування, застосований до <code>Box&lt;T&gt;</code> у Блоці коду 15-7 працює так само як і оператор розіменування, застосований до посилання у Блоці коду 15-6:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-7: використання оператору розіменування на <code>Box&lt;i32&gt;</code></span></p>
<p>Основна відмінність між Блоком коду 15-7 і Блоком коду 15-6 полягає в тому, що в першому ми робимо <code>y</code> екземпляром <code>Box&lt;T&gt;</code>, що вказує на скопійоване значення <code>x</code>, а не посиланням, що вказує на значення <code>x</code>. В останньому твердженні ми можемо використати оператор розіменування, щоб перейти за вказівником у <code>Box&lt;T&gt;</code> так само як ми робили, коли <code>y</code> був посиланням. Далі ми дослідимо, що ж такого в <code>Box&lt;T&gt;</code> дає нам змогу використовувати оператор розіменування, визначивши власний тип MyBox.</p>
<h3 id="Визначення-власного-розумного-вказівника"><a class="header" href="#Визначення-власного-розумного-вказівника">Визначення власного розумного вказівника</a></h3>
<p>Створімо розумний вказівник, схожий на тип <code>Box&lt;T&gt;</code>, що надається стандартною бібліотекою, щоб побачити, у чому розумні вказівники поводяться інакше, ніж вказівники за замовчанням. Тоді ми розглянемо, як додати можливість використовувати оператор розіменування.</p>
<p>Тип <code>Box&lt;T&gt;</code> кінець-кінцем визначається як структура-кортеж з одним елементом, тож Блок коду 15-8 визначає тип <code>MyBox&lt;T&gt;</code> у той же спосіб. Ми також визначаємо функцію <code>new</code>, що відповідає функції <code>new</code>, визначеній для <code>Box&lt;T&gt;</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Блок коду 15-8: визначення типу <code>MyBox&lt;T&gt;</code></span></p>
<p>Ми визначаємо структуру з назвою <code>MyBox</code> і оголошуємо узагальнений параметр <code>T</code>, оскільки ми хочемо, щоб наш тип працював зі значеннями будь-якого типу. Тип <code>MyBox</code> є структурою-кортежем з одним елементом типу <code>T</code>. Функція <code>MyBox::new</code> приймає один параметр типу <code>T</code> і повертає екземпляр <code>MyBox</code>, який містить передане значення.</p>
<p>Спробуймо додати функцію <code>main</code> з Блока коду 15-7 до Блоку коду 15-8 та змінити її, щоб використовувати визначений нами тип <code>MyBox&lt;T&gt;</code> замість <code>Box&lt;T&gt;</code>. Код у Блоці коду 15-9 не компілюється, оскільки Rust не знає, як розіменувати <code>MyBox</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<p><span class="caption">Блок коду 15-9: спроба використовувати <code>MyBox&lt;T&gt;</code> тим самим способом, яким ми використовували посилання та <code>Box&lt;T&gt;</code></span></p>
<p>Виходить ось така помилка компіляції:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` due to previous error
</code></pre>
<p>Наш тип <code>MyBox&lt;T&gt;</code> не можна розіменовувати, оскільки ми не реалізували цю здатність для нашого типу. Щоб дозволити розіменування за допомогою оператора <code>*</code>, ми реалізуємо трейт <code>Deref</code>.</p>
<h3 id="Реалізація-трейту-deref-для-використання-типу-як-посилання"><a class="header" href="#Реалізація-трейту-deref-для-використання-типу-як-посилання">Реалізація трейту <code>Deref</code> для використання типу як посилання</a></h3>
<p>Як обговорено в підрозділі <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">&quot;Реалізація трейту для типів&quot;</a><!-- ignore
--> Розділу 10, щоб реалізувати трейт, ми маємо реалізувати методи, необхідні цьому трейту. Трейт </p>
<p><code>Deref</code>, наданий стандартною бібліотекою, вимагає, щоб ми реалізувати один метод, що зветься <code>deref</code>, який позичає <code>self</code> і повертає посилання на внутрішні дані. Блок коду 15-10 містить реалізацію <code>Deref</code>, яку треба додати до визначення <code>MyBox</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 15-10: реалізація <code>Deref</code> для <code>MyBox&lt;T&gt;</code></span></p>
<p>Запис <code>type Target = T;</code> визначає асоційований тип для використання трейтом <code>Deref</code>. Асоційовані типи дещо відрізняються від оголошення узагальненого параметра, але вам поки що не потрібно турбуватися про них; ми розглянемо її детальніше у Розділі 19.</p>
<p>В тіло методу <code>deref</code> ми додаємо <code>&amp;self.0</code>, тож <code>Deref</code> повертає посилання на значення, до якого ми хочемо отримати доступ за допомогою оператора <code>*</code>; згадайте з підрозділу <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">&quot;Структури-кортежі без іменованих полів для створення нових типів&quot;</a><!-- ignore --> Розділу 5, що <code>.0</code> є способом доступу до першого значення у структурі-кортежі. Функція <code>main</code> у Блоці коду 15-9, яка викликає <code>*</code> для значення <code>MyBox&lt;T&gt;</code> тепер компілюється, і твердження виконуються!</p>
<p>Без трейту <code>Deref</code> компілятор може розіменовувати лише посилання <code>&amp;</code>. Метод <code>deref</code> надає компілятору можливість взяти значення будь-якого типу, який реалізує <code>Deref</code>, і викликати метод <code>deref</code>, щоб отримати посилання <code>&amp;</code>, яке він вміє розіменовувати.</p>
<p>Коли ми ввели <code>*y</code> у Блоці коду 15-9, за лаштунками Rust насправді запустився цей код:</p>
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<p>Rust замінює оператор <code>*</code> викликом методу <code>deref</code>, а потім звичайне розіменування, тож нам не треба думати, треба чи не треба викликати метод <code>deref</code>. Це особливість Rust дозволяє нам писати код, що працює так само, використовуємо ми звичайні посилання чи тип, що реалізує <code>Deref</code>.</p>
<p>Причина, з якої метод <code>deref</code> повертає посилання на значення, і що за дужками <code>*(y.deref())</code> все ще потрібне звичайне розіменування, стосується системи володіння. Якби метод <code>deref</code> повертав значення безпосередньо замість посилання на значення, значення було б переміщене з <code>self</code>. Ми не хочемо у цьому випадку брати володіння внутрішнім значенням у <code>MyBox&lt;T&gt;</code>, як і в більшості випадків, де ми використовуємо оператор розіменування.</p>
<p>Зверніть увагу, що оператор <code>*</code> замінюється на виклик метод <code>deref</code>, а потім виклик оператора <code>*</code> лише один раз, щоразу, коли ми використовуємо <code>*</code> у нашому коді. Оскільки підставляння оператора <code>*</code> не виконується рекурсивно до нескінченості, ми прийдемо до даних типу <code>i32</code>, що відповідають <code>5</code> у <code>assert_eq!</code> у Блоці коду 15-9.</p>
<h3 id="Неявне-приведення-розіменування-у-функціях-та-методах"><a class="header" href="#Неявне-приведення-розіменування-у-функціях-та-методах">Неявне приведення розіменування у функціях та методах</a></h3>
<p><em>Приведення розіменування</em> перетворює посилання на тип, що реалізує трейт <code>Deref</code>, до посилання на інший тип. Наприклад, приведення розіменування може перетворити <code>&amp;String</code> на <code>&amp;str</code>, тому що <code>String</code> реалізує трейт <code>Deref</code>, так, що він повертає <code>&amp;str</code>. Приведення розіменування - це покращення для зручності, яке Rust застосовує до аргументів функцій та методів, і працює лише з типами, що реалізують трейт <code>Deref</code>. Воно застосовується автоматично, коли ми передаємо посилання на значення певного типу як аргумент функції чи метода, що не відповідає типу параметра у визначенні функції чи метода. Послідовність викликів методу <code>deref</code> перетворює тип, наданий нами, на тип, потрібний параметру.</p>
<p>Приведення розіменування було додане в Rust, щоб програмістам, що пишуть виклики функцій та методів, не було потрібно додавати стільки явних посилань і розіменувань за допомогою <code>&amp;</code> і <code>*</code>. Приведення розіменування також дозволяє легше писати код, що працює як з посиланнями, так і з розумними вказівниками.</p>
<p>Щоб побачити, як працює приведення розіменування, застосуймо тип <code>MyBox&lt;T&gt;</code>, який ми визначили у Блоці коду 15-8, разом із реалізацією <code>Deref</code>, яку ми додали в Блоці коду 15-10. Блок коду 15-11 показує визначення функції, що має параметром стрічковий слайс:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn hello(name: &amp;str) {
    println!(&quot;Hello, {name}!&quot;);
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Блок коду 15-11: Функція <code>hello</code>, що має параметр <code>name</code> типу <code>&amp;str</code></span></p>
<p>Ми можемо викликати функцію <code>hello</code> аргументом - стрічковим слайсом, наприклад <code>hello(&quot;Rust&quot;);</code>. Приведення розіменування уможливлює виклик <code>hello</code> з посиланням на значення типу <code>MyBox&lt;String&gt;</code>, як показано в Блоці коду 15-12:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {name}!&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-12: Виклик <code>hello</code> з посиланням на значення <code>MyBox&lt;String&gt;</code>, яке працює завдяки приведенню розіменування</span></p>
<p>Тут ми викликаємо функцію <code>hello</code> з аргументом <code>&amp;m</code>, який є посиланням на значення типу <code>MyBox&lt;String&gt;</code>. Оскільки ми реалізували трейт <code>Deref</code> для <code>MyBox&lt;T&gt;</code> у Блоці коду 15-10, Rust може перетворити <code>&amp;MyBox&lt;String&gt;</code> на <code>&amp;String</code> викликавши <code>deref</code>. Стандартна бібліотека надає реалізацію <code>Deref</code> для <code>String</code>, що повертає стрічковий слайс, і про це сказано в документації API для <code>Deref</code>. Rust викликає <code>deref</code> знову, щоб перетворити <code>&amp;String</code> на <code>&amp;str</code>, який відповідає визначенню функції <code>hello</code>.</p>
<p>Якби Rust не мав приведення розіменування, нам довелося б писати код, як у Блоці коду 15-13 замість коду з Блоку коду 15-12, щоб викликати <code>hello</code> для значення типу <code>&amp;MyBox&lt;String&gt;</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {name}!&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-13: код, який довелося б писати, якби Rust не мав приведення розіменування</span></p>
<p><code>(*m)</code> розіменовує <code>MyBox&lt;String&gt;</code> у <code>String</code>. Потім <code>&amp;</code> і <code>[..]</code> беруть стрічковий слайс зі <code>String</code>, що дорівнює всій стрічці, щоб відповідати сигнатурі <code>hello</code>. Цей код без приведення розіменування складніше читати, писати і розуміти з усіма цими символами. Приведення розіменування дозволяє Rust обробляти для нас такі перетворення автоматично.</p>
<p>Коли трейт <code>Deref</code> визначений для залучених типів, Rust аналізує ці типи і використовує <code>Deref::deref</code> стільки разів, скільки треба, щоб отримати посилання, що відповідає типу параметра. Скільки разів треба додати <code>Deref::deref</code> визначається під час компіляції, тож немає ніяких втрат часу виконання за переваги приведення розіменування!</p>
<h3 id="Як-приведення-розіменування-взаємодіє-з-мутабельністю"><a class="header" href="#Як-приведення-розіменування-взаємодіє-з-мутабельністю">Як приведення розіменування взаємодіє з мутабельністю</a></h3>
<p>Подібно до того, як ви використовуєте трейт <code>Deref</code>, щоб перевизначити оператор <code>*</code> для іммутабельних посилань, ви можете скористатися трейтом <code>DerefMut</code>, щоб перевизначити оператор <code>*</code> для мутабельних посилань.</p>
<p>Rust виконує приведення розіменування, коли виявляє типи і реалізації трейтів у трьох випадках:</p>
<ul>
<li>З <code>&amp;T</code> в <code>&amp;U</code>, якщо <code>T: Deref&lt;Target=U&gt;</code></li>
<li>З <code>&amp;mut T</code> в <code>&amp;mut U</code>, якщо <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>З <code>&amp;mut T</code> в <code>&amp;U</code>, якщо <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>Перші два випадки однакові, окрім того, що другий реалізує мутабельність. Перший випадок застосовується, що якщо є <code>&amp;T</code>, і <code>T</code> реалізує <code>Deref</code> у якийсь тип <code>U</code>, то ми можете прозоро отримати <code>&amp;U</code>. Другий випадок застосовується що таке саме приведення розіменування виконується для мутабельних посилань.</p>
<p>Третій випадок хитріший: Rust також приведе мутабельне посилання до немутабельного. Але зворотне <em>не</em>можливе: немутабельні посилання ніколи не приводяться до мутабельних посилань. Через правила позичання, якщо ви маєте мутабельне посилання, це мутабельне посилання має бути єдиним посиланням на ці дані (інакше програма не скомпілюється). Перетворення мутабельного посилання на немутабельне ніколи не порушить правила позичання. Перетворення немутабельного посилання на мутабельне посилання вимагало б, щоб початкове немутабельне посилання було єдиним немутабельним посиланням на ці дані, але правила позичання не гарантують цього. Тому Rust не може зробити припущення про те, чи перетворення немутабельного посилання на мутабельне посилання є можливим.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Виконання-коду-при-очищенні-за-допомогою-трейту-drop"><a class="header" href="#Виконання-коду-при-очищенні-за-допомогою-трейту-drop">Виконання коду при очищенні за допомогою трейту <code>Drop</code></a></h2>
<p>Другий важливий трейт для шаблону розумного вказівника - <code>Drop</code>, який дозволяє вам налаштувати, що відбувається, коли значення збирається вийти з області видимості. Ви можете створити реалізацію трейту <code>Drop</code> для будь-якого типу, і цей код може використовуватися для звільнення ресурсів на кшталт файлів чи мережевих з'єднань.</p>
<p>Ми презентуємо <code>Drop</code> у контексті розумних вказівників, оскільки функціональність трейту <code>Drop</code> практично завжди використовується при реалізації розумних вказівників. Наприклад, коли <code>Box&lt;T&gt;</code> скидається, то звільняє простір у купі, виділений при створенні.</p>
<p>У деяких мовах для деяких типів програміст повинен викликати код для звільнення пам'яті або ресурсів кожного разу, коли він завершує використовувати екземпляр такого типу. Прикладами можуть бути файли, сокети чи блокування доступу до даних. Якщо програміст забуде це зробити, система може перенавантажитися і впасти. У Rust ви можете вказати, що спеціальний шматок коду має бути виконано, коли значення виходить з зони видимості, і компілятор додасть цей код автоматично. В результаті вам не треба стежити за ретельним розміщенням коду очищення всюди в програмі для завершення роботи з екземпляром певного типу - і все одно ви не допустите витоку ресурсів!</p>
<p>Ви вказуєте код, що потрібно виконати, коли значення виходить з області видимості, реалізуючи трейт <code>Drop</code>. Трейт <code>Drop</code> потребує реалізації одного методу, що зветься <code>drop</code>, який приймає мутабельне посилання на <code>self</code>. Щоб побачити, коли Rust викликає <code>drop</code>, тимчасово реалізуймо <code>drop</code> з інструкціями <code>println!</code>.</p>
<p>Блок коду 15-14 показує структуру <code>CustomSmartPointer</code>, чия єдина особлива функціональність полягає в тому, що вона виводить <code>Dropping CustomSmartPointer!</code>, коли екземпляр виходить із зони видимості, щоб показати, коли Rust запускає функцію <code>drop</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;my stuff&quot;),
    };
    let d = CustomSmartPointer {
        data: String::from(&quot;other stuff&quot;),
    };
    println!(&quot;CustomSmartPointers created.&quot;);
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-14: структура <code>CustomSmartPointer</code>, що реалізує трейт <code>Drop</code>, в якому ми розміщуємо наш код для очищення</span></p>
<p>Трейт <code>Drop</code> включено до прелюдії, тож нам не треба вводити її в область видимості. Ми реалізуємо трейт <code>Drop</code> для <code>CustomSmartPointer</code> і надаємо реалізацію методу <code>drop</code>, що викликає <code>println!</code>. Саме у тілі функції <code>drop</code> треба розмістити логіку, яку ви хочете виконати, коли екземпляр типу виходить з області видимості. Тут ми виводимо деякий текст для наочної демонстрації, коли саме Rust викличе <code>drop</code>.</p>
<p>У <code>main</code> ми створимо два екземпляри <code>CustomSmartPointer</code> і виведемо <code>CustomSmartPointers created</code>. Наприкінці <code>main</code> наші екземпляри <code>CustomSmartPointer</code> вийдуть з області видимості, і Rust викличе код, який ми розмістили у методі <code>drop</code>, вивівши наше останнє повідомлення. Зверніть увагу що нам не треба явно викликати метод <code>drop</code>.</p>
<p>Коли ми запустимо цю програму, то побачимо таке:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Rust автоматично викликав для нас <code>drop</code>, коли наші екземпляри вийшли з області видимості, виконавши зазначений код. Змінні очищуються у зворотному порядку від створення, тож <code>d</code> буде очищено перед <code>c</code>. Мета цього прикладу - надати Вам візуальний посібник того, як працює метод <code>drop</code>; зазвичай ви вказуєте код для очищення, який треба запустити вашому типу, а не друкуєте повідомлення.</p>
<h3 id="Раннє-очищення-значення-за-допомогою-stdmemdrop"><a class="header" href="#Раннє-очищення-значення-за-допомогою-stdmemdrop">Раннє очищення значення за допомогою <code>std::mem::drop</code></a></h3>
<p>На жаль, зовсім не очевидно, як вимкнути автоматичну функціональність <code>drop</code>. Відключати <code>drop</code> зазвичай не потрібно; весь сенс трейту <code>Drop</code> полягає в тому, що про нього компілятор дбає автоматично. Однак, іноді ви можете захотіти очистити значення завчасно. Візьмемо такий приклад: розумні вказівники, що керують блокуванням; ви можете захотіти примусово запустити метод <code>drop</code>, що відпускає блокування, щоб інший код у цій області видимості міг захопити це блокування. Rust не дозволяє вам викликати метод <code>drop</code> трейту <code>Drop</code> вручну; натомість ви маєте викликати функцію <code>std::mem::drop</code>, надану стандартною бібліотекою, якщо ви хочете примусово очистити значення перед до закінчення її області видимості.</p>
<p>Якщо ми спробуємо викликати метод <code>drop</code> трейту <code>Drop</code> вручну, змінивши функцію <code>main</code> з Блоку коду 15-14, як показано у Блоці коду 15-15, то отримаємо помилку компілятора:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;some data&quot;),
    };
    println!(&quot;CustomSmartPointer created.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre>
<p><span class="caption">Блок коду 15-15: спроба викликати метод <code>drop</code> з риси <code>Drop</code> вручну для раннього очищення</span></p>
<p>Якщо ми спробуємо скомпілювати цей код, то отримаємо таку помилку:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |     --^^^^--
   |     | |
   |     | explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(c)`

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` due to previous error
</code></pre>
<p>Ця помилка каже, що ми не можемо явно викликати <code>drop</code>. Повідомлення використовує загальнопрограмістський термін <em>деструктор</em>, що позначає функцію, яка очищує екземпляр. <em>Деструктор</em> є аналогом до <em>конструктора</em>, який створює екземпляр. Функція <code>drop</code> в Rust - це деструктор.</p>
<p>Rust не дозволяє нам викликати <code>drop</code> явно, бо Rust все одно автоматично викличе <code>drop</code> для цього значення наприкінці <code>main</code>. Це спричинить помилку <em>подвійного звільнення</em>, бо Rust спробує очистити те саме значення двічі.</p>
<p>Ми не можемо вимкнути автоматичне додавання <code>drop</code> там, де значення виходить за межі області видимості, і ми не можемо викликати метод <code>drop</code> явно. Тож якщо нам треба змусити значення очиститися раніше, ми використовуємо функцію <code>std::mem::drop</code>.</p>
<p>Функція <code>std::mem::drop</code> відрізняється від методу <code>drop</code> у трейті <code>Drop</code>. Ми викликаємо її, передаючи аргументом значення, яке ми хочемо примусово очистити. Ця функція є в прелюдії, таким чином, ми можемо змінити <code>main</code> у Блоці коду 15-15, щоб викликати функцію <code>drop</code>, як показано в Блоці коду 15-16:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;some data&quot;),
    };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-16: виклик <code>std::mem::drop</code>, щоб явно очистити значення до того, як вони вийде з області видимості</span></p>
<p>Виконання цього коду виведе наступне:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p>Текст <code>Видалення CustomSmartPointer з даними `деякі дані`!</code> виводиться між текстами <code>CustomSmartPointer created.</code> і <code>CustomSmartPointer dropped before the end of main.</code>, показуючи, що код методу <code>drop</code> викликається для очищення <code>с</code> в цьому місці.</p>
<p>Ви можете використати код, вказаний у реалізації трейту <code>Drop</code>, у різні способи, щоб зробити очищення зручним і безпечним: зокрема, ви могли б використати його для створення власного розподілювача пам'яті! Завдяки трейту <code>Drop</code> і системі володіння Rust, вам не треба пам'ятати про очищення, бо Rust робить це автоматично.</p>
<p>Також вам не доведеться турбуватися про проблеми, що можуть виникнути через випадкове очищення значень, які все ще використовуються: система власності, яка гарантує, що посилання завжди дійсні, також гарантує, що метод <code>drop</code> буде викликаний лише один раз, коли значення більше не використовуватиметься.</p>
<p>Тепер, коли ми дослідили <code>Box&lt;T&gt;</code> і деякі характеристики розумних вказівників, погляньмо на деякі інші розумні вказівники, визначені у стандартній бібліотеці.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rct-розумний-вказівник-з-лічильником-посилань"><a class="header" href="#rct-розумний-вказівник-з-лічильником-посилань"><code>Rc&lt;T&gt;</code>, розумний вказівник з лічильником посилань</a></h2>
<p>У більшості випадків володіння є прозорим: ви точно знаєте, яка змінна володіє певним значенням. Проте є випадки, коли одне значення може мати декілька власників. Наприклад, в структурах даних - графах багато ребер можуть вказувати на один вузол, і цей вузол концептуально є володінням усіх ребер, які ведуть у нього. Вузол не повинен бути очищений, поки існують ребра, які вказують на нього, і тому він має власників.</p>
<p>Вам треба явно дозволити множинне володіння, використовуючи тип Rust <code>Rc&lt;T&gt;</code>, що означає <em>лічильник посилань</em>. Тип <code>Rc&lt;T&gt;</code> відстежує кількість посилань на значення, щоб визначити, чи значення все ще використовується. Якщо лишилося нуль посилань на значення, то значення можна очистити, не зробивши жодне посилання некоректним.</p>
<p>Можна уявити собі <code>Rc&lt;T&gt;</code> як телевізор у сімейній кімнаті. Коли одна людина входить, щоб подивитися телевізор, його вмикають. Інші теж можуть зайти до кімнати і подивитися телевізор. Коли остання людина залишає кімнату, телевізор вимикають, бо його більше не використовують. Якщо хтось вимкне телевізор, поки інші все ще його дивитимуться, решта глядачів телевізора обуриться!</p>
<p>Ми використовуємо тип <code>Rc&lt;T&gt;</code>, коли ми хочемо виділити деякі дані в купі, щоб різні частини програми могли їх читати, і не можемо визначити під час компіляції, яка частина останньою завершить використовувати ці дані. Якби ми знали, яка частина завершить останньою, то могли б просто надати цій частині володіння, і були б застосовані звичайні правила володіння часу компіляції.</p>
<p>Зверніть увагу, що <code>Rc&lt;T&gt;</code> використовується тільки в однопотокових сценаріях. Коли ми обговорюватимемо конкурентність у Розділі 16, то розглянемо, як облічувати посилання в багатопотокових програмах.</p>
<h3 id="Використання-rct-для-спільного-використання-даних"><a class="header" href="#Використання-rct-для-спільного-використання-даних">Використання <code>Rc&lt;T&gt;</code> для спільного використання даних</a></h3>
<p>Повернімося до прикладу зі списком Cons з Блоку коду 15-5. Пам'ятайте, що ми визначили його за допомогою <code>Box&lt;T&gt;</code>. Цього разу створимо два списки, що спільно володіють третім. Концептуально це схоже на Рисунок 15-3:</p>
<img alt="Два списки, що спільно володіють третім списком" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">Рисунок 15-3: Два списки, <code>b</code> and <code>c</code>, спільно володіють третім списком, <code>a</code></span></p>
<p>Ми створимо список <code>a</code>, що містить 5, а потім 10. Тоді ми зробимо ще два списки: <code>b</code>, що починається з 3 і <code>c</code>, що починається з 4. Обидва списки <code>b</code> та <code>c</code> далі продовжуються першим списком <code>a</code>, що містить 5 і 10. Іншими словами, обидва списки спільно використовують перший, що містить 5 і 10.</p>
<p>Спроба реалізувати цией сценарій за допомогою нашого визначення <code>List</code> із <code>Box&lt;T&gt;</code> не спрацює, як показано в Блоці коду 15-17:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<p><span class="caption">Блок коду 15-17: демонстрація, що ми не можемо мати два списки, створені з <code>Box&lt;T&gt;</code>, які намагаються спільно володіти третім списком</span></p>
<p>Якщо ми скомпілюємо цей код, ми отримаємо цю помилку:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` due to previous error
</code></pre>
<p>Варіанти <code>Cons</code> володіють даними, що в них знаходяться, тож коли ми створюємо список <code>b</code>, <code>a</code> переміщується в <code>b</code> і <code>b</code> володіє <code>a</code>. Тоді ж, коли ми намагаємося знову використати <code>а</code> при створенні <code>c</code>, нам це заборонено через те, що <code>a</code> було переміщено.</p>
<p>Ми могли б змінити визначення <code>Cons</code>, щоб він зберігав посилання, але тоді нам потрібно було б вказати параметри часу існування. Вказуючи параметри часу існування, ми вказуємо, що кожен елемент у списку буде існувати принаймні стільки ж, скільки весь список. Це так для елементів і списків у Блоці коду 15-17, але не для кожного сценарію.</p>
<p>Натомість ми змінимо наше визначення <code>List</code>, застосувавши <code>Rc&lt;T&gt;</code> замість <code>Box&lt;T&gt;</code>, як показано в Блоці коду 15-18. Варіант <code>Cons</code> тепер буде складатися зі значення і <code>Rc&lt;T&gt;</code>, що вказує на <code>List</code>. Коли ми створюємо <code>b</code>, замість того, перебрати володіння <code>a</code>, ми клонуватимемо <code>Rc&lt;List&gt;</code>, що <code>a</code> містить, збільшуючи таким чином кількість посилань з одного до двох і дозволяючи <code>а</code> та <code>b</code> розділити володіння даними в цьому <code>Rc&lt;List&gt;</code>. Ми також склонуємо <code>a</code>, коли створюватимемо <code>c</code>, збільшуючи кількість посилань з двох до трьох. Кожного разу, як ми викликаємо <code>Rc::clone</code>, кількість посилань на дані в <code>Rc&lt;List&gt;</code> буде збільшуватися, і дані не будуть очищені, поки кількість посилань на них не сягне нуля.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-18: визначення <code>List</code> за допомогою <code>Rc&lt;T&gt;</code></span></p>
<p>Нам потрібно додати інструкцію <code>use</code>, щоб винести <code>Rc&lt;T&gt;</code> в область видимості, оскільки його немає у прелюдії. У <code>main</code> ми створюємо список, що складається з 5 і 10 і зберігаємо його у новому <code>Rc&lt;List&gt;</code> <code>a</code>. Потім ми створюємо <code>b</code> і <code>c</code>, викликаємо функцію <code>Rc::clone</code> і передаємо посилання на <code>Rc&lt;List&gt;</code> в <code>a</code> як аргумент.</p>
<p>Ми могли б викликати <code>a.clone()</code>, а не <code>Rc::clone(&amp;a)</code>, але в Rust діє домовленість використовувати в цьому випадку <code>Rc::clone</code>. Реалізація <code>Rc::clone</code> не робить глибокої копії всіх даних, на відміну від реалізацій реалізації <code>clone</code> для більшості типів. Виклик <code>Rc::clone</code> тільки збільшує кількість посилань, що не забирає багато часу. Глибокі копії даних можуть зайняти багато часу. Використовуючи <code>Rc:::clone</code> для обліку посилань, ми можемо візуально розрізняти clone, що роблять глибоку копію, і ті, які збільшують кількість посилань. При пошуку проблем з продуктивністю в коді нам потрібно лише розглянути clone глибокого копіювання і може не враховувати виклики <code>Rc::clone</code>.</p>
<h3 id="Клонування-rct-збільшує-кількість-посилань"><a class="header" href="#Клонування-rct-збільшує-кількість-посилань">Клонування <code>Rc&lt;T&gt;</code> збільшує кількість посилань</a></h3>
<p>Змінімо наш робочий приклад у Блоці коду 15-18 так, щоб ми могли переглянути зміни лічильника посилань, коли ми створюємо і очищуємо посилання на <code>Rc&lt;List&gt;</code> в <code>a</code>.</p>
<p>У Блоці коду 15-19 ми змінимо <code>main</code> так, щоб вона мала внутрішню область видимості навколо списку <code>c</code>; тоді ми можемо побачити, як змінюється кількість посилань, коли <code>c</code> виходить за межі видимості.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-19: виведення лічильника посилань</span></p>
<p>У кожній точці програми, в якій змінюється кількість посилань, ми виводимо кількість посилань, які ми отримаємо, викликавши функцію <code>Rc::strong_count</code>. Ця функція зветься <code>strong_count</code>, а не просто <code>count</code>, бо тип <code>Rc&lt;T&gt;</code> також має <code>weak_count</code>; ми побачимо, нащо потрібен <code>weak_count</code>, у підрозділі <a href="ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">“Запобігання циклам посилань: перетворення <code>Rc&lt;T&gt;</code> на <code>Weak&lt;T&gt;</code>”</a><!-- ignore --> .</p>
<p>Цей код виводить таке:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>Як ми можемо бачити, <code>Rc&lt;List&gt;</code> в <code>a</code> має початкове значення лічильника 1; потім кожного разу при виклику <code>clone</code> кількість збільшується на 1. Коли <code>c</code> виходить з області видимості, кількість знижується на 1. Там не треба викликати функцію, щоб зменшити лічильник посилань, на відміну від виклику <code>Rc::clone</code> для його збільшення: реалізація трейту <code>Drop</code> зменшує лічильник посилань автоматично, коли <code>Rc&lt;T&gt;</code> виходить з області видимості.</p>
<p>Чого ми не можемо бачити в цьому прикладі, то це того, що коли <code>b</code>, а потім <code>a</code> виходять з області видимості в кінці <code>main</code>, лічильник стає 0, а тоді <code>Rc&lt;List&gt;</code> повністю очищується. Використання <code>Rc&lt;T&gt;</code> дозволяє одному значенню мати кілька власників, а лічильник гарантує, що значення залишається коректним доти, поки існує хоч один із власників.</p>
<p>За допомогою іммутабельних посилань <code>Rc&lt;T&gt;</code> дозволяє спільно використовувати дані лише для читання у багатьох частинах вашої програми. Якби <code>Rc&lt;T&gt;</code> дозволяв також мати кілька повторюваних посилань, ви змогли б порушити одне з правил запозичення, що обговорювалися в Розділі 4: кілька мутабельних позичань до одного місця можуть спричинити гонитву даних і неузгодженість. Але ж мати можливість змінювати дані так зручно! У наступному підрозділі ми обговоримо шаблон внутрішньої мутабельності та тип <code>RefCell&lt;T&gt;</code>, який ви можете використовувати разом з <code>Rc&lt;T&gt;</code> для роботи з цим обмеженням немутабельності.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcellt-і-шаблон-внутрішньої-мутабельності"><a class="header" href="#refcellt-і-шаблон-внутрішньої-мутабельності"><code>RefCell&lt;T&gt;</code> і шаблон внутрішньої мутабельності</a></h2>
<p><em>Внутрішня мутабельність</em> - це шаблон проєктування в Rust, що дозволяє вам змінювати дані, навіть якщо є немутабельні посилання на ці дані; зазвичай, ця дія заборонена правилами позичання. Щоб змінювати дані, цей шаблон використовує <code>небезпечний</code> код у структурі даних, щоб обійти звичайні правила Rust, що керують мутабельністю та позичанням. Небезпечний код повідомляє компілятор, що ми перевіряємо правила самостійно, а не покладаємося на компілятор, щоб перевіряти їх для нас; ми детальніше поговоримо про небезпечний код у Розділі 19.</p>
<p>Ми можемо використовувати типи, які використовують шаблон внутрішньої мутабельності тільки тоді, коли ми можемо гарантувати дотримання правил позичання під час виконання, тоді як компілятор не може гарантувати цього. <code>Небезпечний</code> код застосовується загорнутим у безпечне API, і зовнішній тип лишається немутабельним.</p>
<p>Дослідимо цю концепцію, розглянувши тип <code>Refell&lt;T&gt;</code>, який слідує шаблону внутрішньої мутабельності.</p>
<h3 id="Забезпечення-правил-позичання-під-час-виконання-за-допомогою-refcellt"><a class="header" href="#Забезпечення-правил-позичання-під-час-виконання-за-допомогою-refcellt">Забезпечення правил позичання під час виконання за допомогою <code>RefCell&lt;T&gt;</code></a></h3>
<p>На відміну від <code>Rc&lt;T&gt;</code>, тип <code>RefCell&lt;T&gt;</code> представляє єдине володіння даними, що він містить. То що ж відрізняє <code>RefCell&lt;T&gt;</code> від типу на кшталт <code>Box&lt;T&gt;</code>? Згадайте правила позичання, які ви вивчили у Розділі 4:</p>
<ul>
<li>У будь-який час можна мати <em>або</em> одне мутабельне посилання, &lt;0&gt;або&lt;/0&gt; будь-яку кількість немутабельних посилань.</li>
<li>Посилання завжди мають бути коректними.</li>
</ul>
<p>За допомогою посилань і <code>Box&lt;T&gt;</code> інваріанти правил позичання забезпечуються під час компіляції. За допомогою <code>RefCell&lt;T&gt;</code>, ці інваріанти забезпечуються <em>під час виконання</em>. При застосуванні посилань, якщо ви порушите ці правила, то отримаєте помилку компілятора. При застосуванні <code>RefCell&lt;T&gt;</code>, якщо ви порушите ці правила, ваша програма запанікує і завершиться.</p>
<p>Перевага перевірки правил позичання під час компіляції полягає в тому, що помилки будуть виявлені раніше під час розробки і немає впливу на продуктивність часу виконання, бо весь аналіз проведений заздалегідь. З цих причин перевірка правил позичання під час компіляції є найкращим вибором у більшості випадків, чому це і є замовчуванням Rust.</p>
<p>Перевагою перевірки правил позичання під час виконання є те, що уможливлюються певні безпечні для пам'яті сценарії, які були б заборонені перевірками часу компіляції. Статичний аналіз, як і компілятор Rust, за своєю природою консервативний. Певні властивості коду неможливо виявити лише аналізом коду: найвідоміший приклад - Проблема зупинки, про яку в цій книзі не йдеться, але це цікава тема для дослідження.</p>
<p>Оскільки певний аналіз неможливий, то якщо компілятор Rust не може бути впевненим, що код відповідає правилам володіння, він може відхилити коректну програму; таким чином, він консервативний. Якби Rust прийняв некоректну програму, користувачі не змогли б довіряти гарантіям, забезпеченим Rust. Однак, якщо Rust відхиляє правильну програму, програмісту буде незручно, але нічого катастрофічного не може станеться. Тип <code>RefCell&lt;T&gt;</code> є корисним, коли ви впевнені, що ваш код слідує правилам запозичень, але компілятор не в змозі зрозуміти і гарантувати це.</p>
<p>Подібно до <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> призначено лише для використання в однопотоковому сценарії видасть вам помилку часу компіляції, якщо ви спробуєте використати його в багатопотоковому контексті. Ми поговоримо про те, як отримати функціональність <code>RefCell&lt;T&gt;</code> в багатопотоковій програмі у Розділі 16.</p>
<p>Ось коротке зведення, коли обирати <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, або <code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> дозволяє декілька власників одних даних; <code>Box&lt;T&gt;</code> і <code>RefCell&lt;T&gt;</code> мають одного власника.</li>
<li><code>Box&lt;T&gt;</code> дозволяє немутабельні чи мутабельні позичання, перевірені під час компіляції; <code>Rc&lt;T&gt;</code> дозволяє лише немутабельні позичання, перевірені під час компіляції; <code>RefCell&lt;T&gt;</code> дозволяє немутабельні чи мутабельні позичання, перевірені під час виконання.</li>
<li>Оскільки <code>RefCell&lt;T&gt;</code> дозволяє мутабельні позичання, перевірені під час виконання, ви можете змінити значення всередині <code>RefCell&lt;T&gt;</code>, навіть коли <code>RefCell&lt;T&gt;</code> є немутабельним.</li>
</ul>
<p>Зміна значення всередині немутабельного значення - це шаблон <em>внутрішньої мутабельності</em>. Подивімося на ситуацію, в якій внутрішня мутабельність корисна і дослідимо, як її використовувати.</p>
<h3 id="Внутрішня-мутабельність-мутабельне-позичання-немутабельного-значення"><a class="header" href="#Внутрішня-мутабельність-мутабельне-позичання-немутабельного-значення">Внутрішня мутабельність: мутабельне позичання немутабельного значення</a></h3>
<p>З правил запозичення випливає, що якщо ви маєте немутабельне значення, то ви не можете його мутабельно позичити. Наприклад, цей код не компілюється:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<p>Якби ви спробували скомпілювати цей код, то отримали б таку помилку:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` due to previous error
</code></pre>
<p>Проте, Існують ситуації, в яких було б зручним для значення змінювати себе у своїх методах, але виглядати немутабельним для іншого коду. Код за межами методів цього значення не має можливості змінювати значення. Використання <code>RefCell&lt;T&gt;</code> є одним зі способів отримати можливість внутрішньої мутабельності, але <code>RefCell&lt;T&gt;</code> не повністю оминає правила позичання: borrow checker у компіляторі дозволяє цю внутрішню мутабельність, і правила позичання перевіряються під час виконання програми. Якщо ви порушите ці правила, ви отримаєте <code>panic!</code> замість помилки компілятора.</p>
<p>Пропрацюємо практичний приклад, де ми можемо використати <code>RefCell&lt;T&gt;</code> для зміни немутабельного значення і побачити, чому це корисно.</p>
<h4 id="Сценарій-використання-внутрішньої-мутабельності-імітаційні-обєкти"><a class="header" href="#Сценарій-використання-внутрішньої-мутабельності-імітаційні-обєкти">Сценарій використання внутрішньої мутабельності: імітаційні об'єкти</a></h4>
<p>Іноді під час тестування програміст може використовувати тип замість іншого типу, для того, щоб отримати певну поведінку та перевірити коректність його реалізації. Такий тип-замінник зветься <em>тест-дублером</em>. Можна розглядати його як &quot;дублера-каскадера&quot; у фільмі, де інша людина замінює актора для виконання певної ризикованої сцени. Тест-дублери замінюють інші типи при виконанні тестів. <em>Імітаційні об'єкти</em> - це спеціальні типи тест-дублерів, що записують, що відбувається під час тесту, щоб ви могли перевірити, що мали місце правильні дії.</p>
<p>У Rust немає об'єктів у тому ж сенсі, в якому вони є в інших мовах, і в Rust немає вбудованої функціональності імітаційних об'єктів у стандартній бібліотеці, як в деяких інших мовах. Однак, ви точно можете створити структуру, що буде служити тій же меті, що й імітаційний об'єкт.</p>
<p>Ось цей сценарій ми будемо тестувати: ми створимо бібліотеку, яка буде відстежувати значення до максимального значення і надсилатиме повідомлення залежно від того, наскільки близьке поточне значення до максимального значення. Цю бібліотеку можна використовувати, наприклад, для відстеження квоти користувача на кількість викликів API, які їм дозволено зробити.</p>
<p>Наша бібліотека забезпечить тільки функціональність відстеження, наскільки близьким до максимального є значення і коли та якими мають бути повідомлення. Очікується, що застосунки, які використовують нашу бібліотеку, забезпечать механізм відправлення повідомлень: застосунок може відправити повідомлення у застосунок, надіслати електронного листа, текстове повідомлення або щось інше. Бібліотека не має знати про такі подробиці. Все, що їй потрібно - щось, що реалізує наданий нами трейт, що зветься <code>Messenger</code>. Блок коду 15-20 показує код бібліотеки:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;Error: You are over your quota!&quot;);
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
        }
    }
}
</code></pre>
<p><span class="caption">Блок коду 15-20: бібліотека для відстеження наближення значення до максимального значення і попередження, коли значення сягає певних рівнів</span></p>
<p>Важливою частиною цього коду є те, що трейт <code>Messenger</code> має один метод, що зветься <code>send</code>, який приймає немутабельне посилання на <code>self</code> і текст повідомлення. Цей трейт є інтерфейсом нашого імітаційного об'єкта, який треба реалізувати, щоб імітаційний об'єкт можна було використовувати так само, як і реальний об'єкт. Іншою важливою частиною є те, що ми хочемо перевірити поведінку методу <code>set_value</code> у <code>LimitTracker</code>. Ми можемо змінити значення, що передається як параметр <code>value</code>, але <code>set_value</code> не поверне нам нічого, на чому можна робити тестові твердження. Ми хочемо мати змогу сказати, що якщо ми створюємо <code>LimitTracker</code> з чимось, що реалізує трейт <code>Messenger</code> і конкретним значенням <code>max</code>, то коли ми передаємо різні числа для <code>value</code>, месенджеру накажуть відправляти відповідні повідомлення.</p>
<p>Нам потрібен імітаційний об'єкт, який, замість того, щоб надіслати електронне або текстове повідомлення коли ми викликаємо <code>send</code>, лише стежитиме за повідомленнями, які йому сказано надіслати. Ми можемо створити новий екземпляр імітаційного об'єкта, створити <code>LimitTracker</code>, який використовує цей імітаційний об'єкт, викликати метод <code>set_value</code> для <code>LimitTracker</code> і перевірити, чи цей імітаційний об'єкт містить повідомлення, на які ми очікуємо. Блок коду 15-21 показує спробу реалізувати імітаційний об'єкт, що робить саме це, але borrow checker не дозволяє так робити:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
</code></pre>
<p><span class="caption">Блок коду 15-21: спроба реалізувати <code>MockMessenger</code>, не дозволена borrow checker</span></p>
<p>Код цього тесту визначає структуру <code>MockMessenger</code>, що має поле <code>sent_messages</code> з <code>Vec</code>, що складається з <code>String</code>, щоб відстежувати повідомлення, які йому сказано. відправити. Ми також визначили асоційовану функцію <code>new</code>, щоб зручно було створювати нові значення <code>MockMessenger</code>, які на початку мають порожній список повідомлень. Далі ми реалізуємо трейт <code>Messenger</code> для <code>MockMessenger</code>, щоб можна було передати <code>Messenger</code> до <code>LimitTracker</code>. У визначенні методу <code>send</code> ми беремо повідомлення, передане як параметр, і у <code>MockMessenger</code> зберігаємо його у списку <code>sent_messages</code>.</p>
<p>У цьому тесті ми тестуємо, що відбувається, коли наказали <code>LimitTracker</code> встановити якесь значення <code>value</code>, більше за 75 відсотків значення <code>max</code>. Спочатку ми створюємо новий <code>MockMessenger</code>, який починає з порожнім списком повідомлень. Далі ми створюємо новий <code>LimitTracker</code> і даємо йому посилання на новий <code>MockMessenger</code> і значення <code>max</code> 100. Ми викликаємо метод <code>set_value</code> для <code>LimitTracker</code> зі значенням 80, що більше, ніж 75% від 100. Далі ми твердимо, що список повідомлень, який відстежує <code>MockMessenger</code>, має тепер складатися з одного повідомлення.</p>
<p>Однак, є одна проблема з цим тестом, як показано тут:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
2  |     fn send(&amp;self, msg: &amp;str);
   |             ----- help: consider changing that to be a mutable reference: `&amp;mut self`
...
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` due to previous error
warning: build failed, waiting for other jobs to finish...
</code></pre>
<p>Ми не можемо змінити <code>MockMessenger</code> для відстеження повідомлень, оскільки метод <code>send</code> приймає немутабельне посилання на <code>self</code>. Також ми не можемо скористатися пропозицією з тексту помилки замінити посилання на <code>&amp;mut self</code>, тому що тоді сигнатура <code>send</code> не відповідатиме сигнатурі у визначенні трейту <code>Messenger</code>: (можете спробувати і побачите, яке повідомлення про помилку ви отримаєте).</p>
<p>У цій ситуації може допомогти внутрішня мутабельність! Ми зберігатимемо <code>sent_messages</code> в <code>RefCell&lt;T&gt;</code>, і тоді метод <code>send</code> зможе змінити <code>sent_messages</code>, щоб зберегти повідомлення, які ми бачили. Блок коду 15-22 показує, як це виглядає:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
</code></pre>
<p><span class="caption">Блок коду 15-22: Використання <code>RefCell&lt;T&gt;</code>, щоб змінити внутрішнє значення, поки зовнішнє значення вважається немутабельним</span></p>
<p>Поле <code>sent_messages</code> тепер має тип <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, а не <code>Vec&lt;String&gt;</code>. У функції <code>new</code> ми створюємо новий екземпляр <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> навколо порожнього вектора.</p>
<p>Для реалізації метода <code>send</code> перший параметр все ще є немутабельним позичанням <code>self</code>, що відповідає за визначенню трейта. Ми викликаємо <code>borrow_mut</code> для <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> у <code>self.sent_messages</code>, щоб отримати мутабельне посилання на значення всередині <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, тобто вектор. Тоді ми можемо викликати <code>push</code> для мутабельного посилання на вектор, щоб зберігати повідомлення, надіслані протягом тесту.</p>
<p>Остання зміна, яку ми повинні зробити - в твердженні тесту: щоб подивитись, скільки елементів є у внутрішньому векторі, ми викликаємо <code>borrow</code> для <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, щоб отримати немутабельне посилання на вектор.</p>
<p>Тепер, коли ви побачили, як використовувати <code>RefCell&lt;T&gt;</code>, зануримось у те, як воно працює!</p>
<h4 id="Відстеження-позичань-за-допомогою-refcellt-під-час-виконання"><a class="header" href="#Відстеження-позичань-за-допомогою-refcellt-під-час-виконання">Відстеження позичань за допомогою <code>RefCell&lt;T&gt;</code> під час виконання</a></h4>
<p>Створюючи немутабельні і мутабельні посилання, ви використовуємо, відповідно, записи <code>&amp;</code> та <code>&amp;mut</code>. Для <code>RefCell&lt;T&gt;</code> ми використовуємо методи <code>borrow</code> і <code>borrow_mut</code>, які є частиною безпечного API <code>RefCell&lt;T&gt;</code>. Метод <code>borrow</code> повертає розумний вказівник типу <code>Ref&lt;T&gt;</code>, а <code>borrow_mut</code> повертає розумний вказівник типу <code>RefMut&lt;T&gt;</code>. Обидва типи реалізують <code>Deref</code>, тому ми можемо працювати з ними як зі звичайними посиланнями.</p>
<p><code>RefCell&lt;T&gt;</code> відстежує, скільки є активних розумних вказівників <code>Ref&lt;T&gt;</code> і <code>Refut&lt;T&gt;</code> у кожен момент. Кожного разу коли ми викликаємо <code>borrow</code>, <code>RefCell&lt;T&gt;</code> збільшує кількість активних немутабельних позичань. Коли значення <code>Ref&lt;T&gt;</code> виходить з області видимості, кількість немутабельних позичань зменшується на один. Так само як правила позичання часу компіляції, <code>Refell&lt;T&gt;</code> дозволяє мати багато немутабельних позичань або одне мутабельне позичання в будь-який момент часу.</p>
<p>Якщо ми спробуємо порушити ці правила, то замість помилки компілятора, як це стається з посиланнями, реалізація <code>RefCell&lt;T&gt;</code> запанікує під час виконання. Блок коду 15-23 показує зміну реалізації <code>send</code> з Блоку коду 15-22. Ми навмисно намагаємося створити два немутабельні позичання активними в одній області видимості, щоб продемонструвати, що <code>RefCell&lt;T&gt;</code> запобігає цьому під час виконання.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 15-23: створення двох мутабельних посилань в одній області видимості, щоб побачити, що<code>RefCell&lt;T&gt;</code> запанікує</span></p>
<p>Ми створюємо змінну <code>one_borrow</code> для розумного вказівника <code>RefMut&lt;T&gt;</code>, повернутого з <code>borrow_mut</code>. Потім так само створюємо ще одне мутабельне позичання в змінній <code>two_borrow</code>. Це створює два мутабельні позичання в одній області видимості, що є забороненим. Коли ми запускаємо тести для нашої бібліотеки, код з Блоку коду 15-23 скомпілюється без будь-яких помилок, але тест не провалиться:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'main' panicked at 'already borrowed: BorrowMutError', src/lib.rs:60:53
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Зверніть увагу, що код панікував з повідомленням <code>already borrowed: BorrowMutError</code>. Ось так <code>RefCell&lt;T&gt;</code> обробляє порушення правил позичання під час виконання.</p>
<p>Перехоплення помилок під час виконання, а не під час компіляції, як ми зробили це тут, означає що ви потенційно знаходитимете помилки у вашому коді пізніше під час розробки. Можливо, лише тоді, коли ваш код уже буде розгорнуто у кінцевого користувача. Крім того, ваш код матиме незначне зниження продуктивності у піл час виконання у результаті відстеження позичань під час виконання замість часу компіляції. Проте використання <code>RefCell&lt;T&gt;</code> уможливлює запис імітаційних об'єктів, які можуть змінювати себе, щоб відстежувати повідомлення, які вони отримували під час використання в контексті, де допускаються лише немутабельні значення. Ви можете використовувати <code>RefCell&lt;T&gt;</code> не зважаючи на його недоліки, щоб отримати більше функціональності, ніж надають звичайні посилання.</p>
<h3 id="Множинні-власники-мутабельних-даних-за-допомогою-комбінації-rct-та-refcellt"><a class="header" href="#Множинні-власники-мутабельних-даних-за-допомогою-комбінації-rct-та-refcellt">Множинні власники мутабельних даних за допомогою комбінації <code>Rc&lt;T&gt;</code> та <code>RefCell&lt;T&gt;</code></a></h3>
<p>Звичайний спосіб використання e <code>RefCell&lt;T&gt;</code> - комбінація з <code>Rc&lt;T&gt;</code>. Згадайте, що <code>Rc&lt;T&gt;</code> дозволяє мати кілька володільців одних даних, але надає лише немутабельний доступ до цих даних. Якщо ви маєте <code>Rc&lt;T&gt;</code>, що містить <code>RefCell&lt;T&gt;</code>, ви можете отримати значення, що може мати кількох власників <em>і</em> яке ви можете змінювати!</p>
<p>Наприклад, згадайте приклад зі списком cons у Блоці коду 15-18, де ми використовували <code>Rc&lt;T&gt;</code>, щоб дозволити декільком спискам ділитися володінням іншим списком. Оскільки <code>Rc&lt;T&gt;</code> має лише немутабельні значення, ми не можемо змінити жодне зі значень у списку після їх створення. Додамо <code>RefCell&lt;T&gt;</code>, щоб отримати можливість змінити значення у списках. Блок коду 15-24 показує, що використовуючи <code>Refell&lt;T&gt;</code> у визначенні <code>Cons</code> ми можемо змінити значення, збережене у всіх списках:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-24: використання <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> для створення <code>List</code>, який ми можемо змінювати</span></p>
<p>Ми створюємо значення, що є екземпляром <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>, і зберігаємо його у змінній з назвою <code>value</code>, щоб пізніше мати можливість доступу до нього. Потім створили <code>List</code> в <code>a</code> з варіантом <code>Cons</code>, що містить <code>value</code>. Ми маємо клонувати <code>value</code>, щоб обидва <code>a</code> і <code>value</code> мали володіння над внутрішнім значенням <code>5</code> замість передачі володіння з <code>value</code> до <code>a</code> чи щоб <code>a</code> позичало <code>value</code>.</p>
<p>Ми обгорнули список <code>a</code> у <code>Rc&lt;T&gt;</code>, тож коли ми створюємо списки <code>b</code> та <code>c</code>, вони обидва можуть посилатися на <code>a</code>, як ми робили у Блоці коду 15-18.</p>
<p>Після створення списків у <code>a</code>, <code>b</code>і <code>c</code>, ми хочемо додати 10 до значення в <code>value</code>. Ми зробимо це, викликавши <code>borrow_mut</code> для <code>value</code>, що використовує автоматичне розіменування, обговорене в Розділі 5 (див. підрозділ <a href="ch05-03-method-syntax.html#wheres-the---operator">&quot;А де ж оператор <code>-&gt;</code>?&quot;</a><!-- ignore -->), для розіменування <code>Rc&lt;T&gt;</code> до внутрішнього значення <code>RefCell&lt;T&gt;</code>. Метод e <code>borrow_mut</code> повертає розумний вказівник <code>RefMut&lt;T&gt;</code>, і ми використовуємо на ньому оператор розіменування та змінюємо внутрішнє значення.</p>
<p>Коли ми виводимо <code>a</code>, <code>b</code> та <code>c</code>, ми бачимо, що всі вони мають змінене значення 10 замість 5:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>Ця техніка дуже акуратна! Використовуючи <code>RefCell&lt;T&gt;</code>, ми маємо зовнішньо немутабельне значення <code>List</code>. Але ми можемо використати методи <code>RefCell&lt;T&gt;</code>, які надають доступ до його внутрішньої мутабельності, тож ми можемо змінювати наші дані в разі потреби. Перевірка правил запозичення часу виконання захищає нас від гонитви даних, і це іноді варто виміняти на крихту швидкості швидкістю заради цієї гнучкості в наших структурах даних. Зверніть увагу, що <code>RefCell&lt;T&gt;</code> не працює в багатопотоковому коді! <code>Mutex&lt;T&gt;</code> є потоково-безпечною версією <code>Refell&lt;T&gt;</code>, і ми обговоримо <code>Mutex&lt;T&gt;</code> в Розділі 16.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Цикли-посилань-можуть-призвести-до-витоку-памяті"><a class="header" href="#Цикли-посилань-можуть-призвести-до-витоку-памяті">Цикли посилань можуть призвести до витоку пам'яті</a></h2>
<p>Гарантії безпеки пам'яті Rust, ускладнюють, але не унеможливлюють, випадкове створення пам'яті, що ніколи не було очищеною (це зветься <em>витік пам'яті</em>). Повне запобігання витокам пам'яті не є однією з гарантій Rust, тобто витоки пам'яті вважаються безпечними в Rust. Як ми можемо бачити, Rust дозволяє витоки пам’яті за допомогою <code>Rc&lt;T&gt;</code> і <code>RefCell&lt;T&gt;</code>: можна створити посилання, де елементи посилаються один на одного в циклі. Це створює витік пам'яті, бо лічильник посилань кожного елементу в циклі ніколи не сягне 0, і значення ніколи не будуть очищені.</p>
<h3 id="Створення-циклу-посилань"><a class="header" href="#Створення-циклу-посилань">Створення циклу посилань</a></h3>
<p>Подивімося, як може виникнути цикл посилань і як цьому запобігти, почавши з визначення енуму <code>List</code> і методу <code>tail</code> у Блоці коду 15-25:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}
</code></pre></pre>
<p><span class="caption">Блок коду 15-25: визначення списку cons, що містить <code>RefCell&lt;T&gt;</code>, щоб ми могли змінювати, на що посилається варіант <code>Cons</code></span></p>
<p>Ми використовуємо інший різновид визначення <code>List</code>, ніж у Блоці коду 15-5. Другий елемент у варіанті <code>Cons</code> тепер є <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, що означає, що замість можливості змінювати значення <code>i32</code>, як це було в Блоці коду 15-24, ми хочемо змінити значення <code>List</code>, на яке вказує варіант <code>Cons</code>. Ми також додаємо метод <code>tail</code>, щоб зробити зручним доступ до другого елементу в варіанті <code>Cons</code>.</p>
<p>У Блоці коду 15-26 ми додаємо функцію <code>main</code>, що використовує визначення з Блока коду 15-25. Цей код створює список <code>a</code> і список <code>b</code>, що вказує на список <code>a</code>. Тоді він змінює список <code>a</code> так, що той вказує на <code>b</code>, утворивши цикл посилань. Вздовж усього шляху розставлені інструкції <code>println!</code>, щоб показати значення лічильників посилань в різних точках цього процесу.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-26: створення циклу посилань з двох значень <code>List</code>, що вказують одне на іншого</span></p>
<p>Ми створили екземпляр <code>Rc&lt;List&gt;</code>, що містить значення <code>List</code>, у змінній <code>a</code>, з початковим списком <code>5, Nil</code>. Далі ми створюємо екземпляр <code>Rc&lt;List&gt;</code>, що містить інше значення <code>List</code>, у змінній <code>b</code>, зі значенням 10, що вказує на список <code>a</code>.</p>
<p>Ми змінюємо <code>a</code> так, що воно вказує на <code>b</code> замість <code>Nil</code>, утворивши цикл. Ми робимо це за допомогою методу <code>tail</code>, щоб отримати посилання на <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> у <code>a</code>, який ми кладемо у змінну <code>link</code>. Потім ми використовуємо метод <code>borrow_mut</code> для <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, щоб змінити значення всередині з <code>Rc&lt;List&gt;</code>, що містить значення <code>Nil</code>, на <code>Rc&lt;List&gt;</code> в <code>b</code>.</p>
<p>Коли ми запустимо цей код із закоментованим поки що останнім <code>println!</code>, то отримаємо таке:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>Лічильник посилань екземплярів <code>Rc&lt;List&gt;</code> в обох <code>a</code> і <code>b</code> має значення 2 після того, як ми змінюємо список в <code>a</code>, щоб він вказував на <code>b</code>. У кінці <code>main</code> Rust очищує змінну <code>b</code>, яка зменшує лічильник посилань екземпляра <code>Rc&lt;List&gt;</code> <code>b</code> з 2 до 1. Пам'ять, яку <code>Rc&lt;List&gt;</code> тримає в купі, не буде скинуто у в цей момент, тому що лічильник посилань дорівнює 1, а не 0. Потім Rust очищує <code>a</code>, так само зменшуючи кількість посилань екземпляра <code>Rc&lt;List&gt;</code> <code>a</code> з 2 до 1. Пам'ять цього екземпляра також не може бути очищена, тому що інший екземпляр <code>Rc&lt;List&gt;</code> досі посилається на неї. Пам'ять, виділена для списку, залишиться незвільненою назавжди. Щоб візуалізувати цей цикл посилань, ми створили діаграму на Рисунку 15-4.</p>
<img alt="Цикл посилань у списках" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">Рисунок 15-4: цикл посилань у списках <code>a</code> і <code>b</code>, що вказують один на іншого</span></p>
<p>Якщо ви розкоментуєте останній <code>println!</code> і запустите програму, Rust спробує надрукувати цей цикл з <code>a</code>, що вказує на <code>b</code> що вказує на <code>a</code> і так далі, поки стек не переповниться.</p>
<p>Порівняно з реальними програмами, наслідки створення циклу посилань в цьому прикладі не дуже страшні: одразу після того, як ми створили цикл посилань, програма завершується. Однак, якщо складніша програма виділяє багато пам'яті в циклі працює досить тривалий час, програма буде використовувати більше пам’яті, ніж їй потрібно і може перенавантажити систему, призвівши до вичерпання доступної пам'яті.</p>
<p>Створити цикл посилань - не проста задача, але й не неможлива. Якщо у вас є значення <code>RefCell&lt;T&gt;</code>, що містять <code>Rc&lt;T&gt;</code> або аналогічну вкладену комбінацію типів з внутрішньою мутабельністю і лічильником посилань, ви повинні переконатися, що не створюєте циклів; ви не можете розраховувати на те, що Rust їх виявить. Створення циклу посилань буде логічною помилкою у вашій програмі, і ви маєте використовувати автоматизовані тести, надавати код для огляду іншим програмістам та інші практики розробки програм, щоб мінімізувати їхню можливість.</p>
<p>Іншим рішенням для уникнення циклів посилань є реорганізація ваших структур даних структур так, щоб деякі посилання виражали володіння, а деякі ні. У результаті можуть виникати цикли, утворені кількома відносинами володіння і кількома без володіння, і тільки відносини володіння працею впливають на те, чи можна очистити значення. У Блоці коду 15-25 ми завжди хочемо, щоб варіант <code>Cons</code> володів списком, тому реорганізація структури даних неможлива. Подивімося на приклад графу, зробленого з батьківських і дочірніх вузлів, щоб побачити, коли відносини без володіння є адекватним способом запобігти циклу посилань.</p>
<h3 id="Запобігання-циклам-посилань-перетворення-rct-на-weakt"><a class="header" href="#Запобігання-циклам-посилань-перетворення-rct-на-weakt">Запобігання циклам посилань: перетворення <code>Rc&lt;T&gt;</code> на <code>Weak&lt;T&gt;</code></a></h3>
<p>Поки що ми продемонстрували, що виклик <code>Rc::clone</code> збільшує <code>strong_count</code> у екземплярі <code>Rc&lt;T&gt;</code>, і екземпляр <code>Rc&lt;T&gt;</code> очищується лише якщо його <code>strong_count</code> дорівнює 0. Ви також можете створити <em>weak reference</em> на значення в екземплярі <code>Rc&lt;T&gt;</code>, викликавши <code>Rc::downgrade</code> і передавши посилання до <code>Rc&lt;T&gt;</code>. Сильні посилання - це спосіб поділитися володінням екземпляром <code>Rc&lt;T&gt;</code>. Слабкі посилання не виражають відношення володіння і їхня кількість не впливає на те, коли екземпляр <code>Rc&lt;T&gt;</code> буде очищено. Вони не викликають циклу посилань, оскільки будь-який цикл, який передбачає деякі слабкі посилання, буде зламано, коли лічильник сильних посилань набуде значення 0.</p>
<p>Коли ви викликаєте <code>Rc::downgrade</code>, ви отримуєте розумний вказівник типу <code>Weak&lt;T&gt;</code>. Замість збільшувати <code>strong_count</code> у екземплярі <code>Rc&lt;T&gt;</code> на 1, виклик <code>Rc::downgrade</code> збільшує <code>weak_count</code> на 1. Тип <code>Rc&lt;T&gt;</code> тип використовує <code>weak_count</code>, щоб відстежувати, скільки існує посилань <code>Weak&lt;T&gt;</code>, подібно до <code>strong_count</code>. Різниця в тому, що <code>weak_count</code> не має бути 0, щоб екземпляр <code>Rc&lt;T&gt;</code> був очищений.</p>
<p>Оскільки значення, на яке посилається <code>Weak&lt;T&gt;</code>, може бути очищене, щоб зробити будь-що зі значенням, на яке вказує <code>Weak&lt;T&gt;</code>, ви маєте переконатися, що воно ще існує. Це можна зробити, викликавши метод <code>upgrade</code> екземпляру <code>Weak&lt;T&gt;</code>, який поверне <code>Option&lt;Rc&lt;T&gt;&gt;</code>. Ви отримаєте результат <code>Some</code>, якщо значення <code>Rc&lt;T&gt;</code> ще не було очищене, і результат <code>None</code>, якщо значення <code>Rc&lt;T&gt;</code> було очищене. Оскільки <code>upgrade</code> повертає <code>Option&lt;Rc&lt;T&gt;&gt;</code> Rust гарантує, що варіанти <code>Some</code> і <code>None</code> будуть оброблені, і не буде некоректного вказівника.</p>
<p>Як приклад, замість того, щоб використовувати список, елементи якого знають лише про наступний елемент, ми створимо дерево, чиї елементи будуть знати про дочірні елементи <em>і</em> про свої батьківські елементи.</p>
<h4 id="Створення-структури-даних---дерева-вузол-node-і-дочірні-вузли"><a class="header" href="#Створення-структури-даних---дерева-вузол-node-і-дочірні-вузли">Створення структури даних - дерева: вузол <code>Node</code> і дочірні вузли</a></h4>
<p>Для початку ми побудуємо дерево з вузлами, що знають про свої дочірні вузли. Ми створимо структуру <code>Node</code>, що міститиме значення <code>i32</code>, а також посилання на свої дочірні значення <code>Node</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}
</span></code></pre></pre>
<p>Ми хочемо, щоб <code>Node</code> володів своїми дочірніми вузлами, і хочемо ділитися цим володінням зі змінними, щоб ми могли отримати доступ до кожного <code>Node</code> в дереві безпосередньо. Для цього ми визначаємо <code>Vec&lt;T&gt;</code> елементів, значення яких мають тип <code>Rc&lt;Node&gt;</code>. Ми також хочемо змінити, які вузли є дочірніми для іншого вузла, тож ми маємо в <code>children</code> <code>RefCell&lt;T&gt;</code> навколо <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>Далі ми використаємо визначення нашої структури і створимо один екземпляр <code>Node</code> з назвою <code>leaf</code>, значенням 3 і без дочірніх вузлів, і інший екземпляр з назвою <code>branch</code>, значенням 5 і <code>leaf</code> як один з дочірніх вузлів, як показано у Блоці коду 15-27:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-27: створення вузла <code>leaf</code> без дочірніх вузлів і вузла <code>branch</code> з одним дочірнім вузлом <code>leaf</code></span></p>
<p>Ми клонуємо <code>Rc&lt;Node&gt;</code> в <code>leaf</code> і зберігаємо його в <code>branch</code>, що означає, що <code>Node</code> в <code>leaf</code> має два володільці: <code>leaf</code> і <code>branch</code>. Ми можемо дістатися з <code>branch</code> до <code>leaf</code> через <code>branch.children</code>, але немає жодного способу дістатися з <code>leaf</code> до <code>branch</code>. Причина в тому, що<code>leaf</code> не має посилання на <code>branch</code> і не знає, що вони пов'язані. Нам потрібно, щоб <code>leaf</code> знав, що <code>branch</code> - це його батьківський елемент. Цим ми й займемося.</p>
<h4 id="Додавання-посилання-з-дочірнього-вузла-на-батьківський"><a class="header" href="#Додавання-посилання-з-дочірнього-вузла-на-батьківський">Додавання посилання з дочірнього вузла на батьківський</a></h4>
<p>Щоб надати дочірньому вузлу інформацію про батьківський, ми повинні додати поле <code>parent</code> до визначення структури <code>Node</code>. Проблема в тому, щоб вирішити, якого типу має бути <code>parent</code>. Ми знаємо, що він не може містити <code>Rc&lt;T&gt;</code>, бо це створить цикл посилань, адже <code>leaf.parent</code> вказуватиме на <code>branch</code>, а <code>branch.children</code> вказуватиме на <code>leaf</code>, що призведе до того, що їхні значення <code>strong_count</code> ніколи не стануть 0.</p>
<p>Подумаємо про відносини іншим чином: батьківський вузол повинен володіти дочірніми, і якщо батьківський вузол очищується, його дочірні вузли також мають бути очищені. Однак дочірній вузол не має володіти батьківським: якщо ми очищуємо дочірній вузол, батьківський має лишитися. Це якраз випадок для слабких посилань!</p>
<p>Отже, замість <code>Rc&lt;T&gt;</code>, для типу <code>parent</code> скористаємося <code>Weak&lt;T&gt;</code>, а точніше, <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Тепер наш вузол <code>Node</code> виглядає наступним чином:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">}
</span></code></pre></pre>
<p>Вузол тепер може посилатися на батьківський вузол, але не володіє ним. У Блоці коду 15-28 ми оновлюємо <code>main</code>, щоб використати нове визначення, так щоб вузол <code>leaf</code> матиме спосіб послатися на батьківський вузол <code>branch</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-28: вузол <code>leaf</code> зі слабким посиланням на свій батьківський вузол <code>branch</code></span></p>
<p>Створення вузла <code>leaf</code> виглядає схожим на Блок коду 15-27, за винятком поля <code>parent</code>: <code>leaf</code> спершу не має батьківського вузла, тож ми створюємо новий, порожній екземпляр посилання <code>Weak&lt;Node&gt;</code>.</p>
<p>На цей момент, коли ми намагаємося отримати посилання на батьківський вузол вузла <code>leaf</code> за допомогою методу <code>upgrade</code>, то отримуємо значення <code>None</code>. Ми бачимо це з того, що виводить перша інструкція <code>println!</code>:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>Коли ми створюємо вузол <code>branch</code>, він також матиме нове посилання <code>Weak&lt;Node&gt;</code> в полі <code>parent</code>, оскільки <code>branch</code> не має батьківського вузла. Але, як і раніше, <code>leaf</code> є одним з дочірніх посилань у <code>branch</code>. Але коли ми вже маємо екземпляр <code>Node</code> у <code>branch</code>, то ми можемо змінити <code>leaf</code>, щоб дати йому посилання <code>Weak&lt;Node&gt;</code> на його батька. Ми використовуємо метод <code>borrow_mut</code> для <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> в полі <code>parent</code> змінної <code>leaf</code>, а потім ми використовуємо функцію <code>Rc::downgrade</code>, щоб створити посилання <code>Weak&lt;Node&gt;</code> на <code>branch</code> з <code>Rc&lt;Node&gt;</code> у <code>branch</code>.</p>
<p>Коли ми ще раз виводимо батька <code>leaf</code> ще раз, цього разу ми отримуємо варіант <code>Some</code>, що містить <code>branch</code>: тепер <code>leaf</code> може отримати доступ свого батька! Коли ми виводимо <code>leaf</code>, то також уникаємо циклу, який врешті-решт переповнив би стеку, як було у Блоці коду 15-26; посилання <code>Weak&lt;Node&gt;</code> виводяться як <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>Відсутність нескінченого виведення показує, що цей код не створив циклу посилань. Ми також можемо сказати це, переглянувши значення, які ми отримаємо від виклику <code>Rc::strong_count</code> та <code>Rc::weak_count</code>.</p>
<h4 id="Візуалізація-змін-у-strong_count-і-weak_count"><a class="header" href="#Візуалізація-змін-у-strong_count-і-weak_count">Візуалізація змін у <code>strong_count</code> і <code>weak_count</code></a></h4>
<p>Подивімося, як змінюються значення <code>strong_count</code> і <code>weak _count</code> екземплярів <code>Rc&lt;Node&gt;</code>, створивши нову внутрішню область видимості і перемістивши туди створення <code>branch</code>. Зробивши це, ми зможемо побачити, що відбувається, коли <code>branch</code> створюється, а потім очищується, коли виходить за межі області видимості. Зміни показані у Блоці коду 15-29:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre></pre>
<p><span class="caption">Блок коду 15-29: створення <code>branch</code> у внутрішній області видимості і перевірка лічильників сильних та слабких посилань</span></p>
<p>Після створення <code>leaf</code> його <code>Rc&lt;Node&gt;</code> налічує 1 сильне посилання і 1 слабке. У внутрішній області видимості ми створюємо <code>branch</code> і пов'язуємо її з <code>leaf</code>. У цей момент, коли ми виводимо лічильники, <code>Rc&lt;Node&gt;</code> у <code>branch</code> матиме лічильник сильних 1 і слабких 1 (у <code>leaf.parent</code>, що вказує на <code>branch</code> за допомогою <code>Weak&lt;Node&gt;</code>). Коли ми виводимо лічильники <code>leaf</code>, то бачимо, що сильних посилань 2, бо <code>branch</code> тепер зберігає клон <code>Rc&lt;Node&gt;</code> з <code>leaf</code> у <code>branch.children</code>, але все ще має 0 слабких посилань.</p>
<p>Коли внутрішня область видимості закінчується, <code>branch</code> виходить з видимості і лічильних сильних посилань <code>Rc&lt;Node&gt;</code> зменшується до 0, тож <code>Node</code> очищується. Лічильник слабких посилань 1 у <code>leaf.parent</code> не має стосунку до того, чи очиститься <code>Node</code>, тож ми більше не маємо витоків пам'яті!</p>
<p>Якщо ми спробуємо дістатися до батька змінної <code>leaf</code> після виходу з області видимості, ми знову отримаємо <code>None</code>. Наприкінці програми <code>Rc&lt;Node&gt;</code> у <code>leaf</code> має лічильник сильних посилань 1 і слабких 0, бо змінна <code>leaf</code> тепер знову є єдиним посиланням на <code>Rc&lt;Node&gt;</code>.</p>
<p>Вся логіка, яка керує лічильниками та очищенням значень, вбудована в <code>Rc&lt;T&gt;</code> і <code>Weak&lt;T&gt;</code> і їхні реалізації трейту <code>Drop</code>. Вказавши у визначенні <code>Node</code>, що стосунки дочірнього вузла до батьківського мають бути посиланням <code>Weak&lt;T&gt;</code>, ви змогли отримати взаємні посилання з батьківських вузлів до дочірніх і назад, не створивши циклу посилань і витоку пам'яті.</p>
<h2 id="Підсумок-14"><a class="header" href="#Підсумок-14">Підсумок</a></h2>
<p>Цей розділ висвітлив, як використовувати розумні вказівники для отримання гарантій та недоліків, що відрізняються від тих, які Rust робить за замовчуванням для звичайних посилань. Тип <code>Box&lt;T&gt;</code> має відомий розмір і вказує на дані, розташовані в купі. Тип <code>Rc&lt;T&gt;</code> відстежує кількість посилань на дані в купі, так що ці дані можуть мати кілька власників. Тип <code>RefCell&lt;T&gt;</code> завдяки внутрішній мутабельності надає нам тип, який ми можемо використовувати, коли потребуємо незмінного типу, але має мо змінювати внутрішнє значення цього типу; він також застосовує правила позичання під час виконання замість часу компіляції.</p>
<p>Також ми обговорили трейти <code>Deref</code> і <code>Drop</code>, які дозволяють застосувати функціональність розумних вказівників. Ми дослідили цикли посилань, які можуть викликати витоки пам’яті, і як запобігти їм за допомогою <code>Weak&lt;T&gt;</code>.</p>
<p>Якщо ця глава зацікавила вас і ви хочете реалізувати свої власні розумні вказівники, перегляньте <a href="../nomicon/index.html">&quot;The Rustonomicon&quot;</a> для отримання додаткової корисної інформації.</p>
<p>Далі ми поговоримо про конкурентне виконання в Rust. Ви дізнаєтеся про ще кілька нових розумних вказівників.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Конкурентність-без-страху"><a class="header" href="#Конкурентність-без-страху">Конкурентність без страху</a></h1>
<p>Ще одна головна мета Rust є безпечна та ефективна обробка конкурентності. <em>Конкурентне програмування</em>, коли різні частини програми виконуються незалежно, та <em>паралельне програмування</em>, коли різні частини програми виконуються одночасно, стає все більш важливим, оскільки більше комп'ютерів використовують декілька процесорів. Історично, програмування в цих контекстах було дуже складне і схильне до помилок: Rust сподівається змінити це.</p>
<p>Спочатку, команда Rust думала що забезпечення безпеки пам'яті та запобігання проблем конкурентності були двома різними проблемами, які слід вирішувати різними методами. З часом, команда виявила що системи властності та типів є потужним набором інструментів що може допомогти з проблемами захисту пам'яті <em>і</em> конкурентності! Використовуючи перевірку власника та типів, багато помилок конкурентної призводять до помилок під час компіляції в Rust, а не під час виконання. Тому замість, того щоб витрачати багато часу у спробах відтворити конкретні обставини, за якої відбуватиметься помилка конкурентності під час виконання, неправильний код відмовиться компілюватись та виведе помилку що пояснює проблему. Як результат, ви можете виправити ваш код під час роботи над ним, а не потенційно після того, як він був відправлений у виробництво. Ми назвемо цей аспект Rust <em>безстрашною</em> <em>конкурентністю</em>. Безстрашна конкурентність дозволяє вам писати код що вільний від складних для пошуку помилок, та легкий для рефакторингу без запровадження нових помилок.</p>
<blockquote>
<p>Примітка: Заради спрощення, ми будемо більшість проблем називати як <em>конкурентність</em>, а не більш точним визначенням <em>конкурентність та/або паралелізм</em>. Якби ця книга була про конкурентність та/або паралелізм, ми були б більш конкретними. Для цього розділу, будь ласка, коли ми використовуємо <em>конкурентність</em> в себе в голові замінюйте на <em>конкурентність та/або паралелізм</em>.</p>
</blockquote>
<p>Багато мов дуже догматичні в вирішені проблеми обробки конкурентності. Наприклад, Erlang має дуже елегантний функціонал для конкурентної передачі повідомлень, але також лише незрозумілі методи спільного використання стану між потоками. Підтримка лише частини можливих вирішень є розумною стратегією для мов високого рівня, тому що мови високого рівня обіцяють переваги від передачі частини контролю задля отримання абстракцій. Проте, мови низького рівня очікувано надають вирішення кращі за швидкодією в будь-яких випадках, але мають менше абстракцій від заліза. Тому, Rust пропонує різноманітні інструменти для моделювання проблем в будь-який спосіб що відповідає вашій ситуації та вимогам.</p>
<p>В даному розділі ми розглянемо наступні теми:</p>
<ul>
<li>Як створити потоки для запуску кілька частин коду одночасно</li>
<li>Конкурентна <em>передача повідомлень</em>, де канали відсилають повідомлення між потоками</li>
<li>Конкурентний <em>спільний стан</em>, де декілька потоків мають доступ до одної частини даних</li>
<li><code>Sync</code> та <code>Send</code> трейти, які поширюють гарантії паралельності Rust на типи, визначені користувачем, а також типи, надані стандартною бібліотекою</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Використання-потоків-для-одночасного-запуску-коду"><a class="header" href="#Використання-потоків-для-одночасного-запуску-коду">Використання потоків для одночасного запуску коду</a></h2>
<p>В більшості сучасних операційних систем, код виконуємої програми запускається в середині <em>процесу</em>, а операційна система керує багатьма процесами одночасно. Всередині програми ви можете мати незалежні частини, які виконуються одночасно. Фунціонал, який виконує такі незалежні частини називають <em>потоками</em> або <em>тредами</em>. Наприклад, вебсервер може використовувати декілька потоків і таким чином мати змогу обробляти більше одного запиту одночасно.</p>
<p>Розділення обчислень між декількома потоками для одночасного виконання кількох завдань може покращити швидкість виконання програми, але також підвищує складність програми. Оскільки потоки можуть виконуватись одночасно, немає жодної гарантії стосовно порядку виконання частин коду в різних потоках. Це може призвести до наступних проблем:</p>
<ul>
<li>стан гонитви, за якого потоки отримують доступ до даних або ресурсів в довільному порядку</li>
<li>дедлоки, коли два потоки чекають один одного, перешкоджаючи продовженню виконанняя обох потоків</li>
<li>помилки, що виникають виключно за певних обставин і які важко відворити та надійно виправити</li>
</ul>
<p>Rust намагається помʼякшити негативні наслідки використання потоків, але програмування в багатопоточному контексті все ще вимагає ретельного обдумування та потребує структуру коду, відмінну від програм, що виконуються в одному потоці.</p>
<p>Мови програмування імплементують потоки декількома різними способами, а багато операційних систем надають API, який мова може використовувати для створення нових потоків. Стандартна бібліотека Rust використовує модель імплементації потоку <em>1:1</em>, за якої програма використовує один потік операційної системи на один потік, що використовує мова. Існують крейти, котрі імплементують інші моделі потоків, що йдуть на інші компроміси порівняно з моделью 1:1.</p>
<h3 id="Створення-нового-потоку-за-допомогою-spawn"><a class="header" href="#Створення-нового-потоку-за-допомогою-spawn">Створення нового потоку за допомогою <code>spawn</code></a></h3>
<p>Для того, щоб створити новий потік, ми викликаємо функцію <code>thread::spawn</code> і передаємо їй замикання (ми вже говорили про них в Розділі 13), що містить в собі код, який ми хочемо запустити всередині нового потоку. Приклад у Лістінгу 16-1 виводить на екран деякий текст з основного потоку, а також інший текст з нового потоку:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p><span class="caption">Блок коду 16-1: Створення нового потоку для виводу на екран деяку стрічку, поки основний потік виводить іншу стрічку</span></p>
<p>Зверніть увагу, що коли основний потік Rust програми завершується, всі створені потоки припиняють існувати, незалежно від того завершили вони своє виконання чи ні. Вивід цієї програми може дещо відрізнятись від запуску до запуску, але виглядатиме приблизно так:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>Виклики <code>thread::sleep</code> змушують потік припинити виконання на короткий період часу, дозволяючи виконувати інший потік. Ймовірно, потоки будуть виконуватись по черзі, проте це не гарантовано, а залежить від того, як ваша операційна система планує виконання потоків. Цього разу, основний потік вивів на екран стрічку першим, незважаючи на те, що print statement в новому потоці зʼявляється у коді раніше. Незважаючи на те, що ми запрограмували новостворений потік виводити екран стрічки доти, поки <code>i</code> не дорівнюватиме 9, він вивів лише 5 стрічок до завершення основного потоку.</p>
<p>Якщо ви запускаєте цей код і бачите лише вивід з основного потоку або ж не бачите жодного оверлепу, спробуйте збільшити діапазон чисел, щоб створити для операційної системи більше умов для переключання між потоками.</p>
<h3 id="Очікування-закінчення-виконання-всіх-потоків-з-використанням-join-handles"><a class="header" href="#Очікування-закінчення-виконання-всіх-потоків-з-використанням-join-handles">Очікування закінчення виконання всіх потоків з використанням <code>join</code> handles</a></h3>
<p>Код в Блоці коду 16-1 не лише передчасно зупиняє створений потік в більшості випадків через завершення основного потоку, але оскільки гарантії щодо порядку виконання потоків відсутні, ми не можемо гарантувати, що створені потоки взагалі будуть виконуватись!</p>
<p>Ми можемо вирішити проблему, коли створений потік не виконується або ж передчасно завершує виконання, зберігаючи значення, що повертає <code>thread::spawn</code> в змінну. <code>thread::spawn</code> повертає значення, що має тип <code>JoinHandle</code>. <code>JoinHandle</code> - це owned value (значення, яким володіють), котре при виклику на ньому методу <code>join</code>, чекатиме завершення виконання потоку. Блок коду 16-2 демонструє як використовувати <code>JoinHandle</code> потоку, котрий ми створили в блоці коду 16-1, а також викликати <code>join</code> щоб пересвідчитись, що новостворений потік закінчує виконання раніше, ніж <code>main</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Блок коду 16-2: Збереження <code>JoinHandle</code> з <code>thread::spawn</code> щоб гарантувати виконання потоку до завершення</span></p>
<p>Виклик <code>join</code> на обробнику (хендлері) блокує потік, що наразі виконується аж до моменту, коли потік, представлений обробником, не завершиться. <em>Блокування</em> потоку означає, що такий потік не може виконуватися або ж завершитись. Оскільки ми помістили виклик <code>join</code> після циклу <code>for</code> в основному потоці, виконання Блоку коду 16-2 має вивести на екран щось схоже на наступне:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>Два потоки продовжують виконуватися по черзі, але основний потік чекає через виклик <code>handle.join()</code> і не завершується, доки не завершиться створений потік.</p>
<p>Однак давайте поглянемо, що трапиться, якщо замість цього розмістити <code>handle.join()</code> перед циклом <code>for</code> всередині <code>main</code>, як тут:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p>Основний потік чекатиме на завершення виконання створеного треду і лише після цього виконуватиме цикл <code>for</code>, тому вивід більше не буде чергуватись, як показано тут:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Дрібні деталі, такі як-от місце виклику <code>join</code>, можуть впливати на те чи будуть ваші потоки виконуватись одночасно.</p>
<h3 id="Використання-move-замикання-із-потоками"><a class="header" href="#Використання-move-замикання-із-потоками">Використання <code>move</code> замикання із потоками</a></h3>
<p>Ми будемо часто використовувати ключове слово <code>move</code> разом з замиканнями, переданими всередину <code>thread::spawn</code>, оскільки замикання тоді почне володіти значеннями, які вона використовує з оточуючого контексту (середовища), таким чином передаючи володіння значеннями з одного потоку в інший. У підрозділі <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">&quot;Захоплення посилань або переміщення володіння&quot;</a><!-- ignore
--> Розділу 13, ми розглядали </p>
<p><code>move</code> в контексті замикань. Зараз же, ми сконцентруємось більше на взаємодії між <code>move</code> та <code>thread::spawn</code>.</p>
<p>Зверніть увагу, в Блоці коду 16-1 замикання, яке ми передаємо в <code>thread::spawn</code> не приймає жодних аргументів: ми не використовуємо жодних даних з основного потоку в коді створеного потоку. Для того, щоб використовувати дані з основного потоку в створеному потоці, замикання створеного потоку має захопити (capture) потрібні значення. Блок коду 16-3 показує спробу створити вектор в основному потоці, а потім використати його в створеному. Однак, це не запрацює одразу, як ви зможете незабаром пересвідчитись.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">Блок коду 16-3: Спроба використати вектор, створений основним потоком, в іншому потоці</span></p>
<p>Замикання використовує <code>v</code>, отже, воно захопить <code>v</code> і зробить його частиною контексту замикання. Оскільки <code>thread::spawn</code> виконує замикання в новому потоці, ми повинні мати доступ до <code>v</code> всередині нового потоку. Однак, коли ми скомпілюємо цей приклад, ми отримаємо наступну помилку:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!(&quot;Here's a vector: {:?}&quot;, v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` due to previous error
</code></pre>
<p>Rust <em>здогадується</em> як захопити <code>v</code>, і саме тому <code>println!</code> потребує тільки посилання на <code>v</code>, а замикання намагається запозичити <code>v</code>. Однак є проблема: Rust не може здогадатись як довго потік буде виконуватись, отже, Rust не знає чи буде посилання на <code>v</code> завжди валідним (valid).</p>
<p>Блок коду 16-4 показує випадок, який, швидше за все, матиме невалідне посилання на <code>v</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">Блок коду 16-4: Потік з замиканням, що намагається захопити (capture) посилання на <code>v</code> з основного потоку, який видаляє <code>v</code></span></p>
<p>Якщо Rust дозволить нам виконати цей код, існує ймовірність, що створений потік буде негайно переведений в бекграунд (background) і не буде виконуватись взагалі. Створений потік має посилання на <code>v</code> всередині себе, але основний потік негайно викидає (drops) <code>v</code>, використовуючи функцію <code>drop</code>, котру ми розглядали у Розділі 15. Потім, коли створений потік починає виконуватись, <code>v</code> більше невалідний, тому посилання на нього також невалідне. О ні!</p>
<p>Щоб виправити помилку компілятора в блоці коду 16-3, ми можем скористатись порадою, яку надає повідомлення про помилку:</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>Додаючи ключове слово <code>move</code> перед замиканням, ми змушуємо замикання взяти володіння над значеннями, котрі воно використовує, не дозволяючи Rust робити припущення стосовно позичання (borrowing) значень. Модифікація до Блоку коду 16-3, показана в Блоці коду 16-5 скомпілюється і виконуватиметься так, як ми задумали:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Блок коду 16-5: Використання ключового слова <code>move</code>, щоб примусити замикання взяти володіння над значеннями, які воно використовує</span></p>
<p>В нас може виникнути спокуса спробувати той самий підхід, щоб виправити код у Блоці коду 16-4, де основний потік викликав <code>drop</code>, використовуючи замикання з <code>move</code>. Однак, це не спрацює, оскільки те, що Блок коду 16-4 намагається зробити, заборонено з іншої причини. Якщо ми додамо <code>move</code> до замикання, ми перенемістили <code>v</code> в контекст замикання, тому ми більше не можемо викликати <code>drop</code> на ньому в основному потоці. Замість цього ми отримаємо помилку компіляції:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  | 
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!(&quot;Here's a vector: {:?}&quot;, v);
   |                                           - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` due to previous error
</code></pre>
<p>Правила володіння Rust знову нас врятували! Ми отримали помлку в Блоці коду 16-3, оскільки Rust був консервативним і позичив лише <code>v</code> для потоку, а отже, основний потік міг теоретично зробити посилання, що використовувалось у створеному потоці, невалідним. Сказавши Rust передати володіння <code>v</code> створеному потоку, ми гарантуємо Rust, що основний потік більше не використовуватиме <code>v</code>. Якщо ми змінимо Блок коду 16-4 таким же чином, то ми порушимо правила володіння, коли намагатимемось використати <code>v</code> в основному потоці. Ключове слово <code>move</code> бере гору над правилами володіння, що Rust використовує за замовчуванням; таким чином не ми не порушуємо правила володіння.</p>
<p>Маючи базове розуміння потоків і API потоків (прикладний програмний інтерфейс потоків), давайте поглянемо що ми можемо <em>робити</em> з потоками.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Використання-обміну-повідомленнями-для-передачі-данних-між-потоками"><a class="header" href="#Використання-обміну-повідомленнями-для-передачі-данних-між-потоками">Використання обміну повідомленнями для передачі данних між потоками</a></h2>
<p>Одним із набираючих популярність підходів для забезпечення безпечної конкурентності є <em>обмін повідомленнями</em>, коли потоки або ж актори комунікують надсилаючи один одному повідомлення, що містять дані. Ось основна ідея, виражена в слогані з [документації мови програмування Go](https://go. dev/doc/effective_go#concurrency): &quot;Не комунікуйте за допомогою спільної памʼяті; замість цього, діліться памʼяттю комунікуючи.&quot;</p>
<p>Для досягнення конкурентності за допомогою обміну повідомленнями, стандартна бібліотека Rust надає імплементацію <em>каналів</em>. Канал - це загальна концепція програмування, основна ідея якої полягає в тому, що дані надсилаються з одного потоку в інший.</p>
<p>Ви можете уявити канал в програмуванні схожим на напрямлений канал води, такий як струмок чи річка. Якщо ви помістите щось на кшталт гумової качечки в річку, вона попливе вниз за течією аж до кінця водного шляху.</p>
<p>Канал має дві половини: передавач (transmitter) і отримувач (receiver). Передавач - це місце, де ви пускаєте за течією гумових качечок, а отримувач - це місце куди гумова качечка потрапляє в кінці течії. Одна частина вашого коду викликає методи передавача з даними, які ви хочете відправити, а інша частина перевіряє отримувач на наявність отриманих повідомлень. Канал вважається <em>закритим</em> якщо передавач або ж отримувач були видалені.</p>
<p>Надалі, ми попрацюємо над програмою, яка має один потік для генерації значень і надсилання їх по каналу, а інший потік отримуватиме значення і виводитиме їх на екран. Ми відправлятимемо прості значення між потоками використовуючи канали для ілюстрації даного функціоналу. Як тільки ви познайомитесь з даним підходом, ви зможете використовувати канали для будь-яких потоків, яким потрібно комунікувати між собою, таким як чат-системи або ж системи, де багато потоків виконують частини обчислень і надсилають результати в один потік, котрий агрегує ці результати.</p>
<p>Спочатку, в Блоці коду 16-6, ми створимо канал, але не будемо нічого з ним робити. Зверніть увагу, що даний приклад поки що не скомпілюється, оскільки Rust не може визначити які типи значень ми хочемо надсилати через канал.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
</code></pre>
<p><span class="caption">Блок коду 16-6: Створення каналу і присвоєння двох його половин в <code>tx</code> і <code>rx</code></span></p>
<p>Ми створюємо новий канал за допомогою функції <code>mpsc::channel</code>, <code>mpsc</code> означає <em>multiple producer, single consumer</em> (<em>декілька виробників, один споживач</em>). Словом, спосіб, в який стандартна бібліотека Rust імплементує канали означає, що канал може мати декілька <em>відправляючих</em> кінців, які створюють значення, але лише один <em>споживаючий</em> кінець, який споживає значення. Уявіть декілька струмків, що зливаються в одну велику річку: все що буде відправлено за течією будь-якого з струмків в кінці-кінців потрапить в річку. Наразі ми почнемо з одного виробника, але ми додамо ще декілька коли змусимо цей приклад працювати.</p>
<p>Функція <code>mpsc::channel</code> повертає кортеж, першим елементом якого є відправляючий кінець - передавач, а другим елементом є отримуючий кінець - отримувач. Абревіатури <code>tx</code> і <code>rx</code> традиційно використовуються в багатьох сферах для позначення <em>передавача (transmitter)</em> та <em>отримувача (receiver)</em> відповідно, тому ми називаємо наші змінні таким чином, щоб позначити відповідні кінці каналу. Ми використовуємо інструкцію <code>let</code> з шаблоном, що деструктуризує кортежі; ми обговоримо використання шаблонів в інструкціях <code>let</code> та деструктуризацію в Розділі 18. Наразі ж знайте, що використання інструкції <code>let</code> в такий спосіб є зручним підходом для витягування (extract) частин кортежу, який повертає після виконання <code>mpsc::channel</code>.</p>
<p>Давайте перемістимо передавач в створений потік і попросимо його надіслати одну стрічку, щоб даний потік комунікував з основним потоком, як показано в Блоці коду 16-7. Це як помістити гумову качечку в річку вище за течією або ж надіслати чат-повідомлення з одного потоку в інший.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<p><span class="caption">Блок коду 16-7: Переміщення <code>tx</code> в створений потік і відправка &quot;hi&quot;</span></p>
<p>Знову ж таки, ми використовуємо <code>thread::spawn</code> щоб створити новий потік і потім використовуємо <code>move</code> щоб помістити <code>tx</code> всередину замикання, адже таким чином потік володітиме <code>tx</code>. Створений потік має володіти передавачем, щоб мати можливість надсилати повідомлення по каналу. Передавач має метод <code>send</code>, котрий приймає значення, яке ми хочемо надіслати. Метод <code>send</code> повертає <code>Result&lt;T, E&gt;</code>, отже, якщо отримувач був видалений й немає куди надіслати значення, операція поверне помилку. В даному прикладі, ми викликаємо <code>unwrap</code>, щоб наш код запанікував у випадку помилки. Однак в справжньому додатку ми б обробили помилки належним чином: поверніться до Розділу 9 щоб переглянути стратегії належної обробки помилок.</p>
<p>В Блоці коду 16-8 ми в основному потоці отримаємо/дістанемо значення з отримувача. Це як дістати гумову качечку з води в кінці річки або ж отримати повідомлення в чаті.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<p><span class="caption">Блок коду 16-8: Отримання значення &quot;hi&quot; в основному потоці та вивід його на екран</span></p>
<p>Отримувач має два корисні методі: <code>recv</code> та <code>try_recv</code>. Ми використовуємо <code>recv</code>, скорочено від <em>receive</em>, який заблокує виконання основного потоку і чекатиме доки значення буде надіслане в канал. Як тільки значення буде надіслане, <code>recv</code> поверне його, обернувши в <code>Result&lt;T, E&gt;</code>. Коли передавач закриється, <code>recv</code> поверне помилку, яка сигналізує про те, що значення більше не надходитимуть.</p>
<p>Метод <code>try_recv</code> не блокує основний потік, а натомість одразу повертає <code>Result&lt;T, E&gt;</code>: значення <code>Ok</code>, котре містить повідомлення, якщо воно доступне, і <code>Err</code> якщо цього разу немає жодних повідомлень. Використання <code>try_recv</code> корисне якщо потік має виконувати іншу роботу, очікуючи на повідомлення: ми можемо написати цикл, котрий періодично викликає <code>try_recv</code>, обробляє повідомлення, якщо воно доступне, а в іншому випадку деякий час виконує іншу роботу аж до наступної перевірки.</p>
<p>Ми використали <code>recv</code> в цьому прикладі для простоти; ми не маємо жодної іншої роботи для основного потоку, окрім очікування повідомлень, тому блокування основного потоку є доречним/виправданим.</p>
<p>Коли ми запустимо код з Блоку коду 16-8, ми побачимо, що значення виводиться з основного потоку:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
</code></pre>
<p>Ідеально!</p>
<h3 id="Канали-та-передача-володіння"><a class="header" href="#Канали-та-передача-володіння">Канали та передача володіння</a></h3>
<p>Правила володіння відіграють важливу роль в обміні повідомленнями, оскільки вони допомагають вам писати безпечний конкурентний код. Запобігання помилкам в конкурентних програмах - це перевага, яку надає мислення в термінах володіння в ваших Rust програмах. Давайте проведемо експеримент для демонстрації того як канали та володіння працюють разом для запобігання проблемам: ми спробуємо використати значення <code>val</code> в створеному потоці вже <em>після</em> того, як ми надіслали його далі по каналу. Спробуйте скомпілювати код з Блоку коду 16-9 щоб побачити чому він не пропускається компілятором:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        println!(&quot;val is {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre>
<p><span class="caption">Блок коду 16-9: Спроба використати <code>val</code> після того, як воно було надіслане в канал</span></p>
<p>Тут ми намагаємось вивести <code>val</code> на екран вже після того як ми надіслали його по каналу за допомогою <code>tx.send</code>. Дозволяти таке було б поганою ідеєю: як тільки значення буде надіслане в інший потік, такий потік може модифікувати або ж навіть видалити значення, перш ніж ми спробуємо використати його знову. Потенційно, зміни в іншому потоці можуть привести до помилок або ж неочікуваних результатів через суперечливі (inconsistent) або ж неіснуючі дані. Однак, Rust видасть помилку якщо ми спробуємо скомпілювати код з Блоку коду 16-9:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:31
   |
8  |         let val = String::from(&quot;hi&quot;);
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {}&quot;, val);
   |                               ^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` due to previous error
</code></pre>
<p>Наша помилка в роботі з конкурентністю спричинила помилку компіляції. Функція <code>send</code> бере володіння над своїм параметром, а коли значення переміщується (moved), отримувач бере над ним володіння. Це не дає нам випадково повторно використати значення після того як ми його надіслали; правила володіння перевіряють чи все гаразд.</p>
<h3 id="Відправка-декількох-значень-і-спостерігання-за-очікуванням-отримувача"><a class="header" href="#Відправка-декількох-значень-і-спостерігання-за-очікуванням-отримувача">Відправка декількох значень і спостерігання за очікуванням отримувача</a></h3>
<p>Код в Блоці коду 16-8 скомпілювався і виконався, але він не продемонстрував, що два окремі потоки спілкуються між собою через канал. В Блоці коду 16-10 ми зробили деякі зміни, які підтвердять, що код в Блоці коду 16-8 виконується конкурентно: створений потік тепер відсилатиме декілька повідомлень і робитиме секундну паузу між кожним повідомленням.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre>
<p><span class="caption">Блок коду 16-10: Відправка декількох повідомлень із паузою між відправками</span></p>
<p>Цього разу створений потік має вектор стрічок, які ми хочемо надіслати в основний потік. Ми ітеруємось по ним, надсилаючи кожну стрічку окремо, і робимо паузу між кожною відправкою, викликаючи функцію <code>thread::sleep</code> із значенням <code>Duration</code> в 1 секунду.</p>
<p>В основному потоці, ми більше не викликаємо функцію <code>recv</code> явно: замість цього ми розглядаємо <code>rx</code> як ітератор. Отримуючи значення, ми виводимо його на екран. Якщо канал закриється, ітерування припиниться.</p>
<p>Під час виконання коду із Блоку коду 16-10, ви маєте побачити наступний вивід із 1-секундною паузою між кожним рядком:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Оскільки ми не маємо жодного коду, що призупиняє або ж відкладає виконання циклу <code>for</code> в основному потоці, ми можемо сказати, що основний потік очікує отримання значень із створеного потоку.</p>
<h3 id="Створення-декількох-виробників-шляхом-клонування-передавача"><a class="header" href="#Створення-декількох-виробників-шляхом-клонування-передавача">Створення декількох виробників шляхом клонування передавача</a></h3>
<p>Раніше ми вже згадували, що <code>mpsc</code> - це абревіатура для <em>multiple producer, single consumer</em> (<em>кілька виробників, один споживач</em>). Давайте використаємо <code>mpsc</code> і розширимо код в Блоці коду 16-10 щоб створити кілька потоків, котрі надсилають дані одному й тому ж отримувачу. Ми можемо зробити це склонувавши передавач, як показано в Блоці коду 16-11:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;more&quot;),
            String::from(&quot;messages&quot;),
            String::from(&quot;for&quot;),
            String::from(&quot;you&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }

    // --snip--
<span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 16-11: Відправка декількох повідомлень з кількох виробників (producers)</span></p>
<p>Цього разу, перед тим як ми створимо перший потік, ми викликаємо <code>clone</code> на передавачі. Це дасть нам новий передавач, який ми зможемо потім передати в створений потік. Ми передаємо оригінальний передавач в другий створений потік. Це дає нам два потоки, кожен з яких надсилає різні повідомленнями одному отримувачу.</p>
<p>Коли ви виконаєте код, ваш вивід має виглядати приблизно так:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>Ви можете бачити значення в іншому порядку, залежно від вашої системи. Саме це робить конкурентність цікавою, але й складною одночасно. Якщо ви поекспериментуєте з <code>thread::sleep</code>, підставляючи різні значення в різні потоки, кожен запуск буде ще більш недетермінованим і щоразу створюватиме різний вивід.</p>
<p>Тепер, коли ми поглянули на те, як працюють канали, давайте розглянемо інший метод конкурентності.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Паралелізм-із-спільним-станом"><a class="header" href="#Паралелізм-із-спільним-станом">Паралелізм із спільним станом</a></h2>
<p>Обмін повідомленнями - чудовий, але не єдиний спосіб роботи з конкурентністю. Іншим способом можу бути доступ декількох потоків до спільних даних. Розглянемо наступну частину слогану з документації мови програмування Go ще раз: &quot;не комунікуйте за допомогою спільної памʼяті.&quot;</p>
<p>Як би виглядала комунікація за допомогою спільної памʼяті? Окрім того, чому ентузіасти обміну повідомленнями застерігають від використання спільної памʼяті?</p>
<p>У певному сенсі, канали в будь-якій мові програмування схожі на одноособове володіння, тому що як тільки ви передали значення по каналу, ви не повинні більше використовувати таке значення. Конкурентність із спільною памʼяттю нагадує множинне володіння: декілька потоків одночасно мають доступ до однієї і тієї ж області памʼяті. Як ви могли бачити в Розділі 15, де розумні вказівники робили множинне володіння можливим, таке володіння може додати програмі складності, оскільки потрібно управляти різними власниками (owners). Система типів Rust та правила володіння дуже допомагають здійснювати таке управління коректно. Наприклад, давайте розглянемо мʼютекси, один з найпоширеніших примітивів конкурентності для роботи із спільною памʼяттю.</p>
<h3 id="Використання-мʼютексів-для-доступу-до-даних-з-лише-з-одного-потоку-в-момент-часу"><a class="header" href="#Використання-мʼютексів-для-доступу-до-даних-з-лише-з-одного-потоку-в-момент-часу">Використання мʼютексів для доступу до даних з лише з одного потоку в момент часу</a></h3>
<p><em>Mutex (мʼютекс)</em> - це абревіатура для <em>mutual exclusion (взаємне виключення)</em>, оскільки мʼютекс дозволяє лише одному потоку отримувати доступ до даних в будь-який момент часу. Для того, щоб отримати доступ до даних у мʼютексі, потік має спочатку повідомити, що він бажає отримати доступ, запросивши отримати <em>блокування (lock)</em> мʼютексу. Блокування - це структура даних, що є частиною мʼютексу і відстежує хто саме має ексклюзивний доступ до даних. Саме тому, мʼютекс описують як <em>захист</em> даних, які він в собі зберігає, за допомогою системи блокування.</p>
<p>Мʼютекси мають репутацію складного в використанні механізму, оскільки ви маєте памʼятати два правила:</p>
<ul>
<li>Ви повинні спробувати отримати блокування перед використанням даних.</li>
<li>Коли ви закінчите працювати з даними, що захищає мʼютекс, ви маєте розблокувати дані, щоб інші потоки могли отримати блокування.</li>
</ul>
<p>Метафорою для мʼютексу можна вважати панельну дискусію на конференції лише з одним мікрофоном. Перед тим як інший учасник дискусії зможе говорити, він повинен попросити або показати, що він хоче скористатись мікрофоном. Коли він отримає мікрофон, він може говорити стільки, скількі вважає за потрібне, а потім передати мікрофон наступному учаснику дискусії, який просить слово. Якщо учасник дискусії забуває передати мікрофон після того, як він закінчив, то ніхто інший не матиме змоги говорити. Якщо управління спільним мікрофоном піде неправильно, то панельна дискусія не працюватиме так, як заплановано!</p>
<p>Правильне управління мʼютексами може бути неймовірно складним, ось чому так багато людей з ентузіазмом ставиться до каналів. Однак, завдяки системі типів Rust та правилам володіння, ви не можете помилитись при блокуванні та розблокуванні.</p>
<h4 id="api-mutext"><a class="header" href="#api-mutext">API <code>Mutex&lt;T&gt;</code></a></h4>
<p>Щоб продемонструвати як використовувати мʼютекс, давайте почнемо з використання мʼютексу в однопоточному контексті, як показано в Блоці коду 16-12:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<p><span class="caption">Блок коду 16-12: Експерименти з API <code>Mutex&lt;T&gt;</code> в однопоточному контексті для простоти</span></p>
<p>Як і з багатьма типами, ми створюємо <code>Mutex&lt;T&gt;</code>, використовуючи функцію <code>new</code>. Для доступу до даних всередині мʼютекса, ми використовуємо метод <code>lock</code> для отримання блокування. Цей виклик заблокує поточний потік, щоб він не міг виконувати жодну роботу до моменту поки не настане наша черга отримувати блокування.</p>
<p>Виклик <code>lock</code> завершиться неуспішно, якщо інший потік, котрий тримав блок, запанікував (panicked). В такому випадку, ніхто ніколи не зможе отримати блок, тому ми вирішили використати <code>unwrap</code> і змусити потік запанікувати, якщо ми опинимось в такій ситуації.</p>
<p>Після того, як ми отримали блокування, ми можемо розглядати повернуте значення, яке в даному випадку називається <code>num</code>, як мутабельне посилання на дані всередині. Система типів гарантує, що ми отримуємо блокування перед тим як використати значення в <code>m</code>. Тип <code>m</code> - <code>Mutex&lt;i32&gt;</code>, а не <code>i32</code>, тому ми <em>зобовʼязані</em> викликати <code>lock</code> щоб мати змогу використовувати значення <code>i32</code>. Ми не можемо забути про це; інакше система типів не дозволить нам отримати доступ до внутрішнього <code>i32</code>.</p>
<p>Як ви могли запідозрити, <code>Mutex&lt;T&gt;</code> є розумним вказівником. Точніше, виклик <code>lock</code> <em>повертає</em> розумний покажчик, котрий називається <code>MutexGuard</code>, загорнутий в <code>LockResult</code>, який ми обробили за допомогою виклика <code>unwrap</code>. <code>MutexGuard</code> - це розумний вказівник, що реалізує <code>Deref</code>, щоб вказувати на внутрішні дані; розумний вказівник такж має реалізацію <code>Drop</code>, котра вивільняє блок автоматично, коли <code>MutexGuard</code> виходить за межі області видимості, що відбувається в кінці внутрішньої області видимості. Як наслідок, ми не ризикуємо забути розблокувати блок і заблокувати використання мʼютексу іншими потоками, оскільки розблокування блоку відбувається автоматично.</p>
<p>Після видалення блоку, ми можемо вивести на екран значення мʼютексу і побачити, що ми змогли змінити внутрінє <code>i32</code> на 6.</p>
<h4 id="Спільне-використання-mutext-декількома-потоками"><a class="header" href="#Спільне-використання-mutext-декількома-потоками">Спільне використання <code>Mutex&lt;T&gt;</code> декількома потоками</a></h4>
<p>Тепер давайте спробуємо, використати значення з декількох різних потоків за допомогою <code>Mutex&lt;T&gt;</code>. Ми запустимо 10 потоків і кожен з них буде збільшувати значення лічильника на 1, таким чином лічильник змінюватиме значення від 0 до 10. Наступний приклад в Блоці коду 16-3 містить помилку компіляції і ми використаємо цю помилку щоб дізнатися більше про використання <code>Mutex&lt;T&gt;</code> і як Rust допомагає нам правильно його використовувати.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">Блок коду 16-13: Десять потоків по черзі інкрементують лічильник, захищений за допомогою <code>Mutex&lt;T&gt;</code></span></p>
<p>Ми створюємо змінну <code>counter</code>, що містить <code>i32</code> всередині <code>Mutex&lt;T&gt;</code>, так само як ми зробили в Блоці коду 16-12. Далі, ми створюємо 10 потоків, що ітеруються по діапазону (range) чисел. Ми використовуємо <code>thread::spawn</code> і передаємо кожному потоку одне й те саме замикання, котре переміщує лічильник всередину потоку, отримує блокування <code>Mutex&lt;T&gt;</code>, викликаючи метод <code>lock</code>, а потім додає 1 до значення всередині мʼютексу. Коли потік завершує виконання замикання, <code>num</code> виходить з області видимості, звільняє блок (lock), щоб інший потік міг його отримати.</p>
<p>В основному потоці, ми збираємо (collect) всі обробники (join handles). Після цього, так само як і в Блоці коду 16-2, ми викликаємо <code>join</code> на кожному обробнику, щоб впевнитись, що всі потоки завершуються. В цей момент основний потік отримає блокування і виведе на екран результат виконання цієї програми.</p>
<p>Ми натякнули, що цей приклад не скомпілюється. А тепер давайте дізнаємось чому!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:9:36
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop
10 |             let mut num = counter.lock().unwrap();
   |                           ------- use occurs due to use in closure

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` due to previous error
</code></pre>
<p>У повідомленні про помилку вказано, що значення <code>counter</code> вже було переміщено в попередній ітерації циклу. Rust говорить нам, що ми не можемо перемістити володіння блококуванням <code>counter</code> в декілька потоків. Виправимо помилку компіляції за допомогою множинного володіння, про яке ми говорили в Розділі 15.</p>
<h4 id="Множинне-володіння-і-декілька-потоків"><a class="header" href="#Множинне-володіння-і-декілька-потоків">Множинне володіння і декілька потоків</a></h4>
<p>В Розділі 15, ми надали значення декільком власникам, використовуючи розумний вказівник <code>Rc&lt;T&gt;</code> щоб створити значення з підрахунком посилань. Зробімо тут те саме і подивимось, що станеться. Ми загорнемо <code>Mutex&lt;T&gt;</code> в <code>Rc&lt;T&gt;</code> в Блоці коду 16-14 і склонуємо <code>Rc&lt;T&gt;</code> перед переміщенням володіння всередину потоку.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">Блок коду 16-14: Спроба використати <code>Rc&lt;T&gt;</code> щоб дозволити потокам володіти <code>Mutex&lt;T&gt;</code></span></p>
<p>Компілюємо знов і отримуємо... інші помилки! Компілятор нас багато чому вчить.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:22
    |
11  |           let handle = thread::spawn(move || {
    |  ______________________^^^^^^^^^^^^^_-
    | |                      |
    | |                      `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`
    |
    = help: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10]`
note: required by a bound in `spawn`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` due to previous error
</code></pre>
<p>Ох, це повідомлення про помилку доволі багатослівне! Ось важлива частина, на яку треба звернути увагу: <code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>. Компілятор також повідомляє нам чому: <code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>. Ми поговоримо про <code>Send</code> в наступній секції: це один з трейтів, що гарантують, що типи, котрі ми використовуємо в потоках, призначені для використання в конкурентних ситуаціях.</p>
<p>На жаль, <code>Rc&lt;T&gt;</code> небезпечно спільно використовувати в декількох потоках. Коли <code>Rc&lt;T&gt;</code> керує підрахунком посилань, він додає одиницю до лічильника за кожен виклик <code>clone</code> і віднімає одиницю від лічильника, кожного разу коли значення клону видаляється. Проте він не використовує жодних примітивів конкурентності, щоб переконатися, що зміни лічильника не будуть перервані іншим потоком. Це може призвести до неправильного підрахунку посилань - проблем, які дуже важко помітити й ідентифікувати, і можуть призвести до витоків памʼяті (memory leaks) або ж значення може бути видалене, до того як ми з ним закінчимо. Нам потрібен тип, ідентичний <code>Rc&lt;T&gt;</code>, але такий, що робить зміни до лічильника підрахунку посилань в потокобезпечний (thread-safe) спосіб.</p>
<h4 id="Атомарний-підрахунок-посилань-із-arct"><a class="header" href="#Атомарний-підрахунок-посилань-із-arct">Атомарний підрахунок посилань із <code>Arc&lt;T&gt;</code></a></h4>
<p>На щастя, <code>Arc&lt;T&gt;</code> <em>є</em> типом, схожим на <code>Rc&lt;T&gt;</code>, але який безпечно використовувати в конкурентних ситуаціях. Літера <em>a</em> означає <em>atomic</em>, тобто це тип <em>з атомарним підрахуванням посилань</em>. Атоміки - це додатковий вид примітивів конкурентності, які ми не будемо тут детально розглядати: див. документацію стандартної бібліотеки для <a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code></a><!-- ignore --> для більш докладної інформації. На даному етапі вам лише необхідно знати, що атоміки працюють як примітивні типи, але безпечні для спільного використання декількома потоками.</p>
<p>Ви можете запитати, чому всі примітивні типи не є атомариними і чому типи стандартної бібліотеки не використовують <code>Arc&lt;T&gt;</code> за замовчуванням. Причиною є те, що безпека потоків супроводжується зниженням швидкості виконання, а це штраф, який ви хочете заплатити лише тоді, коли це дійсно необхідно. Якщо ви просто виконуєте операції над значеннями в межах одного потоку, ваш код може працювати швидше, якщо йому не потрібно застосовувати гарантії, котрі надають атоміки.</p>
<p>Давайте повернемось до нашого прикладу: <code>Arc&lt;T&gt;</code> і <code>Rc&lt;T&gt;</code> мають однаковий API, тому ми просто виправляємо нашу програму змінюючи рядок з <code>use</code>, виклик <code>new</code>, а також виклик <code>clone</code>. Код в Блоці коду 16-15 нарешті скомпілюється й виконається:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p><span class="caption">Блок коду 16-15: Використання <code>Arc&lt;T&gt;</code> для обгортання <code>Mutex&lt;T&gt;</code> щоб мати можливіть поділитися володінням між кількома потоками</span></p>
<p>Цей код виводить на екран наступне:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>Ми зробили це! Ми рахували від 0 до 10, що може здатися не дуже вражаючим, але це навчило нас багато чому про <code>Mutex&lt;T&gt;</code> та безпеку потоків. Ви також можете використовувати структуру цієї програми для виконання більш складних операцій, ніж просто збільшення лічильника. Використовуючи цю стратегію, ви можете розділити обчислення на незалежні частини, потім розділити ці частини між потоками, а потім використати <code>Mutex&lt;T&gt;</code>, щоб кожен потік оновив кінцевий результат своєю частиною.</p>
<p>Завважте, що якщо ви виконуєте прості числові операції, є типи простіші за <code>Mutex&lt;T&gt;</code>, що визначені в модулі <a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code> стандартної бібліотеки</a><!-- ignore -->. Згадані типи забезпечують безпечний, конкурентний, атомарний доступ до примітивних типів. Для цього прикладу ми вирішили використовувати <code>Mutex&lt;T&gt;</code> із примітивним типом щоб ми могли зосередитися на тому, як працює <code>Mutex&lt;T&gt;</code>.</p>
<h3 id="Подібності-між-refcelltrct-і-mutextarct"><a class="header" href="#Подібності-між-refcelltrct-і-mutextarct">Подібності між <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> і <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<p>Ви могли помітити, що <code>counter</code> є імутабельним, але ми могли б отримати мутабельне посилання на значення в ньому; це означає, що <code>Mutex&lt;T&gt;</code> забезпечує внутрішню мутабельність (interior mutability), як це робить <code>Cell</code>. Таким же чином ми використовували <code>RefCell&lt;T&gt;</code> у Розділі 15, щоб дозволити нам змінювати контент всередині <code>Rc&lt;T&gt;</code>, ми використовуємо <code>Mutex&lt;T&gt;</code> щоб змінити вміст у <code>Arc&lt;T&gt;</code>.</p>
<p>Ще одна деталь, яку слід зазначити, полягає в тому, що Rust не може захистити вас від усіх видів логічних помилок під час використання <code>Mutex&lt;T&gt;</code>. Згадайте, що в Розділі 15 ми обговорювали, що використання <code>Rc&lt;T&gt;</code> супроводжується ризиком створення циклічних посилань, де два значення <code>Rc&lt;T&gt;</code> посилаються один на одного, спричиняючи витоки памʼяті (memory leaks). Подібним чином, використання <code>Mutex&lt;T&gt;</code> несе з собою ризик створення <em>взаємних блокувань</em>. Це відбувається, коли операція потребує блокування двох ресурсів і кожен з двох потоків отримав оне з блокувань, таким чином змушуючи їх вічно чекати один одного. Якщо вас цікавлять взаємні блокування, спробуйте створити Rust програму, яка має взаємне блокування; потім пошукайте стратегії вирішення проблеми взаємних блокувань для мʼютексів в будь-якій мові та спробуйте реалізувати їх на Rust. API документація стандартної бібліотеки для <code>Mutex&lt;T&gt;</code> і <code>MutexGuard</code> надає корисну інформацію.</p>
<p>Ми завершимо цей розділ розповіддю про трейти <code>Send</code> і <code>Sync</code> і те, як ми можемо їх використовувати разом з власними типами.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Розширювана-конкурентність-із-трейтами-sync-і-send"><a class="header" href="#Розширювана-конкурентність-із-трейтами-sync-і-send">Розширювана конкурентність із трейтами <code>Sync</code> і <code>Send</code></a></h2>
<p>Цікаво, що мова Rust має <em>дуже</em> небагато функціоналу для конкурентності. Майже весь функціонал конкурентності, про який ми будемо говорити в цьому розділі, є частиною стандартної бібліотеки, а не мови. Ваші опції для роботи з конкурентністю не обмежуються мовою чи стандартною бібліотекою; ви можете написати власний функціонал для конкурентності або використовувати ті, що вже були написані іншими.</p>
<p>Однак, дві концепції конкурентності вбудовані в мову: трейти <code>Sync</code> and <code>Send</code> із <code>std::marker</code>.</p>
<h3 id="Дозвіл-передавати-володіння-між-потоками-за-допомогою-send"><a class="header" href="#Дозвіл-передавати-володіння-між-потоками-за-допомогою-send">Дозвіл передавати володіння між потоками за допомогою <code>Send</code></a></h3>
<p>Маркерний трейт <code>Send</code> підказує нам, що володіння значенням типу, який реалізує <code>Send</code> можна передавати між потоками. Майже кожен тип в Rust реалізує <code>Send</code>, але є деякі винятки, включаючи <code>Rc&lt;T&gt;</code>: він не може реалізовувати <code>Send</code>, оскільки якщо ви клонували значення <code>Rc&lt;T&gt;</code> і спробували передати володіння клоном в інший потік, обидва потоки могли оновити лічильник підрахунку посилань одночасно. З цієї причини <code>Rc&lt;T&gt;</code> реалізовано для використання в одному потоці, коли ви не хочете жертвувати ефективністю виконання коду.</p>
<p>Тому, система типів Rust і межі трейтів (trait bounds) гарантують, що ви ніколи не зможете випадково небезпечно надіслати значення <code>Rc&lt;T&gt;</code> між потоками. Коли ми спробували зробити це в Блоці коду 16-14, то отримали помилку<code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>. Коли ми почали використовувати <code>Arc&lt;T&gt;</code>, який реалізує <code>Send</code>, код скомпілювався.</p>
<p>Будь-який тип, який повністю складається з типів, що реалізують <code>Send</code>, також автоматично позначається як <code>Send</code>. Майже всі примітивні типи реалізують <code>Send</code>, окрім сирих вказівників (raw pointers), які ми обговоримо в Розділі 19.</p>
<h3 id="Дозвіл-доступу-з-кількох-потоків-за-допомогою-sync"><a class="header" href="#Дозвіл-доступу-з-кількох-потоків-за-допомогою-sync">Дозвіл доступу з кількох потоків за допомогою <code>Sync</code></a></h3>
<p>Маркерний трейт <code>Sync</code> підказує нам, що на тип, котрий реалізує <code>Sync</code>, безпечно посилатись із декількох потоків. Іншими словами, будь-який тип <code>T</code> реалізує <code>Sync</code>, якщо <code>&amp;T</code> (імутабельне посилання на <code>T</code>) реалізує <code>Send</code>, тобто що посилання може бути безпечно передане в інший потік. Подібно до <code>Send</code>, примітивні типи реалізують <code>Sync</code>, а типи, що складаються з типів, котрі реалізують <code>Sync</code> також позначаються як <code>Sync</code>.</p>
<p>Розумний вказівник <code>Rc&lt;T&gt;</code> також не реалізує <code>Sync</code> з тих самих причин з яких не реалізує <code>Send</code>. Тип <code>RefCell&lt;T&gt;</code> (про який ми говорили в Розділі 15) і сімейство повʼязаних типів <code>Cell&lt;T&gt;</code> також не реалізують <code>Sync</code>. Реалізація перевірки запозичень (borrow checking), яку <code>RefCell&lt;T&gt;</code> виконує під час виконання програми, не є потокобезпечною. Розумний покажчик <code>Mutex&lt;T&gt;</code> реалізує <code>Sync</code> і може бути спільно використовуватись декількома потоками, як ви могли побачити в секції &quot;Спільне використання <code>Mutex&lt;T&gt;</code> декількома потоками&quot;<!-- ignore --> секції</p>
<h3 id="Реалізовувати-send-і-sync-вручну-небезпечно"><a class="header" href="#Реалізовувати-send-і-sync-вручну-небезпечно">Реалізовувати <code>Send</code> і <code>Sync</code> вручну небезпечно</a></h3>
<p>Оскільки типи, які складаються з типів, що реалізують <code>Send</code> і <code>Sync</code>, автоматично також реалізують <code>Send</code> і <code>Sync</code>, нам не потрібно реалізовувати ці трейти вручну. Як маркерні трейти, вони навіть не мають жодних методів, які потрібно реалізовувати. Вони просто корисні для забезпечення виконання інваріантів, пов’язаних із конкурентністю.</p>
<p>Ручне реалізація цих трейтів передбачає використання unsafe Rust коду. Ми поговоримо про використання unsafe Rust коду в Розділі 19; наразі ж, важливою інформацією є те, що для створення нових конкурентних типів, які не складаються з <code>Send</code> і <code>Sync</code>, потрібно ретельно продумати гарантії безпеки. <a href="../nomicon/index.html">“The Rustonomicon”</a> містить більше інформації про такі гарантії та способи їх забезбечення.</p>
<h2 id="Підсумок-15"><a class="header" href="#Підсумок-15">Підсумок</a></h2>
<p>Це не останній раз, коли ви читаєте про конкурентність у цій книзі: проєкт у Розділі 20 використовуватиме концепції цього розділу в більш реалістичній ситуації, ніж менші приклади, які тут розглядались.</p>
<p>Як вже згадувалося раніше, оскільки лише дуже маленька доля функціоналу для роботи з конкурентністю є частиною мови Rust, багато рішень реалізовано як крейти. Вони розвиваються швидше, ніж стандартна бібліотека, тому обов’язково шукайте в інтернеті поточні, найсучасніші крейти для використання при роботі з конкурентністю.</p>
<p>Стандартна бібліотека Rust надає канали для обміну повідомленнями і типи розумних вказівників, такі як <code>Mutex&lt;T&gt;</code> і <code>Arc&lt;T&gt;</code>, які безпечно використовувати в конкурентних контекстах. Система типів і borrow checker гарантують, що код, який використовує ці рішення, не призведе до гонитви даних або недійсних (невалідних) посилань. Як тільки ви змогли досягти того, що ваш код скомпілювався, ви можете бути впевнені, що він успішно працюватиме в декількох потоках без типових для інших мов помилок, котрі важко відстежити. Конкурентне програмування більше не є концепцією, якої варто боятися: безстрашно робіть свої програми конкурентними!</p>
<p>Далі ми поговоримо про ідіоматичні способи моделювання проблем і структурування рішень, по мірі того як ваші Rust програми стають більшими. Крім того, ми обговоримо, як ідіоми Rust пов’язані з ідіомами, що можуть бути вам знайомі з об’єктно-орієнтованого програмування.
ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Обєктно-орієнтовані-особливості-Расту"><a class="header" href="#Обєктно-орієнтовані-особливості-Расту">Об'єктно орієнтовані особливості Расту</a></h1>
<p>Об'єктно орієнтоване програмування(ООП) це варіант моделювання програм. Об'єкти, як концепт програмування, був вперше представлений мовою Simula в 1960-их. Ці об'єкти мали вплив на архітектуру ПЗ створену Аланом Каєм, в якій об'єкти відправляли повідомлення один одному. Щоб описати цю архітектуру, він придумав термін <em>об'єктно орієнтоване програмування</em> в 1967р. Багато різних визначень намагались описати, що таке ООП, і згідно з деякими, Rust є об'єктно орієнтованою мовою, а згідно з рештою -- ні. В цьому розділі ми розглянемо деякі аспекти, які, зазвичай, розглядаються як об'єктно орієнтовані та як вони застосовуються в Rust. Після чого, ми покажемо вам, як реалізувати шаблони об'єктно орієнтованого дизайну в Rust, а також обговоримо компроміси, які виникають через використання цього підходу замість сильних сторін Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Характеристики-обєктно-орієнтованого-програмування"><a class="header" href="#Характеристики-обєктно-орієнтованого-програмування">Характеристики об'єктно орієнтованого програмування</a></h2>
<p>Спільнота програмістів не дійшла згоди в питані того, що повинна містити мова, щоб вважатися об'єктно орієнтованою. На Rust вплинуло багато парадигм програмування, включно з ООП; наприклад, ми розглянули особливості, які прийшли з функціонального програмування, у Розділі 13. Беззаперечно, ООП мови містять у собі деякі спільні характеристики, а саме об'єкти, інкапсуляцію і наслідування. Тож розгляньмо, що кожна з цих характеристик значить і чи Rust її підтримує.</p>
<h3 id="Обєкти-котрі-місять-дані-та-поведінку"><a class="header" href="#Обєкти-котрі-місять-дані-та-поведінку">Об'єкти, котрі місять дані та поведінку</a></h3>
<p>Книга Еріха Гамми, Річарда Гелма, Ральфа Джонсона і Джона Вліссайдса <em>Design Patterns: Elements of Reusable Object-Oriented Software(Addison-Wesley Professional, 1994)</em>, яку в розмовній мові називають книгою <em>Банди Чотирьох</em>, є каталогом шаблонів об'єктно орієнтованого дизайну. В книзі ООП визначається наступним способом:</p>
<blockquote>
<p>Об'єктно орієнтовані програми складаються з об'єктів. <em>Об'єкт</em> формується як даними, так і процедурами, котрі працюють з цими даними. Цими процедурами є так звані <em>методи</em> або <em>операції</em>.</p>
</blockquote>
<p>Користуючись цим визначенням, Rust є об'єктно орієнтованим: структури та енуми містять дані, а блоки <code>impl</code> дозволяє реалізовувати методи для структур і енумів. Не зважаючи на те, що структури й енуми з методами не <em>називають</em> об'єктами, вони містять той самий функціонал, що й об'єкти згідно з визначенням Банди Чотирьох.</p>
<h3 id="Інкапсуляція-яка-приховує-деталі-реалізації"><a class="header" href="#Інкапсуляція-яка-приховує-деталі-реалізації">Інкапсуляція, яка приховує деталі реалізації</a></h3>
<p>Іншим аспектом, який часто асоціюють з ООП, є ідея <em>інкапсуляції</em>. Головною ідеєю цього аспекту є те, що деталі реалізації об'єкта не є доступними з коду, який цей об'єкт користує. З цього випливає, що єдиним способом взаємодії з об'єктом є його публічне API; код, який використовує об'єкт, не повинен мати можливості прямого доступу до даних об'єкту, його внутрішнього стану чи безпосередньої зміни поведінки об'єкта. Це дозволяє програмісту змінювати і рефакторити внутрішній код об'єкта без необхідності зміни коду, який використовує об'єкт.</p>
<p>Ми обговорили, як контролювати інкапсуляцію, у Розділі 7: ми можемо використовувати ключове слово <code>pub</code>, щоб визначити, які модулі, типи, функції і методи нашого коду повинні бути публічними. За замовчанням усе є приватним. Наприклад, ми можемо визначити структуру <code>AveragedCollection</code>, котра містить поле - вектор значень<code>i32</code>. Структура також може містити поле, яке зберігає середнє значення в векторі, що дозволяє не перераховувати середнє значення кожен раз, коли хтось його запросить. Іншими словами, <code>AveragedCollection</code> буде кешувати підраховане середнє значення для нас. В Блоці коду 17-1 міститься визначення структури <code>AveragedCollection</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
</code></pre>
<p><span class="caption">Блок коду 17-1: Структура `AveragedCollection', що зберігає список цілих чисел і середнє значення елементів у колекції</span></p>
<p>Структуру позначено <code>pub</code>, щоб інший код міг її використовувати, але поля структури залишаться приватними. Це важливо, оскільки ми хочемо гарантувати, що коли б ми не додали чи забрали якесь значення зі списку -- середнє значення теж оновилось. Ми досягаємо цього, реалізуючи для структури методи <code>add</code>, <code>remove</code> і <code>average</code> так, як показано в Блоці коду 17-2:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
</code></pre>
<p><span class="caption">Блок коду 17-2: Реалізації публічних методів <code>add</code>, <code>remove</code> і <code>average</code> для <code>AveragedCollection</code></span></p>
<p>Публічні методи <code>add</code>, <code>remove</code> і <code>average</code> є єдиним способом, щоб отримати доступ чи змінити дані в екземплярі <code>AveragedCollection</code>. Коли ми додаємо елемент до <code>list</code> за допомогою методу <code>add</code> чи видаляємо методом <code>remove</code>, реалізація всіх методів викличе приватний метод <code>update_average</code>, який обробить зміну середнього значення.</p>
<p>Ми залишаємо поля <code>list</code> і <code>average</code> приватними, щоб не було іншого способу отримати доступ до них напряму. В іншому випадку, поле <code>average</code> може виявитися не синхронізованим з полем <code>list</code>. Метод <code>average</code> повертає значення, яке міститься в полі <code>average</code>, дозволяючи користувачам структури прочитати середнє значення, але не модифікувати його.</p>
<p>Оскільки ми інкапсулювали деталі реалізації структури <code>AveragedCollection</code>, ми без проблем можемо змінити аспекти реалізації структури в майбутньому. Наприклад, ми можемо використати a <code>HashSet&lt;i32&gt;</code> замість <code>Vec&lt;i32&gt;</code> для поля <code>list</code>. Доки сигнатура публічних методів <code>add</code>, <code>remove</code>і <code>average</code> залишається незмінною, використання <code>AveragedCollection</code> не потрібно буде змінювати. Якби ми зробили <code>list</code> публічним, можливо б довелося змінювати спосіб взаємодії зі структурою: <code>HashSet&lt;i32&gt;</code> і <code>Vec&lt;i32&gt;</code> мають різні способи додавання і видалення елементів, тому користувачеві структури, скоріше за все, довелося б змінювати використання структури <code>list</code>.</p>
<p>Якщо інкапсуляція є обов'язковим аспектом для об'єктно орієнтованої мови, то Rust можна вважати такою. Наявність чи відсутність ключового слова <code>pub</code> дозволяє інкапсулювати деталі реалізації.</p>
<h3 id="Наслідування-як-система-типів-а-також-як-система-спільного-використання-коду"><a class="header" href="#Наслідування-як-система-типів-а-також-як-система-спільного-використання-коду">Наслідування як система типів, а також як система спільного використання коду</a></h3>
<p><em>Наслідування</em> — це механізм, за допомогою якого об’єкт може успадковувати елементи з визначення іншого об’єкта, таким чином отримуючи дані та поведінку батьківського об’єкта без потреби визначати їх знову.</p>
<p>Якщо мова повинна мати наслідування, щоб бути об’єктно орієнтованою, то Rust не є нею. Тут нема способу визначити структуру, яка успадковує поля та реалізації методів батьківської структури, без використання макросу.</p>
<p>Однак, якщо ви звикли мати успадкування у своєму наборі інструментів програмування, ви можете використовувати інші рішення в Rust, залежно від того, чому ви спочатку звернулися до успадкування.</p>
<p>Є дві основні причини, щоб використовувати наслідування. Перша з них, це щоб перевикористати код: ви можете реалізувати поведінку для якогось одного типа, а наслідування дозволить вам перевикористати реалізацію для іншого типу. Ви можете використати обмежену версію цього підходу в Rust, з допомогою усталеної реалізації трейту, яку ви бачили в роздруківці 10-14, коли ми додали усталену реалізацію методу <code>summarize</code> для трейту <code>Summary</code>. Кожний тип, який реалізовує трейт <code>Summary</code> матиме доступним метод <code>summarize</code> без повторного написання коду. Це є схожим до батьківського класу, який містить реалізацію методу, і дочірнього класу, який успадкувує реалізацію цього ж методу. Також у випадках реалізації трейту <code>Summary</code>, ми можемо перевизначити усталену реалізацію методу <code>summarize</code> власною, що схоже до перевизначення батьківського методу в дочірньому класі.</p>
<p>Інша причина використання наслідування пов’язана з системою типів: дозволяти використовувати дочірній тип в тих місцях, де очікується батьківський тип. Це також називається <em>поліморфізмом</em>, що означає, що ви можете без проблем замінити один об'єкт на інший, якщо той задовольняє певні вимоги.</p>
<blockquote>
<h3 id="Поліморфізм"><a class="header" href="#Поліморфізм">Поліморфізм</a></h3>
<p>Для багатьох людей поліморфізм є синонімом до наслідування. Але це більш загальний концепт, що описує код, який працює з декількома типами. При наслідуванні ці типи повинні бути підкласами.</p>
<p>На заміну цьому, Rust використовує абстрактний тип для абстрагування над різними можливими типами та трейтами, щоб накласти обмеження на те, що мають надавати ці типи. Це іноді називають <em>обмеженим параметричним поліморфізмом</em>.</p>
</blockquote>
<p>Останнім часом програмісти почали значно рідше використовувати наслідування, оскільки наявний великий ризик перевикористання більше коду ніж необхідно. Підкласи не завжди повинні мати всі ті ж самі характеристики, що і їхні батьки, однак ми завжди робимо так з наслідуванням. Це може зробити архітектуру програм менш гнучкою. Також це створює можливість викликати методи в підкласах попри те, що це не має сенсу чи викликає помилки, бо цей метод не застосовний для цього підкласу. На додачу до цього, деякі мови забороняють множинне наслідування (тобто підклас може наслідуватися лише під одного класу), що ще сильніше зменшує гнучкість програм.</p>
<p>З цих причин Rust використовує інший підхід: використання трейтів замість успадкування. Подивімось, як трейти забезпечують поліморфізм у Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Використання-трейт-обєктів-які-допускають-значення-різних-типів"><a class="header" href="#Використання-трейт-обєктів-які-допускають-значення-різних-типів">Використання трейт-об'єктів, які допускають значення різних типів</a></h2>
<p>У розділі 8 ми казали, що одним з обмежень векторів є те, що вони можуть зберігати елементи тільки одного типу. Ми обійшли цю проблему в Роздруку 8-9, де ми визначили енум <code>SpreadsheetCell</code> який мав варіанти для зберігання цілих чисел, чисел з рухомою комою й тексту. Це означало, що ми мали змогу зберігати різні типи даних в кожній комірці та все одно мати вектор, який представляє рядок комірок. Це дуже гарне рішення коли наші взаємозамінні елементи є типами з фіксованим набором, відомим на етапі компіляції.</p>
<p>Проте іноді ми хочемо, щоб користувач нашої бібліотеки зміг розширити набір типів, які є допустимими в конкретній ситуації. Щоб показати, як ми можемо досягти цього, ми створимо приклад інструменту з графічним інтерфейсом користувача (GUI), який ітерує список елементів, викликаючи метод <code>draw</code> на кожному з них, щоб намалювати його на екрані — це поширена техніка для GUI інструментів. Ми створимо бібліотечний крейт <code>gui</code>, який містить структуру бібліотеки GUI. Цей крейт може містити деякі готові до використання типи, наприклад тип <code>Button</code> чи <code>TextField</code>. Крім того, користувачі крейту <code>gui</code> можуть захотіти створити свої власні типи, які можуть бути намальовані: наприклад, один програміст може додати тип <code>Image</code>, а інший - <code>SelectBox</code>.</p>
<p>Ми не будемо реалізовувати повноцінну GUI бібліотеку для цього прикладу, але покажемо як її частини будуть поєднуватися. Коли ми пишемо бібліотеку, ми не можемо знати та визначити всі типи, які можуть захотіти створити інші програмісти. Але ми знаємо що <code>gui</code> повинен відстежувати багато значень різного типу та викликати метод <code>draw</code> кожного з цих по-різному типізованому значень. Крейт не повинен знати, що станеться, коли ми викличемо метод <code>draw</code>, просто у значення буде доступний для виклику такий метод.</p>
<p>Для того, щоб зробити це на мові, в якій є наслідування, ми можемо визначити клас під назвою <code>Component</code>, який має метод <code>draw</code>. Інші класи, такі як <code>Button</code>, <code>Image</code>, та <code>SelectBox</code>, можуть успадкуватися від <code>Component</code> й таким чином успадкувати метод <code>draw</code>. Кожен з них може перевизначити реалізацію методу <code>draw</code>, щоб описати власну поведінку, але фреймворк може розглядати всі типи ніби вони є екземпляром <code>Component</code> та міг би викликати їх метод <code>draw</code>. Але, оскільки Rust не має механізму успадкування, нам потрібен інший спосіб структурувати <code>gui</code> бібліотеку, щоб дозволити користувачам розширювати її новими типами.</p>
<h3 id="Визначення-трейту-для-загальної-поведінки"><a class="header" href="#Визначення-трейту-для-загальної-поведінки">Визначення трейту для загальної поведінки</a></h3>
<p>Для реалізації поведінки, яку ми хочемо мати в <code>gui</code>, визначимо трейт під назвою <code>Draw</code>, який буде містити один метод <code>draw</code>. Тоді ми можемо визначити вектор, який приймає <em>трейт-об'єкт</em>. Трейт-об'єкт вказує як на екземпляр типу, що реалізує вказаний нами трейт, так і на внутрішню таблицю, що використовується для пошуку методів трейту вказаного типу під час виконання. Ми створюємо трейт-об'єкт в такому порядку: використовуємо якийсь вид вказівнику, наприклад посилання <code>&amp;</code> або розумний вказівник <code>Box&lt;T&gt;</code>, потім ключове слово <code>dyn</code> й відповідний трейт. (Ми будемо говорити чому трейт-об'єкти повинні використовувати вказівник у Розділі 19 в секції <a href="ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">“Dynamically Sized Types and the <code>Sized</code> Trait.”</a><!-- ignore -->) Ми можемо використовувати трейт-об'єкт замість узагальненого або конкретного типу. Де б ми не використовували трейт-об'єкт, система типів Rust забезпечить, що під час компіляції будь-яке значення використане у цьому контексті буде реалізовувати трейт трейт-об'єкту. Отже, ми не повинні знати всі можливі типи під час компіляції.</p>
<p>Ми нагадували, що в Rust ми не називаємо структури та енуми &quot;об'єктами&quot;, щоб розрізняти їх з об'єктами в інших мовах програмування. У структурі або енумі, дані в полях структури та поведінка в блоку <code>impl</code> розділені, тоді як в інших мовах вони об'єднанні в один концепт, який часто називають об'єкт. Однак, трейт-об'єкти <em>є</em> більше схожими на об'єкти в інших мовах, в тому сенсі що вони об'єднують дані та поведінку. Але трейт-об'єкти відрізняються від традиційних об'єктів у том, що ми не можемо додати дані до трейт-об'єкту. Трейт-об'єкти загалом не настільки корисні як об'єкти в інших мовах програмування: їх конкретна ціль - забезпечити абстракцію через загальну поведінку.</p>
<p>Блок коду 17-3 показує, як визначити трейт під назвою <code>Draw</code> з одним методом <code>draw</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Draw {
    fn draw(&amp;self);
}
</code></pre>
<p><span class="caption">Блок коду 17-3: Визначення трейту <code>Draw</code></span></p>
<p>Цей синтаксис має бути знайомим після наших дискусій про те, як визначати трейти в розділі 10. Далі йде новий синтаксис: у Роздруку 17-4 визначена структура під назвою <code>Screen</code>, яка містить вектор з ім'ям <code>components</code>. Цей вектор має тип <code>Box&lt;dyn Draw&gt;</code>, який і є трейт-об'єктом; це позначення будь-якого типу всередині <code>Box</code>, який реалізує трейт <code>Draw</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
</code></pre>
<p><span class="caption">Блок коду 17-4: Визначення структури <code>Screen</code> з полем <code>components</code>, яке є вектором трейт-об'єктів, що реалізують трейт <code>Draw</code></span></p>
<p>У структурі <code>Screen</code> ми визначено метод під назвою <code>run</code>, який буде викликати метод <code>draw</code> кожного елементу вектора <code>components</code>, як показано у Блоці коду 17-5:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
</code></pre>
<p><span class="caption">Блок коду 17-5: Метод <code>run</code> в структурі <code>Screen</code>, який викликає метод <code>draw</code> кожного компоненту</span></p>
<p>Це працює інакше ніж визначення структури, яка використовує параметр узагальненого типу з обмеженнями трейтів. Узагальнений параметр типу може бути замінений тільки одним конкретним типом, тоді як трейт-об'єкти дозволяють декільком конкретним типам бути на його місці під час виконання. Наприклад, визначимо структуру <code>Screen</code> використовуючи узагальнені типи та обмеження трейту в Блоці коду 17-6:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
</code></pre>
<p><span class="caption">Блок коду 17-6: Альтернативна реалізація структури <code>Screen</code> та її методу <code>run</code> за допомогою узагальнених типів та обмежень трейту</span></p>
<p>Це обмежує екземпляр <code>Screen</code> до одного з двох можливих варіантів: наповнений лише компонентами типу <code>Button</code>, або лише компонентами типу <code>TextField</code>. Якщо у вас коли-небудь будуть тільки однорідні колекції, використання узагальнених типів та обмежень трейту краще, оскільки визначення будуть мономорфізованими під час компіляції для використання з конкретними типами.</p>
<p>З іншого боку, за допомогою методу, який використовує трейт-об'єкт, один екземпляр <code>Screen</code> може містити <code>Vec&lt;T&gt;</code>, який містить <code>Box&lt;Button&gt;</code>, так само як і <code>Box&lt;TextField&gt;</code>. Нумо подивімось як це працює, а потім поговоримо про вплив на швидкодію під час виконання.</p>
<h3 id="Реалізація-трейту"><a class="header" href="#Реалізація-трейту">Реалізація трейту</a></h3>
<p>Тепер ми додамо деякі типи, які реалізуються трейт <code>Draw</code>. Запровадимо тип <code>Button</code>. Знову ж таки, фактична реалізація бібліотеки GUI виходить за межі цієї книги, тому тіло методу <code>draw</code> не буде мати ніякої корисної реалізації. Щоб уявити, як може виглядати така реалізація, структура <code>Button</code> може мати поля для <code>width</code>, <code>height</code>, та <code>label</code>, як показано в Роздруку 17-7:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}
</code></pre>
<p><span class="caption">Блок коду 17-7: Структура <code>Button</code>, яка реалізує трейт <code>Draw</code></span></p>
<p>Поля <code>width</code>, <code>height</code>, та <code>label</code> структури <code>Button</code> будуть відрізнятися від полів інших компонентів; наприклад, тип <code>TextField</code> міг би мати такі самі поля плюс поле <code>placeholder</code>. Кожен тип, який ми хочемо намалювати на екрані, буде реалізовувати трейт <code>Draw</code>, але буде мати інший код методу <code>draw</code> для визначення того, як саме малювати конкретний тип, наприклад <code>Button</code> в цьому прикладі (без фактичного коду GUI, який виходить за межі цього розділу). Наприклад, тип <code>Button</code> може мати додаткові блоки <code>impl</code>, що містять методи, які визначають що станеться, коли користувач натисне на кнопку. Такі методи не застосовуватимуться до таких типів, як <code>TextField</code>.</p>
<p>Якщо користувач нашої бібліотеки вирішить реалізувати структуру <code>SelectBox</code>, яка має <code>width</code>, <code>height</code>, та <code>options</code> поля, він реалізує також і трейт <code>Draw</code> для структури <code>SelectBox</code>, як показано в Роздруку 17-8:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p><span class="caption">Блок коду 17-8: Інший крейт використовує <code>gui</code> та реалізує трейт <code>Draw</code> для структури <code>SelectBox</code></span></p>
<p>Тепер користувач нашої бібліотеки може написати свою <code>main</code> функцію, щоб створити екземпляр <code>Screen</code>. До екземпляра <code>Screen</code>, він може додати <code>SelectBox</code> та <code>Button</code>, розмістивши кожен з них у <code>Box&lt;T&gt;</code>, щоб він став трейт-об'єктом. Потім він може викликати метод <code>run</code> в екземпляра <code>Screen</code>, який викличе метод <code>draw</code> для кожного компонента. Роздрук 17-9 показує цю реалізацію:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // code to actually draw a select box
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Блок коду 17-9: Використання трейт-об'єктів для зберігання значень різних типів, які реалізують той самий трейт</span></p>
<p>Коли ми писали бібліотеку, ми не знали, що хтось може додати тип <code>SelectBox</code>, але наша реалізація <code>Screen</code> мала змогу працювати з новим типом та малювати його, тому що <code>SelectBox</code> реалізує трейт <code>Draw</code>, що означає, що він реалізує метод <code>draw</code>.</p>
<p>Ця концепція, яка стосується тільки повідомлень на які значення відповідає, на відміну від конкретного типу в значення, аналогічна концепції <em>duck typing</em> (качкової типізації) у динамічно типізованих мовах: якщо хтось ходить як качка та крякає як качка, то він - качка! У реалізації методу <code>run</code> структури <code>Screen</code> в Роздруку 17-5, <code>run</code> не повинен знати конкретний тип кожного компонента. Він не перевіряє чи є компонент екземпляром <code>Button</code> чи <code>SelectBox</code>, він просто викликає метод <code>draw</code> компоненту. Вказавши <code>Box&lt;dyn Draw&gt;</code> як тип значень у вектору <code>components</code>, ми визначили <code>Screen</code> для значень у яких ми можемо викликати метод <code>draw</code>.</p>
<p>Перевага використання трейт-об'єктів і системи типів Rust для написання коду подібного до коду з використанням качкової типізації полягає в тому, що нам ніколи не потрібно перевіряти, чи реалізує значення певний метод під час виконання або турбуватися про отримання помилок якщо значення не реалізує метод. Rust не буде компілювати наш код, якщо значення не реалізують трейт потрібного трейт-об'єкту.</p>
<p>Наприклад, Блок коду 17-10 показує, що станеться, якщо ми спробуємо створити <code>Screen</code> з <code>String</code> як компонент:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from(&quot;Hi&quot;))],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Роздрук 17-10: Спроба використати тип, який не реалізує трейт трейт-об'єкту</span></p>
<p>Ми отримаємо помилку, тому що <code>String</code> не реалізує трейт <code>Draw</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from(&quot;Hi&quot;))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = note: required for the cast to the object type `dyn Draw`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` due to previous error
</code></pre>
<p>Ця помилка дає зрозуміти, що або ми передаємо в компонент <code>Screen</code> щось, що ми не збиралися передавати, і тоді ми повинні передати інший тип, або ми повинні реалізувати трейт <code>Draw</code> у типу <code>String</code>, щоб <code>Screen</code> міг викликати <code>draw</code> у нього.</p>
<h3 id="Трейт-обєкти-виконують-динамічну-диспетчеризацію-звязування"><a class="header" href="#Трейт-обєкти-виконують-динамічну-диспетчеризацію-звязування">Трейт-об'єкти виконують динамічну диспетчеризацію (зв'язування)</a></h3>
<p>Нагадаємо, у секції <a href="">“Швидкодія коду з узагальненими типами”</a><!-- ignore --> розділу 10 обговорюється процес мономорфізації, який виконується компілятором, коли ми використовуємо обмеження трейтів для узагальнених типів: компілятор генерує конкретні типи, які ми використовуємо замість параметра узагальненого типу. Код, отриманий в результаті мономорфізації, виконує <em>статичну диспетчеризацію</em>, коли компілятор знає який метод ви викликаєте під час компіляції. Це протилежний підхід до <em>динамічної диспетчеризації</em>, коли компілятор не може сказати під час компіляції, який метод ви викликаєте. У випадках динамічної диспетчеризації компілятор генерує код, який під час виконання визначає, який метод необхідно викликати.</p>
<p>Коли ми використовуємо трейт-об'єкти, Rust має використовувати динамічну диспетчеризацію. Компілятор не знає всі типи, які можуть бути використані з кодом, який використовує трейт-об'єкти, тому він не знає, який метод реалізований для якого типу при виклику. Замість цього, під час виконання, Rust використовує вказівники всередині трейт-об'єкту, щоб дізнатися який метод викликати. Такий пошук провокує додаткові витрати під час виконання, які не потребуються під час статичної диспетчеризації. Динамічна диспетчеризація також не дозволяє компілятору обрати вбудовування коду метода, що робить неможливим деякі оптимізації. Однак, ми отримали додаткову гнучкість у коді, який ми написали у Роздруку 17-5, і змогли підтримати у Роздруку 17-9, так що це - компроміс для розгляду.
ch10-01-syntax.html#performance-of-code-using-generics</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Реалізація-патернів-обєктноорієнтованого-програмування"><a class="header" href="#Реалізація-патернів-обєктноорієнтованого-програмування">Реалізація патернів об'єктноорієнтованого програмування</a></h2>
<p>Патерн <em>&quot;Стан&quot;</em> - це об'єктноорієнтований шаблон проєктування. Сенс патерну полягає в тому, що ми визначаємо набір станів, в яких може знаходитися значення. Стани представлені набором <em>об'єктів стану</em>, а поведінка значення змінюється в залежності від його стану. Розглянемо на прикладі структури допису в блозі, що має поле для збереження її стану, яке буде об'єктом стану з набору &quot;чернетка&quot; (draft), &quot;очікування перевірки&quot; (review) або &quot;опубліковано&quot; (published).</p>
<p>Об'єкти стану мають спільну функціональність: звісно в Rust, ми використовуємо структури й трейти, а не об'єкти та наслідування. Кожний об'єкт стану відповідає за свою поведінку й сам визначає, коли він повинен перейти в інший стан. Значення, яке зберігає об'єкт стану, нічого не знає про різницю в поведінці станів або про те, коли один стан повинен перейти в інший.</p>
<p>Перевага використання патерну &quot;Стан&quot; полягає в тому, що при зміненні бізнес-вимог до програми нам не потрібно буде змінювати код значення, що зберігає стан, або код, який використовує це значення. Нам потрібно буде оновити код всередині одного з об’єктів стану, щоб змінити його правила чи можливо додати більше об'єктів стану.</p>
<p>Спочатку, ми реалізуємо патерн &quot;Стан&quot; більш традиційним об'єктноорієнтованим шляхом, а потім використаємо більш ідіоматичний підхід для Rust. Розглянемо поетапну реалізацію робочого процесу публікації в блозі з використанням патерну &quot;Стан&quot;.</p>
<p>Остаточна функціональність буде виглядати наступним чином:</p>
<ol>
<li>Створення допису в блозі починається з пустої чернетки.</li>
<li>Коли чернетка готова, робиться запит на схвалення допису.</li>
<li>Коли допис буде схвалено, він опублікується.</li>
<li>Тільки опубліковані дописи блогу повертають контент для друку, тому несхвалені дописи не можуть випадково бути опубліковані.</li>
</ol>
<p>Будь-які інші зміни, зроблені в дописі, не повинні мати ефекту. Наприклад, якщо ми спробуємо затвердити чернетку допису в блозі перед тим, як ми подали запит на затвердження, допис має залишатися неопублікованою чернеткою.</p>
<p>Лістинг 17-11 показує цей процес у вигляді коду: це приклад використання API (прикладного програмного інтерфейсу), який ми будемо впроваджувати у бібліотечному крейті під назвою <code>blog</code>. Цей приклад не скомпілюється, тому що ми ще не встигли реалізувати крейт <code>blog</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Блок коду 17-11: Код, який демонструє поведінку, яку ми хочемо, щоб мав крейт <code>blog</code></span></p>
<p>Ми хочемо дозволити користувачеві створити новий допис у блозі за допомогою <code>Post::new</code>. Ми хочемо дозволити додавати текст у допис блогу. Якщо ми спробуємо отримати зміст допису до схвалення публікації, ми не повинні отримувати ніякого тексту, оскільки допис все ще є чернеткою. Ми додали <code>assert_eq!</code> в коді для демонстрації цілей. Ідеальним модульним (unit) тестом для цього було б твердження, що чернетка допису повертає порожній рядок з методу <code>content</code>, але ми не будемо писати тести для цього прикладу.</p>
<p>Далі ми хочемо дозволити запит на схвалення допису, і також щоб <code>content</code> повертав порожню стрічку під час очікування схвалення. Коли допис пройде перевірку, він повинен бути опублікований, тобто виклик методу <code>content</code> буде повертати текст допису.</p>
<p>Зверніть увагу, що єдиний тип з крейту, з яким ми взаємодіємо - це тип <code>Post</code>. Цей тип буде використовувати патерн &quot;Стан&quot; і буде містить значення, яке буде одним з трьох об'єктів станів, які представляють різні стани, в яких може знаходитися допис: &quot;чернетка&quot;, &quot;очікування перевірки&quot;, або &quot;опубліковано&quot;. Керування переходом з одного стану в інший буде здійснюватися внутрішньою логікою типа <code>Post</code>. Стани будуть перемикатися в результаті реакції на виклик методів екземпляру <code>Post</code> користувачами нашої бібліотеки, але користувачі не повинні керувати зміною станів напряму. Крім того, користувачі не повинні мати можливість помилитися зі станами, наприклад, опублікувати повідомлення до його перевірки.</p>
<h3 id="Визначення-post-та-створення-нового-екземпляру-в-стані-чернетки"><a class="header" href="#Визначення-post-та-створення-нового-екземпляру-в-стані-чернетки">Визначення <code>Post</code> та створення нового екземпляру в стані чернетки</a></h3>
<p>Нумо почнімо реалізовувати бібліотеку! Ми знаємо, що нам потрібна публічна структура <code>Post</code>, яка зберігає деякий вміст, тому ми почнемо з визначення структури та пов'язаною з нею публічною функцією <code>new</code> для створення екземпляра <code>Post</code>, як показано в Блоці коду 17-12. Ми також зробимо приватний трейт <code>State</code>, який буде визначати поведінку, що повинні будуть мати всі об'єкти станів структури <code>Post</code>.</p>
<p>Далі <code>Post</code> буде містити трейт-об'єкт <code>Box&lt;dyn State&gt;</code> всередині <code>Option&lt;T&gt;</code> в приватному полі <code>state</code> для зберігання об'єкту стану. Трохи пізніше ви зрозумієте, навіщо потрібно використання <code>Option&lt;T&gt;</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
</code></pre>
<p><span class="caption">Блок коду 17-12. Визначення структури <code>Post</code> та функції <code>new</code>, яка створює новий екземпляр <code>Post</code>, трейту <code>State</code> і структури <code>Draft</code></span></p>
<p>Трейт <code>State</code> визначає поведінку, яку спільно використовують різні стани допису. Всі об'єкти станів (<code>Draft</code> - чернетка, <code>PendingReview</code> - очікування перевірки, <code>Published</code> - опубліковано) будуть реалізовувати трейт <code>State</code>. Зараз у цього трейту немає ніяких методів, і ми почнемо з визначення <code>Draft</code>, тому що, що це перший стан, з якого, як ми хочемо, публікація буде починати свій шлях.</p>
<p>Коли ми створюємо новий екземпляр <code>Post</code>, ми встановлюємо його поле <code>state</code> в значення <code>Some</code>, що містить <code>Box</code>. Цей <code>Box</code> вказує на новий екземпляр структури <code>Draft</code>. Це гарантує, щоразу, коли ми створюємо новий екземпляр <code>Post</code>, він з'явиться як чернетка. Оскільки поле <code>state</code> в структурі <code>Post</code> є приватним, нема ніякого способу створити <code>Post</code> в якомусь іншому стані! У функції <code>Post::new</code> ми ініціалізуємо поле <code>content</code> новим пустим рядком типу <code>String</code>.</p>
<h3 id="Зберігання-тексту-вмісту-допису"><a class="header" href="#Зберігання-тексту-вмісту-допису">Зберігання тексту вмісту допису</a></h3>
<p>У Блоці коду 17-11 показано, що ми хочемо мати можливість викликати метод <code>add_text</code> і передати йому <code>&amp;str</code>, яке додається до текстового вмісту допису блогу. Ми реалізуємо цю можливість як метод, а не робимо поле <code>content</code> публічним, використовуючи <code>pub</code>, щоб пізніше ми могли реалізувати метод, який буде керувати тим, як дані поля <code>content</code> будуть зчитуватися. Метод <code>add_text</code> досить простий, тому додаймо його реалізацію в блок <code>impl Post</code> у Блоці коду 17-13:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}
</span></code></pre>
<p><span class="caption">Блок коду 17-13. Реалізація методу <code>add_text</code> для додавання тексту до <code>content</code> (вмісту) допису</span></p>
<p>Метод <code>add_text</code> приймає змінюване посилання на <code>self</code>, тому що ми змінюємо екземпляр <code>Post</code>, для якого викликаємо <code>add_text</code>. Потім ми викликаємо <code>push_str</code> для <code>String</code> у поля <code>content</code> і передаємо <code>text</code> аргументом для додавання до збереженого <code>content</code>. Ця поведінка не залежить від стану, в якому знаходяться допис, таким чином він не є частиною патерну &quot;Стан&quot;. Метод <code>add_text</code> взагалі не взаємодіє з полем <code>state</code>, але це частина поведінки, яку ми хочемо підтримувати.</p>
<h3 id="Переконаємося-що-вміст-чернетки-порожній"><a class="header" href="#Переконаємося-що-вміст-чернетки-порожній">Переконаємося, що вміст чернетки порожній</a></h3>
<p>Навіть після того, як ми викликали метод <code>add_text</code> і додали деякий контент в наш допис, ми хочемо, щоб метод <code>content</code> повертав порожній стрічковий слайс, тому, що допис все ще знаходиться в стані чернетки, як це показано в рядку 7 Блока коду 17-11. Поки що реалізуймо метод <code>content</code> найпростішим способом, який буде задовольняти цій вимозі: будемо завжди повертати порожній стрічковий слайс. Ми змінимо код пізніше, як тільки реалізуємо можливість змінити стан допису, щоб вона могла бути опублікована. Поки що дописи можуть знаходитися тільки в стані чернетки, тому вміст допису завжди повинен бути пустим. Лістинг 17-14 показує цю реалізацію-заглушку:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}
</span></code></pre>
<p><span class="caption">Блок коду 17-14: Додавання реалізації-заглушки для методу <code>content</code> в <code>Post</code>, яка завжди повертає порожній стрічковий слайс</span></p>
<p>З доданим методом <code>content</code> усе в Блоці коду 17-11 працює, як треба, аж до рядка 7.</p>
<h3 id="Запит-на-перевірку-допису-змінює-його-стан"><a class="header" href="#Запит-на-перевірку-допису-змінює-його-стан">Запит на перевірку допису змінює його стан</a></h3>
<p>Далі нам потрібно додати функціональність для запиту на перевірку допису, який повинен змінити її стан з <code>Draft</code> на <code>PendingReview</code>. Лістинг 17-15 показує такий код:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
</code></pre>
<p><span class="caption">Блок коду 17-15: Реалізація методу <code>request_review</code> в структурі <code>Post</code> і трейті <code>State</code></span></p>
<p>Ми додаємо в <code>Post</code> публічний метод з іменем <code>request_review</code>, який буде приймати змінюване посилання на <code>self</code>. Далі ми викликаємо внутрішній метод <code>request_review</code> для поточного стану <code>Post</code>, і цей другий метод <code>request_review</code> поглинає поточний стан та повертає новий стан.</p>
<p>Ми додаємо метод <code>request_review</code> в трейт <code>State</code>; всі типи, які реалізують цей трейт, тепер повинні будуть реалізувати метод <code>request_review</code>. Зверніть увагу, що замість <code>self</code>, <code>&amp;self</code>, або <code>&amp;mut self</code> як першого параметра метода в нас вказаний <code>self: Box&lt;Self&gt;</code>. Цей синтаксис означає, що метод дійсний тільки при його виклику з обгорткою <code>Box</code>, яка містить наш тип. Цей синтаксис стає власником <code>Box&lt;Self&gt;</code>, і робить старий стан недійсним, тому значення стану <code>Post</code> може бути перетворення в новий стан.</p>
<p>Щоб поглинути старий стан, метод <code>request_review</code> повинен стати власником значення стану. Це місце, де приходить на допомогу тип <code>Option</code> поля <code>state</code> допису <code>Post</code>: ми викликаємо метод <code>take</code>, щоб забрати значення <code>Some</code> з поля <code>state</code> і залишити замість нього значення <code>None</code>, тому що Rust не дозволяє мати неініціалізовані поля в структурах. Це дозволяє переміщувати значення <code>state</code> з <code>Post</code>, а не запозичувати його. Потім ми встановимо нове значення <code>state</code> як результат цієї операції.</p>
<p>Нам потрібно тимчасово встановити <code>state</code> в <code>None</code> замість того, щоб встановити його напряму за допомогою коду на кшталт <code>self.state = self.state.request_review();</code> щоб отримати власність над значенням <code>state</code>. Це гарантує, що <code>Post</code> не зможе використовувати старе значення <code>state</code> після того, як ми перетворили його в новий стан.</p>
<p>Метод <code>request_review</code> в <code>Draft</code> повинен повернути екземпляр нової структури <code>PendingReview</code> обгорнутої в <code>Box</code>, яка є станом, коли допис очікує на перевірку. Структура <code>PendingReview</code> також реалізує метод <code>request_review</code>, але не виконує ніяких трансформацій. Вона повертає сама себе, тому що, коли ми робимо запит на перевірку допису, який вже знаходиться в стані <code>PendingReview</code>, вона все одно повинна продовжувати залишатися в стані <code>PendingReview</code>.</p>
<p>Тепер ми починаємо бачити переваги патерну &quot;Стан&quot;: метод <code>request_review</code> для <code>Post</code> однаковий, він не залежить від значення <code>state</code>. Кожен стан сам несе відповідальність за власну поведінку.</p>
<p>Залишимо метод <code>content</code> в <code>Post</code> без змін, тобто який повертає порожній стрічковий слайс. Тепер ми можемо мати <code>Post</code> як у стані <code>PendingReview</code>, так і в стані <code>Draft</code>, але ми хочемо отримати таку саму поведінку в стані <code>PendingReview</code>. Лістинг 17-11 тепер працює до рядка 10!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h3 id="Додавання-методу-approve-для-зміни-поведінки-методу-content"><a class="header" href="#Додавання-методу-approve-для-зміни-поведінки-методу-content">Додавання методу <code>approve</code> для зміни поведінки методу <code>content</code></a></h3>
<p>Метод <code>approve</code> (&quot;схвалити&quot;) буде аналогічним методу <code>request_review</code>: він буде встановлювати в <code>state</code> значення, яке повинен мати допис при його схваленні, як показано в Блоці коду 17-16:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
</code></pre>
<p><span class="caption">Блок коду 17-16: Реалізація методу <code>approve</code> для типу <code>Post</code> і трейту <code>State</code></span></p>
<p>Ми додаємо метод <code>approve</code> в трейт <code>State</code> та додаємо нову структуру, яка реалізує трейт <code>State</code> для стану <code>Published</code>.</p>
<p>Подібно до того, як працює метод <code>request_review</code> для <code>PendingReview</code>, якщо ми викличемо метод <code>approve</code> для <code>Draft</code>, це не буде мати ніякого ефекту, тому що <code>approve</code> поверне <code>self</code>. Коли ми викликаємо метод <code>approve</code> для <code>PendingReview</code>, він повертає новий, обгорнутий у <code>Box</code>, екземпляр структури <code>Published</code>. Структура <code>Published</code> реалізує трейт <code>State</code>, і як для методу <code>request_review</code>, так і для методу <code>approve</code> вона повертає себе, тому що в цих випадках допис повинен залишатися в стані <code>Published</code>.</p>
<p>Тепер нам потрібно оновити метод <code>content</code> для <code>Post</code>. Ми хочемо, щоб значення, яке повертається з <code>content</code>, залежало від поточного стану <code>Post</code>, тому ми збираємося делегувати частину функціональності <code>Post</code> в метод <code>content</code>, визначений для <code>state</code>, як показано в Блоці коду 17-17:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 17-17: Оновлення методу <code>content</code> в структурі <code>Post</code> для делегування частини функціональності методу <code>content</code> структури <code>State</code></span></p>
<p>Оскільки наша ціль полягає в тому, щоб зберегти ці дії всередині структур, які реалізують трейт <code>State</code>, ми викликаємо метод <code>content</code> у значення в полі <code>state</code> і передаємо екземпляр публікації (тобто <code>self</code>) як аргумент. Потім ми повертаємо значення, яке нам повертає виклик методу <code>content</code> поля <code>state</code>.</p>
<p>Ми викликаємо метод <code>as_ref</code> у <code>Option</code>, тому що нам потрібне посилання на значення всередині <code>Option</code>, а не володіння значенням. Оскільки <code>state</code> є типом <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>, то під час виклику методу <code>as_ref</code> повертається <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code>. Якби ми не викликали <code>as_ref</code>, отримали б помилку, тому що ми не можемо перемістити <code>state</code> з запозиченого параметра <code>&amp;self</code> функції.</p>
<p>Далі ми викликаємо метод <code>unwrap</code>. Ми знаємо, що цей метод тут ніколи не призведе до аварійного завершення програми, бо всі методи <code>Post</code> влаштовані таким чином, що після їх виконання, в поле <code>state</code> завжди міститься значення <code>Some</code>. Це один з випадків, про яких ми говорили в розділі <a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">&quot;Випадки, коли у вас більше інформації, ніж у компілятора&quot;</a><!-- ignore --> розділу 9 - випадок, коли ми знаємо, що значення <code>None</code> ніколи не зустрінеться, навіть якщо компілятор не може цього зрозуміти.</p>
<p>Тепер, коли ми викликаємо <code>content</code> у <code>&amp;Box&lt;dyn State&gt;</code>, в дію вступає перетворення під час розіменування (deref coercion) для <code>&amp;</code> та <code>Box</code>, тому в підсумку метод <code>content</code> буде викликаний для типу, який реалізує трейт <code>State</code>. Це означає, що нам потрібно додати метод <code>content</code> у визначення трейту <code>State</code>, і саме там ми розмістимо логіку для з'ясування того, який вміст повертати, в залежності від поточного стану, як показано в Блоці коду 17-18:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
</code></pre>
<p><span class="caption">Блок коду 17-18: Додавання методу <code>content</code> в трейт <code>State</code></span></p>
<p>Ми додаємо реалізацію за замовчуванням метода <code>content</code>, який повертає порожній стрічковий слайс. Це означає, що нам не прийдеться реалізовувати <code>content</code> в структурах <code>Draft</code> та <code>PendingReview</code>. Структура <code>Published</code> буде перевизначати метод <code>content</code> та поверне значення з <code>post.content</code>.</p>
<p>Зверніть увагу, що для цього метода нам потрібні анотації часу життя, як ми обговорювали в розділі 10. Ми беремо посилання на <code>post</code> як аргумент та повертаємо посилання на частину цього <code>post</code>, тому час життя посилання, що повертається, пов'язаний з часом життя аргументу <code>post</code>.</p>
<p>І ось, ми закінчили - тепер все у Блоці коду 17-11 працює! Ми реалізували патерн &quot;Стан&quot;, який визначає правила процесу роботи з дописом у блозі. Логіка, що пов'язана з цими правилами, знаходиться в об'єктах станів, а не розпорошена по всій структурі <code>Post</code>.</p>
<blockquote>
<h4 id="Чому-не-перерахунок-enum"><a class="header" href="#Чому-не-перерахунок-enum">Чому не перерахунок (enum)?</a></h4>
<p>Можливо, вам було цікаво, чому ми не використовували <code>enum</code> з різними можливими станами допису як варіантів. Це, безумовно, одне з можливих рішень, спробуйте його реалізувати та порівняйте кінцеві результати, щоб обрати, який з варіантів вам подобається більше! Одним з недоліків використання перерахунку є те, що в кожному місці, де перевіряється його значення, потрібен вираз <code>match</code> або щось подібне для обробки всіх можливих варіантів. Можливо в цьому випадку нам доведеться повторювати більше коду, ніж це було в рішенні з трейт-об'єктом.</p>
</blockquote>
<h3 id="Компроміси-патерну-Стан"><a class="header" href="#Компроміси-патерну-Стан">Компроміси патерну &quot;Стан&quot;</a></h3>
<p>Ми показали, що Rust здатен реалізувати об'єктноорієнтований патерн &quot;Стан&quot; для інкапсуляції різних типів поведінки, які повинний мати допис в кожному стані. Методи в <code>Post</code> нічого не знають про різні види поведінки. З таким способом організації коду, нам достатньо поглянути тільки на один його фрагмент, щоб дізнатися відмінності в поведінці опублікованого допису: в реалізацію трейту <code>State</code> у структури <code>Published</code>.</p>
<p>Якби ми збиралися створити альтернативну реалізацію, не використовуючи патерн &quot;Стан&quot;, ми могли б використовувати вирази <code>match</code> в методах структури <code>Post</code> або навіть в коді <code>main</code> для перевірки стану допису та зміни його поведінки в цих місцях. Це означало б, що нам би довелося аналізувати декілька фрагментів коду, щоб зрозуміти як себе веде допис в опублікованому стані! Якби ми вирішили додати ще станів, стало б ще гірше: кожному з цих виразів <code>match</code> знадобилися б додаткові гілки.</p>
<p>За допомогою патерну &quot;Стан&quot; методи <code>Post</code> та ділянки, де ми використовуємо <code>Post</code>, не потребують використання виразів <code>match</code>, а для додавання нового стану потрібно буде тільки додати нову структуру та реалізувати методи трейту для цієї структури.</p>
<p>Реалізацію з використанням патерну &quot;Стан&quot; легко розширити для додавання нової функціональності. Щоб побачити, як легко підтримувати код, який використовує даний патерн, спробуйте виконати декілька з пропозицій нижче:</p>
<ul>
<li>Додайте метод <code>reject</code>, який змінює стан публікації з <code>PendingReview</code> назад на <code>Draft</code>.</li>
<li>Вимагайте два виклики метода <code>approve</code>, спершу ніж переводити стан в <code>Published</code>.</li>
<li>Дозвольте користувачам додавати текстовий вміст тільки тоді, коли публікація знаходиться в стані <code>Draft</code>. Порада: нехай об'єкт стану вирішує, чи можна змінювати вміст, але не відповідає за зміну <code>Post</code>.</li>
</ul>
<p>Одним з недоліків патерну &quot;Стан&quot; є те, що оскільки стани самі реалізують переходи між собою, деякі з них виходять пов'язаними один з одним. Якщо ми додамо інший стан між <code>PendingReview</code> та <code>Published</code>, наприклад <code>Scheduled</code> (&quot;заплановано&quot;), то доведеться змінювати код в <code>PendingReview</code>, щоб воно тепер переходило в стан <code>Scheduled</code>. Якби не потрібно було змінювати <code>PendingReview</code> при додаванні нового стану, було б менше роботи, але це означало б, що ми переходимо на інший шаблон проєктування.</p>
<p>Іншим недоліком є дублювання деякої логіки. Щоб усунути деяке дублювання, ми могли б спробувати зробити реалізацію за замовчуванням для методів <code>request_review</code> та <code>approve</code> трейту <code>State</code>, які повертають <code>self</code>; однак, це б порушило безпечність об'єкта, тому що трейт не знає, яким конкретно буде <code>self</code>. Ми хочемо мати можливість використовувати <code>State</code> як трейт-об'єкт, тому нам потрібно, щоб його методи були об'єктно-безпечними.</p>
<p>Інше дублювання містять подібні реалізації методів <code>request_review</code> та <code>approve</code> у <code>Post</code>. Обидва методи делегують реалізації одного й того самого методу значенню поля <code>state</code> типа <code>Option</code> і встановлює результатом нове значення поля <code>state</code>. Якби у <code>Post</code> було багато методів, що дотримувалися цього шаблону, ми могли б розглянути визначення макроса для усунення повторів (дивись секцію <a href="ch19-06-macros.html#macros">&quot;Макроси&quot;</a><!-- ignore --> розділу 19).</p>
<p>Реалізуючи патерн &quot;Стан&quot; таким чином, як він визначений для об'єктноорієнтованих мов, ми не використовуємо переваги Rust на повну. Нумо подивімось на деякі зміни, які ми можемо зробити в крейті <code>blog</code>, щоб неприпустимі стани й переходи перетворити в помилки часу компіляції.</p>
<h4 id="Кодування-станів-та-поведінки-в-вигляді-типів"><a class="header" href="#Кодування-станів-та-поведінки-в-вигляді-типів">Кодування станів та поведінки в вигляді типів</a></h4>
<p>Ми покажемо вам, як переосмислити патерн &quot;Стан&quot;, щоб отримати інший набір компромісів. Замість того, щоб повністю інкапсулювати стани й переходи, таким чином, щоб зовнішній код не знав про них, ми будемо кодувати стани з допомогою різних типів. Отже, система перевірки типів Rust буде перешкоджати спробам використовувати чернетки там, де дозволені тільки опубліковані дописи, викликаючи помилки компіляції.</p>
<p>Розгляньмо першу частину <code>main</code> в Блоці коду 17-11:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!(&quot;&quot;, post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
</span>}
</code></pre>
<p>Ми все ще дозволяємо створювати нові дописи у чернетці використовуючи <code>Post::new</code> і можливість додавати текст до змісту повідомлення. Але замість метода <code>content</code> у чернетці, що повертає порожню стрічку, ми зробимо так, що у чернеток взагалі не буває методу <code>content</code>. Таким чином, якщо ми спробуємо отримати вміст чернетки, отримаємо помилку компілятора, що повідомляє про відсутність методу. Як результат ми не зможемо випадково відобразити вміст чернетки допису в програмі, що працює, тому що цей код навіть не скомпілюється. В Блоці коду 17-19 показано визначення структур <code>Post</code> та <code>DraftPost</code>, а також методів для кожної з них:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
</code></pre>
<p><span class="caption">Блок коду 17-19: Структура <code>Post</code> з методом <code>content</code> та структура <code>DraftPost</code> без методу <code>content</code></span></p>
<p>Обидві структури <code>Post</code> та <code>DraftPost</code> мають приватне поле <code>content</code>, що зберігає текст допису. Структури більше не мають поля <code>state</code>, тому що ми перемістили логіку кодування стану в типи структур. Структура <code>Post</code> буде являти собою опублікований допис, і в неї є метод <code>content</code>, який повертає <code>content</code>.</p>
<p>У нас все ще є функція <code>Post::new</code>, але замість повернення екземпляра <code>Post</code> вона повертає екземпляр <code>DraftPost</code>. Оскільки поле <code>content</code> є приватним і немає ніяких функцій, які повертають <code>Post</code>, вже не вийде створити екземпляр <code>Post</code>.</p>
<p>Структура <code>DraftPost</code> має метод <code>add_text</code>, тому ми можемо додавати текст до <code>content</code> як і раніше, але врахуйте, що в <code>DraftPost</code> не визначений метод <code>content</code>! Тепер програма гарантує, що всі дописи починаються як чернетки, а чернетки не мають контенту для відображення. Будь-яка спроба подолати ці обмеження призведе до помилки компілятора.</p>
<h4 id="Реалізація-переходів-як-трансформації-в-інші-типи"><a class="header" href="#Реалізація-переходів-як-трансформації-в-інші-типи">Реалізація переходів як трансформації в інші типи</a></h4>
<p>Як же нам опублікувати допис? Ми хочемо забезпечити дотримання правила, відповідно якому чернетка допису повинна бути перевірена та схвалена до того, як допис буде опублікований. Допис, що знаходиться в стані очікування перевірки, також не повинен вміти відображати вміст. Реалізуймо ці обмеження, додавши ще одну структуру, <code>PendingReviewPost</code>, визначивши метод <code>request_review</code> у <code>DraftPost</code>, що повертає <code>PendingReviewPost</code>, і визначивши метод <code>approve</code> у <code>PendingReviewPost</code>, що повертає <code>Post</code>, як показано в Блоці коду 17-20:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
</code></pre>
<p><span class="caption">Блок коду 17-20: <code>PendingReviewPost</code>, що створюється шляхом виклику методу <code>request_review</code> екземпляру <code>DraftPost</code> і метод <code>approve</code>, який перетворює <code>PendingReviewPost</code> в опублікований <code>Post</code></span></p>
<p>Методи <code>request_review</code> та <code>approve</code> забирають у володіння <code>self</code>, таким чином поглинаючи екземпляри <code>DraftPost</code> і <code>PendingReviewPost</code>, які потім перетворюються в <code>PendingReviewPost</code> та опублікований <code>Post</code>, відповідно. Таким чином, в нас не буде ніяких довгоживучих екземплярів <code>DraftPost</code>, після того, як ми викликали в них <code>request_review</code> і так далі. У структурі <code>PendingReviewPost</code> не визначений метод <code>content</code>, тому спроба прочитати її вміст призводить до помилки компілятора, як і у випадку з <code>DraftPost</code>. Тому що единим способом отримати опублікований екземпляр <code>Post</code>, у якого дійсно є визначений метод <code>content</code>, є викликом метода <code>approve</code> у екземпляра <code>PendingReviewPost</code>, а единий спосіб отримати <code>PendingReviewPost</code> - це викликати метод <code>request_review</code> в екземпляра <code>DraftPost</code>, тобто ми закодували процес зміни станів допису за допомогою системи типів.</p>
<p>Але ми також повинні зробити невеличкі зміни в <code>main</code>. Методи <code>request_review</code> та <code>approve</code> повертають нові екземпляри, а не змінюють структуру, до якої вони звертаються, тому нам потрібно додати більше виразів <code>let post =</code>, затіняючи присвоювання для збереження екземплярів, що повертаються. Ми також не можемо використовувати твердження (assertions) для чернетки та допису, який очікує на перевірку, що вміст повинен бути пустим рядком, бо вони нам більше не потрібні: тепер ми не зможемо скомпілювати код, який намагається використовувати вміст дописів, що знаходяться в цих станах. Оновлений код в <code>main</code> показано в Блоці коду 17-21:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Блок коду 17-21: Зміни в <code>main</code>, які використовують нову реалізацію процесу підготовки допису блогу</span></p>
<p>Зміни, які нам треба було зробити в <code>main</code>, щоб перевизначити <code>post</code> означають, що ця реалізація тепер не зовсім відповідає об'єктноорієнтованому патерну &quot;Стан&quot;: перетворення між станами більше не інкапсульовані всередині реалізації <code>Post</code> повністю. Проте, ми отримали велику вигоду в тому, що неприпустимі стани тепер неможливі завдяки системі типів та їх перевірці, що відбувається під час компіляції! Це гарантує, що деякі помилки, такі як відображення вмісту неопублікованого допису, будуть знайдені ще до того, як вони дійдуть до користувачів.</p>
<p>Спробуйте виконати завдання, які були запропоновані на початку цього розділу, у версії крейта <code>blog</code>, яким він став після Блока коду 17-20, щоб сформувати свою думку про дизайн цієї версії коду. Зверніть увагу, що деякі інші завдання в цьому варіанті вже можуть бути виконані.</p>
<p>Ми побачили, що хоча Rust і здатен реалізувати об'єктноорієнтовані шаблони проєктування, в ньому також доступні й інші шаблони, такі як кодування стану за допомогою системи типів. Ці шаблони мають різні компроміси. Хоча ви, можливо, дуже добре знайомі з об'єктноорієнтованими патернами, переосмислення проблем для використання переваг і можливостей Rust може дати такі вигоди, як запобігання деяких помилок під час компіляції. Об'єктноорієнтовані патерни не завжди будуть найкращим рішенням в Rust через наявність деяких можливостей, таких як володіння, якого немає в об'єктноорієнтованих мов.</p>
<h2 id="Підсумок-16"><a class="header" href="#Підсумок-16">Підсумок</a></h2>
<p>Незалежно від того, вважаєте ви Rust об'єктноорієнтованою мовою чи ні, прочитавши цей розділ, ви тепер знаєте, що можна використовувати трейт-об'єкти для впровадження деяких об'єктноорієнтованих можливостей у Rust. Динамічна диспетчеризація може дату коду певну гнучкість в обмін на невеличке погіршення швидкодії програми під час виконання. Ви можете використовувати цю гнучкість для реалізації об'єктноорієнтованих патернів, які можуть покращити супроводжуваність вашого коду. Rust також має особливості, такі як власність, які не мають об'єктноорієнтовані мови. Об'єктноорієнтовані патерни не завжди будуть найкращим способом скористатися перевагами Rust, але є доступною опцією.</p>
<p>Далі ми розглянемо патерни, які є ще однією особливістю мови Rust, що дає більше гнучкості. Ми трохи зустрічалися з ними впродовж всієї книги, але все ще не проаналізували всі їх можливості. Вперед до нових можливостей!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Шаблони-та-Зіставлення-Шаблонів"><a class="header" href="#Шаблони-та-Зіставлення-Шаблонів">Шаблони та Зіставлення Шаблонів</a></h1>
<p><em>Шаблони</em> це спеціальний синтаксис в Rust для порівняння з певною структурою типів, складною чи простою. Використання шаблонів у поєднанні з виразами <code>match</code> та іншими конструкціями дає нам більше контролю над нашою програмою. Шаблон складається з певної комбінації наступного:</p>
<ul>
<li>Літералів</li>
<li>Деструктуризованих масивів, енумів, структур або кортежів</li>
<li>Змінних</li>
<li>Символів узагальнення</li>
<li>Заповнювачів</li>
</ul>
<p><code>x</code>, <code>(a, 3)</code>, та <code>Some(Color::Red)</code> це декілька прикладів шаблонів. У контекстах, у яких шаблони дійсні, ці компоненти описують форму даних. Наші програми потім зіставляють значення з шаблонами для визначення коректності форми даних та продовження виконання коду.</p>
<p>Щоб використати шаблон, ми порівнюємо його з якимось значенням. Ми використовуємо частини значення в нашому коді, якщо значенню зіставляється зі шаблоном. Згадайте вирази <code>match</code> в Розділі 6, такі як coin-sorting machine example(скопіювати переклад з шостого розділу), які використовували шаблони. Якщо значення підходить формі шаблону, то ми можемо найменувати та використати певні частини цього значення. Якщо не підходить, то пов'язаний з шаблоном код не виконається.</p>
<p>Цей розділ є довідником для всього пов'язаного з шаблонами. Ми розглянемо місця де можна використовувати шаблони, різницю між спростовними і неспростовними шаблонами та різновиди синтаксису шаблонів, які ви можете побачити. Наприкінці цього розділу ви будете знати як використовувати шаблони для вираження багатьох концептів чітким способом.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Усі-Місця-Можливого-Використання-Шаблонів"><a class="header" href="#Усі-Місця-Можливого-Використання-Шаблонів">Усі Місця Можливого Використання Шаблонів</a></h2>
<p>Шаблони з’являються в багатьох місцях в Rust, і ви ними багато користуєтеся навіть не підозрюючи про це! В цьому розділі ми розглянемо всі місця, де допускаються шаблони.</p>
<h3 id="Рукави-виразу-match"><a class="header" href="#Рукави-виразу-match">Рукави виразу <code>match</code></a></h3>
<p>Як обговорювалося в Розділі 6, ми використовуємо шаблони в рукавах виразів <code>match</code>. Формально, вирази <code>match</code> визначені як ключове слово <code>match</code>, значення яке буде зіставлятися та один або більше рукавів зіставлення, що складаються з шаблону та виразу для виконання, якщо значення зіставляється зі шаблоном рукава, як тут:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>For example, here's the <code>match</code> expression from Listing 6-5 that matches on an <code>Option&lt;i32&gt;</code> value in the variable <code>x</code>:</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}
</code></pre>
<p>The patterns in this <code>match</code> expression are the <code>None</code> and <code>Some(i)</code> on the left of each arrow.</p>
<p>Одна з вимог виразів <code>match</code> це необхідність бути <em>вичерпним</em> у сенсі, що всі можливі значення виразу <code>match</code> повинні бути враховані. Один зі способів переконатися, що ви охопили всі можливі варіанти, - це мати загальний шаблон для останнього рукава: наприклад, назва змінної, що збігається з будь-яким значенням, не може не спрацювати і, таким чином, охоплює всі варіанти, що залишилися.</p>
<p>Зокрема, шаблон <code>_</code> буде відповідати будь-чому, але він ніколи не зв'язується зі змінною, тому його часто використовують в останньому рукаві виразу match. Шаблон <code>_</code> може бути корисним, наприклад, коли потрібно ігнорувати будь-яке не вказане значення. Ми розглянемо шаблон <code>_</code> більш детально в секції <a href="">&quot;Ігнорування Значень в Шаблоні&quot;</a><!-- ignore --> пізніше в цьому розділі.</p>
<h3 id="Умовні-Вирази-if-let"><a class="header" href="#Умовні-Вирази-if-let">Умовні Вирази <code>if let</code></a></h3>
<p>В Розділі 6 ми обговорювали використання виразів <code>if let</code> в основному як рівнозначний та коротший спосіб написання <code>match</code>, який лише зіставляється в одному випадку. При необхідності, <code>if let</code> може мати відповідний <code>else</code>, що містить код для виконання на випадок невідповідності шаблону в <code>if let</code>.</p>
<p>В Блоці Коду 18-1 показано, що також можливо поєднувати вирази <code>if let</code>, <code>else if</code>, та <code>else if let</code>. Це надає нам більшу гнучкість, ніж вираз <code>match</code>, в якому ми можемо представити тільки одне значення для порівняння з шаблонами. Також Rust не вимагає, щоб умови в послідовності <code>if let</code>, <code>else if</code>, <code>else if let</code> стосувалися одна одної.</p>
<p>Код у Блоці Коду 18-1 визначає, яким кольором зробити ваш фон, виходячи з низки перевірок за кількома умовами. Для цього прикладу ми створили змінні з жорстко заданими значеннями, які справжня програма може отримати з вхідних даних користувача.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Using your favorite color, {color}, as the background&quot;);
    } else if is_tuesday {
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Using purple as the background color&quot;);
        } else {
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        println!(&quot;Using blue as the background color&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-1: Mixing <code>if let</code>, <code>else if</code>, <code>else if let</code>, and <code>else</code></span></p>
<p>Якщо користувач вказує улюблений колір, цей колір використовується як фоновий. Якщо улюблений колір не вказано і сьогодні Вівторок, то фоновим кольором буде зелений. Інакше, якщо користувач вказує свій вік стрічкою і ми можемо успішно розібрати її як число, то колір буде фіолетовим або помаранчевим в залежності від значення числа. Якщо жодна з цих умов не застосовується, колір фону буде синім.</p>
<p>Ця умовна структура дозволяє нам підтримувати складні вимоги. З жорстко заданими значеннями як ми маємо тут, цей приклад виведе в консолі <code>Використовую фіолетовий колір як колір фону</code>.</p>
<p>Ви можете побачити, що <code>if let</code> також може впроваджувати затінені змінні аналогічним чином що і рукави <code>match</code>: рядок <code>if let Ok(age) = age</code> запроваджує нову затінену змінну <code>age</code>, яка містить значення всередині <code>Ok</code>. Це означає, що нам потрібно помістити умову <code>if age &gt; 30</code> в цей блок: ми не можемо об'єднати ці дві умови в <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. Значення затіненої змінної <code>age</code>, яку ми хочемо порівняти з 30, не дійсне до тих пір, поки не почнеться новий діапазон з фігурної дужки.</p>
<p>Недоліком використання виразів <code>if let</code> є те, що компілятор не перевіряє вичерпність, тоді як при використанні виразів <code>match</code> він це робить. Якби ми пропустили останній блок <code>else</code> і, відповідно, пропустили обробку деяких випадків, компілятор не попередив би нас про можливу логічну помилку.</p>
<h3 id="Умовні-Цикли-while-let"><a class="header" href="#Умовні-Цикли-while-let">Умовні Цикли <code>while let</code></a></h3>
<p>Подібно до конструкції <code>if let</code>, умовний цикл <code>while let</code> дозволяє циклу <code>while</code> працювати допоки шаблон продовжує збігатися. У Блоці Коду наведено код циклу <code>while let</code>, який використовує вектор як стек і виводить в консолі значення вектора у зворотному порядку, в якому вони були додані.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!(&quot;{}&quot;, top);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-2: Using a <code>while let</code> loop to print values for as long as <code>stack.pop()</code> returns <code>Some</code></span></p>
<p>Цей приклад виводить в консолі 3, 2, і потім 1. Метод <code>pop</code> бере останній елемент з вектора і повертає <code>Some(значення)</code>. Якщо вектор порожній, <code>pop</code> поверне <code>None</code>. Цикл <code>while</code> продовжує виконання коду в своєму блоці допоки <code>pop</code> повертає <code>Some</code>. Коли <code>pop</code> поверне <code>None</code>, цикл зупиниться. Ми можемо використовувати <code>while let</code> для вилучення кожного елементу зі стека.</p>
<h3 id="Цикли-for"><a class="header" href="#Цикли-for">Цикли <code>for</code></a></h3>
<p>В циклі <code>for</code>, значення яке безпосередньо слідує за ключовим словом <code>for</code> є шаблоном. Наприклад, <code>x</code> в <code>for x in y</code> є шаблоном. Блок Коду 18-3 демонструє як використовувати шаблон в циклі <code>for</code> для деструктуризації або розбирання на частини кортежу, як частини циклу <code>for</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!(&quot;{} is at index {}&quot;, value, index);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-3: Using a pattern in a <code>for</code> loop to destructure a tuple</span></p>
<p>Код в Блоці Коду 18-3 виведе в консоль наступне:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>Ми адаптуємо ітератор використовуючи метод <code>enumerate</code> таким чином, щоб він генерував значення та індекс для цього значення, поміщені в кортеж. Перше згенероване значення - кортеж <code>(0, 'a')</code>. При зіставленні цього значення з шаблоном <code>(index, value)</code>, <code>index</code> буде <code>0</code>, а <code>value</code> буде <code>'a'</code>, виводячи перший рядок виводу в консоль.</p>
<h3 id="Інструкції-let"><a class="header" href="#Інструкції-let">Інструкції <code>let</code></a></h3>
<p>До цього розділу ми явно обговорювали тільки використання шаблонів з <code>match</code> та <code>if let</code>, але насправді ми використовували шаблони і в інших місцях, в тому числі і в операторах <code>let</code>. Наприклад, розглянемо це просте присвоювання змінної з використанням <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>Кожного разу, коли ви використовували інструкцію <code>let</code>, ви використовували шаблони, хоча, можливо, ви цього навіть не усвідомлювали! Більш формально, оператор <code>let</code> виглядає так:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>В інструкціях типу <code>let x = 5;</code> з назвою змінної в слоті <code>PATTERN</code> назва змінної є лише особливо простою формою шаблону. Rust порівнює вираз із шаблоном і призначає будь-які знайдені імена. Таким чином, у прикладі <code>let x = 5;</code> <code>x</code> - це шаблон, який означає &quot;прив'язати до змінної <code>x</code> все, що зіставляється з цим виразом.&quot; Оскільки назва <code>x</code> - це весь шаблон, цей шаблон фактично означає &quot;прив'язати все до змінної <code>x</code>, незалежно від її значення.&quot;</p>
<p>To see the pattern matching aspect of <code>let</code> more clearly, consider Listing 18-4, which uses a pattern with <code>let</code> to destructure a tuple.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-4: Using a pattern to destructure a tuple and create three variables at once</span></p>
<p>Тут ми зіставляємо кортеж з шаблоном. Rust зіставляє значення <code>(1, 2, 3)</code> із шаблоном <code>(x, y, z)</code> та бачить, що значення зіставляються, тому Rust пов'язує <code>1</code> до <code>x</code>, <code>2</code> до <code>y</code> та <code>3</code> до <code>z</code>. Ви можете думати про цей шаблон кортежу як про три окремих вкладених шаблонів змінних всередині.</p>
<p>Якщо кількість елементів у шаблоні не відповідає кількості елементів у кортежі, то загальний тип не буде збігатися і ми отримаємо помилку компілятора. Наприклад, у Блоці Коду 18-5 показано спробу деструктуризації кортежу з трьома елементами на дві змінні, що не спрацює.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 18-5: Incorrectly constructing a pattern whose variables don’t match the number of elements in the tuple</span></p>
<p>Спроба скомпілювати цей код призведе до помилки цього типу:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` due to previous error
</code></pre>
<p>Щоб виправити помилку, ми можемо проігнорувати один або більше значень кортежу, використовуючи <code>_</code> або <code>..</code>, як ви побачите в секції <a href="">&quot;Ігнорування Значень в Шаблоні&quot;</a><!-- ignore --> . Якщо проблема в тому, що в шаблоні занадто багато змінних, то рішення полягає в узгодженні типів шляхом видалення змінних так, щоб кількість змінних дорівнювала кількості елементів в кортежі.</p>
<h3 id="Параметри-Функції"><a class="header" href="#Параметри-Функції">Параметри Функції</a></h3>
<p>Параметри функції також можуть бути шаблонами. Код у Блоці Коду 18-6, який оголошує функцію з назвою <code>foo</code>, яка отримує один параметр з назвою <code>x</code> типу <code>i32</code>, вже повинен виглядати знайомим.</p>
<pre><pre class="playground"><code class="language-rust">fn foo(x: i32) {
    // code goes here
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 18-6: A function signature uses patterns in the parameters</span></p>
<p>Частина <code>x</code> - це шаблон! Ми можемо зіставляти кортеж в аргументах функції із шаблоном, як ми зробили з <code>let</code>. В Блоці Коду 18-7 значення кортежу розділяються, коли ми передаємо їх до функції.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<p><span class="caption">Listing 18-7: A function with parameters that destructure a tuple</span></p>
<p>Цей код виводить в консоль <code>Current location: (3, 5)</code>. Значення <code>&amp;(3, 5)</code> зіставляються з шаблоном <code>&amp;(x, y)</code>, тому <code>x</code> має значення <code>3</code> та <code>y</code>має значення <code>5</code>.</p>
<p>We can also use patterns in closure parameter lists in the same way as in function parameter lists, because closures are similar to functions, as discussed in Chapter 13.</p>
<p>Наразі ви побачили декілька способів використання шаблонів, але вони не працюють однаково у всіх місцях можливого використання. У деяких місцях шаблони мають бути неспростовні; в інших умовах вони можуть бути спростовними. Ми обговоримо ці дві концепції далі.
ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Спростовуваність-Чи-Може-Шаблон-Бути-Невідповідним"><a class="header" href="#Спростовуваність-Чи-Може-Шаблон-Бути-Невідповідним">Спростовуваність: Чи Може Шаблон Бути Невідповідним</a></h2>
<p>Шаблони бувають двох видів: спростовні та неспростовні. Шаблони, які збігаються з будь-яким можливим переданим значенням, є <em>неспростовними</em>. Прикладом може бути <code>x</code> в інструкції <code>let x = 5;</code> тому що <code>x</code> збігається з будь-яким значенням і тому не може не збігатися. Шаблони, які можуть не збігатися з деякими можливими значеннями, є <em>спростовними</em>. Прикладом може бути <code>Some(x)</code> у виразі <code>if let Some(x) = a_value</code>, тому що якщо значення змінної <code>a_value</code> буде <code>None</code>, а не <code>Some</code>, то шаблон <code>Some(x)</code> не буде зіставлятися.</p>
<p>Параметри функцій, інструкції <code>let</code> і цикли <code>for</code> можуть приймати тільки неспростовні шаблони, тому що програма не може зробити нічого путнього, коли значення не збігаються. Вирази <code>if let</code> і <code>while let</code> допускають спростовні і неспростовні шаблони, але компілятор застерігає від неспростовних шаблонів, оскільки за визначенням вони призначені для обробки можливих збоїв: функціональність умови полягає в її здатності працювати по-різному в залежності від успіху або невдачі.</p>
<p>В цілому, ви не повинні турбуватися про різницю між спростовуваними і не спростовуваними шаблонами; однак, ви повинні бути знайомі з концепцією спростовуваності, щоб мати можливість реагувати, коли ви бачите її в повідомленні про помилку. У таких випадках вам потрібно буде змінити або шаблон, або конструкцію, в якій ви використовуєте шаблон, в залежності від бажаної поведінки коду.</p>
<p>Розгляньмо приклад того, що відбувається, коли ми намагаємося використати спростовуваний шаблон там, де Rust вимагає неспростовний шаблон і навпаки. У Блоці Коду 18-8 показано інструкцію <code>let</code>, але для шаблону ми вказали <code>Some(x)</code>, спростовуваний шаблон. Як і слід було очікувати, цей код не буде компілюватися.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 18-8: Attempting to use a refutable pattern with <code>let</code></span></p>
<p>Якщо значення <code>some_option_value</code> було б значенням <code>None</code>, то воно не відповідало б шаблону <code>Some(x)</code>, що означає, що шаблон є спростовуваним. Однак, інструкція <code>let</code> може приймати тільки неспростовний шаблон, тому що код не може зробити нічого коректного зі значенням <code>None</code>. Під час компіляції Rust поскаржиться, що ми намагалися використати спростовуваний шаблон там, де потрібен неспростовний шаблон:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding: `None` not covered
   --&gt; src/main.rs:3:9
    |
3   |     let Some(x) = some_option_value;
    |         ^^^^^^^ pattern `None` not covered
    |
    = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant
    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
note: `Option&lt;i32&gt;` defined here
    = note: the matched value is of type `Option&lt;i32&gt;`
help: you might want to use `if let` to ignore the variant that isn't matched
    |
3   |     let x = if let Some(x) = some_option_value { x } else { todo!() };
    |     ++++++++++                                 ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` due to previous error
</code></pre>
<p>Оскільки ми не покрили (і не могли покрити!) кожне допустиме значення шаблоном <code>Some(x)</code>, Rust справедливо видасть помилку компілятора.</p>
<p>Якщо у нас є спростовний шаблон там, де потрібен неспростовний, ми можемо виправити це, змінивши код, який використовує шаблон: замість використання <code>let</code>,, ми можемо використати <code>if let</code>. Тоді, якщо шаблон не збігається, код просто пропустить код у фігурних дужках, даючи йому можливість продовжити правильне виконання коду. У Блоці Коду 18-9 показано, як виправити код у Блоці Коду 18-8.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    if let Some(x) = some_option_value {
        println!(&quot;{}&quot;, x);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-9: Using <code>if let</code> and a block with refutable patterns instead of <code>let</code></span></p>
<p>Ми дали коду вихід! Цей код абсолютно дійсний, хоча це означає, що ми не можемо використовувати неспростовний шаблон без отримання помилки. Якщо ми дамо <code>if let</code> шаблон, який завжди збігатиметься, наприклад, <code>x</code>, як показано у Блоці Коду 18-10, компілятор видасть попередження.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!(&quot;{}&quot;, x);
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-10: Attempting to use an irrefutable pattern with <code>if let</code></span></p>
<p>Rust скаржиться, що немає сенсу використовувати <code>if let</code> з неспростовним шаблоном:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `if let` pattern
 --&gt; src/main.rs:2:8
  |
2 |     if let x = 5 {
  |        ^^^^^^^^^
  |
  = note: `#[warn(irrefutable_let_patterns)]` on by default
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`

warning: `patterns` (bin &quot;patterns&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<p>З цієї причини рукави збігів повинні використовувати спростовувані шаблони, за винятком останнього плеча, яке повинно збігатися з будь-якими значеннями, що залишилися, з неспростовним шаблоном. Rust дозволяє використовувати неспростовний шаблон у <code>match</code> лише з одним рукавом, але цей синтаксис не є особливо корисним і може бути замінений простішим оператором <code>let</code>.</p>
<p>Тепер, коли ви знаєте, де використовувати шаблони і в чому різниця між спростовуваними і не спростовуваними шаблонами, розгляньмо весь синтаксис, який можна використовувати для створення шаблонів.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Синтаксис-Шаблонів"><a class="header" href="#Синтаксис-Шаблонів">Синтаксис Шаблонів</a></h2>
<p>У цьому розділі ми збираємо всі синтаксичні конструкції, що використовуються в шаблонах, і обговорюємо, чому і коли ви можете захотіти використовувати кожну з них.</p>
<h3 id="Зіставлення-з-Літералами"><a class="header" href="#Зіставлення-з-Літералами">Зіставлення з Літералами</a></h3>
<p>Як ви бачили у Розділі 6, можна зіставляти шаблони з літералами напряму. Наведемо декілька прикладів в наступному коді:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;one&quot;),
        2 =&gt; println!(&quot;two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Цей код виведе в консолі <code>one</code>, оскільки значення в <code>x</code> дорівнює 1. Цей синтаксис корисний, коли ви хочете, щоб ваш код виконував дію, якщо він отримує певне значення.</p>
<h3 id="Зіставлення-з-Найменованими-Змінними"><a class="header" href="#Зіставлення-з-Найменованими-Змінними">Зіставлення з Найменованими Змінними</a></h3>
<p>Іменовані змінні - це незаперечні шаблони, які відповідають будь-якому значенню, і ми багато разів використовували їх у книзі. Однак, існує ускладнення при використанні іменованих змінних у виразах <code>match</code>. Оскільки <code>match</code> починає нову область видимості, змінні, оголошені як частина шаблону всередині виразу <code>match</code>, будуть затінювати змінні з тією ж назвою за межами конструкції <code>match</code>, як і у випадку з усіма змінними. У Блоці Коду 18-11 оголошується змінна з назвою <code>x</code> зі значенням <code>Some(5)</code> та змінна <code>y</code> зі значенням <code>10</code>. Потім ми створюємо вираз <code>match</code> над значенням <code>x</code>. Подивіться на шаблони в рукавах match і <code>println!</code> наприкінці, і перед тим, як запускати цей код або читати далі, спробуйте з'ясувати, що виведе код в консолі.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {y}&quot;),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {y}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок Коду 18-11: Вираз <code>match</code> з рукавом, що вводить затінену змінну <code>y</code></span></p>
<p>Розглянемо, що відбувається при виконанні виразу <code>match</code>. Шаблон у першому рукаві порівняння не збігається із заданим значенням <code>x</code>, тому код продовжується.</p>
<p>Шаблон у другому рукаві порівняння вводить нову змінну з назвою <code>y</code>, яка буде відповідати будь-якому значенню всередині значення <code>Some</code>. Оскільки ми знаходимося в новій області видимості всередині виразу <code>match</code>, це нова змінна <code>y</code>, а не та <code>y</code>, яку ми оголосили на початку зі значенням 10. Ця нова прив'язка <code>y</code> буде відповідати будь-якому значенню всередині <code>Some</code>, яке ми маємо в <code>x</code>. Таким чином, ця нова <code>y</code> зв'язується з внутрішнім значенням <code>Some</code> в <code>x</code>. Це значення <code>5</code>, тому вираз для цього рукава виконується і виводить в консолі <code>Matched, y = 5</code>.</p>
<p>Якби значення <code>x</code> було б <code>None</code> замість <code>Some(5)</code>, шаблони в перших двох рукавах не збіглися б, тому значення збіглося б з підкресленням. Ми не створювали змінну <code>x</code> у шаблоні підкреслення, тому <code>x</code> у виразі - це все ще зовнішній <code>x</code>, який не був затінений. У цьому гіпотетичному випадку <code>match</code> виведе в консолі <code>Default case, x = None</code>.</p>
<p>Коли вираз <code>match</code> виконано, його область видимості закінчується, так само як і область видимості внутрішньої <code>y</code>. Останній <code>println!</code> виведе в консолі <code>at the end: x = Some(5), y = 10</code>.</p>
<p>Щоб створити вираз <code>match</code>, який порівнює значення зовнішніх <code>x</code> і <code>y</code>, замість того, щоб вводити затінену змінну, нам потрібно буде використовувати умовний запобіжник. Ми поговоримо про запобіжники пізніше в розділі <a href="ch18-03-pattern-syntax.html#extra-conditionals-with-match-guards">&quot;Додаткові умови з запобіжниками&quot;</a><!--
ignore --> .</p>
<h3 id="Декілька-Шаблонів"><a class="header" href="#Декілька-Шаблонів">Декілька Шаблонів</a></h3>
<p>У виразах <code>match</code> ви можете зіставляти кілька шаблонів, використовуючи синтаксис <code>|</code>, який є оператором шаблону <em>or</em>. Наприклад, у наступному коді ми порівнюємо значення <code>x</code> з рукавами match, перше з яких має опцію <em>or</em>, що означає, що якщо значення <code>x</code> збігається з будь-яким зі значень у цьому рукаві, код цього рукава буде виконано:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;one or two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Цей код виведе в консоль <code>one or two</code>.</p>
<h3 id="Зіставлення-Діапазонів-Значень-з-"><a class="header" href="#Зіставлення-Діапазонів-Значень-з-">Зіставлення Діапазонів Значень з <code>..=</code></a></h3>
<p>Синтаксис <code>..=</code> дозволяє робити інклюзивне зіставлення, зіставлення з діапазоном включно з останнім його значенням. В наступному коді буде виконана гілка, шаблон якої зіставляється з будь-яким значенням заданого діапазону:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;one through five&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Якщо <code>x</code> дорівнює 1, 2, 3, 4, або 5, то буде обрана перша гілка виразу match. Цей синтаксис більш зручний для зіставлення декількох значень ніж використання оператора <code>|</code> для вираження тої самої ідеї; якщо ми використовували б <code>|</code>, нам було б потрібно вказати <code>1 | 2 | 3 | 4 | 5</code>. Вказання діапазону набагато коротше, особливо якщо ми хочемо зіставляти, скажімо, будь-яке число між 1 та 1,000!</p>
<p>Компілятор перевіряє, що діапазон не порожній під час компіляції, і оскільки єдиними типами, для яких Rust може сказати, чи є діапазон порожнім чи ні, є <code>char</code> та числові значення, діапазони дозволяють лише числові або <code>char</code> значення.</p>
<p>Ось приклад використання діапазонів значень <code>char</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;early ASCII letter&quot;),
        'k'..='z' =&gt; println!(&quot;late ASCII letter&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Rust може визначити, що <code>'c'</code> в першому діапазоні шаблона та виведе в консоль <code>early ASCII letter</code>.</p>
<h3 id="Деструктуризація-для-Розбору-Значень-на-Частини"><a class="header" href="#Деструктуризація-для-Розбору-Значень-на-Частини">Деструктуризація для Розбору Значень на Частини</a></h3>
<p>Ми також використовуємо шаблони для деструктуризації структур, енумів та кортежів для використання різних частин їх значень. Розглянемо покроково кожне значення.</p>
<h4 id="Деструктуризація-Структур"><a class="header" href="#Деструктуризація-Структур">Деструктуризація Структур</a></h4>
<p>У Блоці Коду 18-12 показана структура <code>Point</code> з двома полями <code>x</code> і <code>y</code>, яку ми можемо розбити на частини за допомогою шаблону з інструкцією <code>let</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">Блок Коду 18-12: Деструктуризація полів структури в окремі змінні</span></p>
<p>В цьому коді створюються змінні <code>a</code> та <code>b</code>, які відповідають значенням полів <code>x</code> та <code>y</code> структури <code>p</code>. Цей приклад показує, що назви змінних у шаблоні не обов'язково повинні збігатися з назвами полів структури. Однак, зазвичай назви змінних збігаються з назвами полів, щоб полегшити запам'ятовування того, які змінні походять з яких полів. Через таке поширене використання, а також через те, що запис <code>let Point { x: x, y: y } = p;</code> містить багато повторень, Rust має скорочення для шаблонів, які відповідають полям struct: вам потрібно лише перерахувати назву поля struct, і змінні, створені на основі шаблону, матимуть ті ж самі назви. Блок Коду 18-13 працює так само як і Блок Коду 18-12, але змінні, що створюються в шаблоні <code>let</code>, є <code>x</code> і <code>y</code> замість <code>a</code> і <code>b</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">Блок коду 18-13: Деструктуризація полів структури за допомогою скорочення</span></p>
<p>Цей код створить змінні <code>x</code> та <code>y</code>, які відповідають полям <code>x</code> та<code>y</code> змінної <code>p</code>. В результаті змінні <code>x</code> та <code>y</code> містять значення зі структури <code>p</code>.</p>
<p>Ми також можемо деструктурувати за допомогою буквених значень як частини шаблону struct замість того, щоб створювати змінні для всіх полів. Це дозволяє нам перевіряти деякі з полів на наявність певних значень, створюючи змінні для деструктуризації інших полів.</p>
<p>У Блоці Коду 18-14 ми маємо вираз <code>match</code>, який розділяє значення <code>Point</code> на три випадки: точки, які лежать безпосередньо на осі <code>x</code> (що вірно, коли <code>y = 0</code>), на осі <code>y</code> (<code>x = 0</code>), або не лежать ні на одній з них.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p><span class="caption">Блок Коду 18-14: Деструктуризація та зіставлення буквених значень в одному шаблоні</span></p>
<p>Перший рукав буде відповідати будь-якій точці, що лежить на осі <code>x</code>, вказуючи, що поле <code>y</code> збігається, якщо його значення збігається з <code>0</code>. Шаблон все ще створює змінну <code>x</code>, яку ми можемо використовувати в коді для цього рукава.</p>
<p>Аналогічно, другий рукав зіставляє будь-яку точку на осі <code>y</code>, вказуючи, що поле <code>x</code> збігається, якщо його значення дорівнює <code>0</code>, і створює змінну <code>y</code> для значення поля <code>y</code>. Третій рукав не визначає ніяких літералів, тому воно відповідає будь-якій іншій <code>Point</code> і створює змінні для полів <code>x</code> і <code>y</code>.</p>
<p>У цьому прикладі значення <code>p</code> збігається з другим рукавом, оскільки <code>x</code> містить 0, тому цей код виведе в консолі <code>On the y axis at 7</code>.</p>
<p>Пам'ятайте, що вираз <code>match</code> припиняє перевірку рукавів після того, як знайде перший збіг, тому навіть якщо <code>Point { x: 0, y: 0}</code> знаходиться як на осі <code>x</code>, так і на осі <code>y</code>, цей код виведе в консолі <code>On the x axis at 0</code>.</p>
<h4 id="Деструктуризація-Енумів"><a class="header" href="#Деструктуризація-Енумів">Деструктуризація Енумів</a></h4>
<p>У цій книзі ми вже деструктурували енуми (наприклад, в Блоці Коду 6-5 Розділу 6), але ми ще окремо не обговорювали, що шаблон деструктурування енума повинен відповідати тому, як визначаються збережені в енумі дані. Як приклад, у Блоці Коду 18-15 ми використовуємо енум <code>Message</code> з Блоку Коду 6-2 і пишемо <code>match</code> з шаблонами, які деструктуруватимуть кожне внутрішнє значення.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x, y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; println!(
            &quot;Change the color to red {}, green {}, and blue {}&quot;,
            r, g, b
        ),
    }
}
</code></pre></pre>
<p><span class="caption">Блок Коду 18-15: Деструктурування варіантів енума, що містять різні види значень</span></p>
<p>Цей код виведе в консолі <code>Change the color to red 0, green 160, and blue 255</code>. Спробуйте змінити значення <code>msg</code>, щоб побачити виконання коду з інших рукавів.</p>
<p>Для варіантів енуму без даних, таких як <code>Message::Quit</code>, ми не можемо деструктурувати значення далі. Ми тільки можемо зіставити буквальне значення <code>Message::Quit</code>, і жодних змінних у цьому шаблоні немає.</p>
<p>Для структуро-подібних варіантів енуму, таких як <code>Message::Move</code>, ми можемо використовувати шаблон схожий з тим, що ми вказували для зіставлення структур. Після назви варіанту ми ставимо фігурні дужки, а потім перелічуємо поля зі змінними, щоб розбити все на частини, які будуть використані в коді для цього рукава. Тут ми використовуємо скорочену форму, як ми це робили в Блоці Коду 18-13.</p>
<p>Шаблони кортежо-подібних варіантів енума, таких як <code>Message::Write</code>, що містить кортеж з одним елементом, і <code>Message::ChangeColor</code>, що містить кортеж з трьома елементами подібні до шаблону, який ми вказуємо для зіставлення кортежів. Кількість змінних у шаблоні повинна відповідати кількості елементів у варіанті, який ми порівнюємо.</p>
<h4 id="Деструктуризація-Вкладених-Структур-та-Енумів"><a class="header" href="#Деструктуризація-Вкладених-Структур-та-Енумів">Деструктуризація Вкладених Структур та Енумів</a></h4>
<p>Дотепер всі наші приклади стосувалися зіставлення структур або енумів глибиною в один рівень, але зіставлення може працювати і на вкладених елементах! Наприклад, ми можемо переробити код у Блоці Коду 18-15 для додавання підтримки RGB та HSV кольорів у повідомленні <code>ChangeColor</code>, як показано у Блоці Коду 18-16.</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; println!(
            &quot;Change the color to red {}, green {}, and blue {}&quot;,
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; println!(
            &quot;Change the color to hue {}, saturation {}, and value {}&quot;,
            h, s, v
        ),
        _ =&gt; (),
    }
}
</code></pre></pre>
<p><span class="caption">Блок Коду 18-16: Зіставлення з вкладеними енумами</span></p>
<p>Шаблон першого рукава у виразі <code>match</code> відповідає варіанту енуму <code>Message::ChangeColor</code>, який містить варіант <code>Color::Rgb</code>; потім шаблон зв'язується з трьома внутрішніми значеннями <code>i32</code>. Шаблон другого рукава також відповідає варіанту енуму <code>Message::ChangeColor</code>, але внутрішній енум замість цього збігається з <code>Color::Hsv</code>. Ми можемо вказувати такі складні умови в одному виразі <code>match</code>, навіть якщо залучені два енуми.</p>
<h4 id="Деструктуризація-Структур-та-Кортежів"><a class="header" href="#Деструктуризація-Структур-та-Кортежів">Деструктуризація Структур та Кортежів</a></h4>
<p>Ми можемо змішувати, зіставляти та вкладати деструктуризуючі шаблони і складнішими способами. В наступному прикладі показано складна деструктуризація, де ми вкладаємо структури та кортежі в кортеж та деструктуризуємо все примітивні значення:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<p>Цей код дозволяє нам розбивати складні типи на складові частини, щоб ми могли окремо використовувати потрібні нам значення.</p>
<p>Деструктуризація за допомогою шаблонів є зручним способом використання фрагментів значень, таких як значення з кожного поля в структурі, окремо один від одного.</p>
<h3 id="Ігнорування-Значень-Шаблона"><a class="header" href="#Ігнорування-Значень-Шаблона">Ігнорування Значень Шаблона</a></h3>
<p>Ви бачили, що іноді корисно ігнорувати значення в шаблоні, наприклад в останньому рукаві <code>match</code>, щоб отримати загальний шаблон, який не робить деструктуризації, але враховує всі можливі значення, що залишилися. Існує декілька способів ігнорувати цілі значення або частини значень у шаблоні: використання шаблону <code>_</code> (який ви вже бачили), використання шаблону <code>_</code> всередині іншого шаблону, використання імені, яке починається з символу підкреслення, або використання <code>..</code> для ігнорування решти частини значення. Розглянемо, як і навіщо використовувати кожен з цих шаблонів.</p>
<h4 id="Ігнорування-цілого-значення-з-_-_"><a class="header" href="#Ігнорування-цілого-значення-з-_-_">Ігнорування цілого значення з _ <code>_</code></a></h4>
<p>Ми використали символ підкреслення як загальний шаблон, який буде відповідати будь-якому значенню, але не прив'язуватиметься до нього. Це особливо корисно як останній рукав виразу <code>match</code>, але ми також можемо використовувати його в будь-якому шаблоні, включно з параметрами функцій, як показано в Блоці Коду 18-17.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<p><span class="caption">Блок Коду 18-17: Використання <code>_</code> в сигнатурі функції</span></p>
<p>Цей код повністю проігнорує значення <code>3</code>, передане першим аргументом, і виведе <code>Даний код використовує тільки y параметр: 4</code>.</p>
<p>У більшості випадків, коли вам більше не потрібен певний параметр функції, ви змінили б підпис так, щоб він не включав невикористаний параметр. Ігнорування параметру функції може бути особливо корисним у випадках, коли, наприклад, ви реалізуєте трейт і вам потрібна сигнатура певного типу, але тіло функції у вашій реалізації не потребує жодного з параметрів. Ви тоді уникаєте попередження компілятора про невикористані параметри функції, яке було б у випадку використання назви.</p>
<h4 id="Ігнорування-Частин-Значення-з-Вкладеним-_"><a class="header" href="#Ігнорування-Частин-Значення-з-Вкладеним-_">Ігнорування Частин Значення з Вкладеним <code>_</code></a></h4>
<p>Ми також можемо використовувати <code>_</code> всередині іншого шаблону, щоб ігнорувати тільки частину значення, наприклад, коли ми хочемо перевірити тільки частину значення, але не використовуємо інші частини у відповідному коді, який ми хочемо виконати. У Блоці Коду 18-18 наведено код що відповідає за керування значенням налаштувань. Бізнес-вимоги полягають в тому, що користувачеві не повинно бути дозволено перезаписувати існуюче задане налаштування, але користувач може скасувати налаштування та надати йому значення, якщо воно наразі не задане.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;Can't overwrite an existing customized value&quot;);
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!(&quot;setting is {:?}&quot;, setting_value);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок Коду 18-18: Використання підкреслення всередині шаблонів, які відповідають варіантам <code>Some</code>, коли нам не потрібно використовувати значення всередині <code>Some</code> варіанту</span></p>
<p>Цей код виведе <code>Неможливо перезаписати існуюче користувацьке значення</code>, а потім <code>налаштування це Some(5)</code>. У першому рукаві match нам не потрібно зіставляти або використовувати значення всередині будь-якого з варіантів <code>Some</code>, але нам потрібно перевірити випадок, коли <code>setting_value</code> і <code>new_setting_value</code> є варіантом <code>Some</code>. У цьому випадку ми виводимо причину незмінності <code>setting_value</code>, і воно не зміниться.</p>
<p>У всіх інших випадках (якщо або <code>setting_value</code>, або <code>new_setting_value</code> є <code>None</code>), виражених шаблоном <code>_</code> у другому плечі, ми хочемо дозволити <code>new_setting_value</code> стати <code>setting_value</code>.</p>
<p>Ми також можемо використовувати підкреслення в декількох місцях в межах одного шаблону, щоб ігнорувати певні значення. У Блоку Коду 18-19 наведено приклад ігнорування другого та четвертого значень у кортежі з п'яти елементів.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!(&quot;Some numbers: {first}, {third}, {fifth}&quot;)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок Коду 18-19: Ігнорування кількох частин кортежу</span></p>
<p>Цей код виведе <code>Деякі числа: 2, 8, 32</code>, а значення 4 та 16 будуть проігноровані.</p>
<h4 id="Ігнорування-Невикористаної-Змінної-Починаючи-її-Назву-з-_"><a class="header" href="#Ігнорування-Невикористаної-Змінної-Починаючи-її-Назву-з-_">Ігнорування Невикористаної Змінної, Починаючи її Назву з <code>_</code></a></h4>
<p>Якщо ви створюєте змінну, але ніде її не використовуєте, Rust зазвичай попередить про це, оскільки невикористана змінна може бути помилкою. Однак, іноді буває корисно мати можливість створити змінну, яку ви поки що не будете використовувати, наприклад, коли ви створюєте прототип або тільки починаєте проєкт. У цій ситуації ви можете заборонити Rust попереджати вас про невикористану змінну, почавши назву змінної з символу підкреслення. У Боку Коду 18-20 ми створюємо дві невикористовувані змінні, але при компіляції цього коду ми повинні отримати попередження лише про одну з них.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><span class="caption">Блок Коду 18-20: Початок назви змінної з символу підкреслення, щоб уникнути попередження про невикористані змінні</span></p>
<p>Тут ми отримуємо попередження про невикористання змінної <code>y</code>, але не отримуємо попередження про невикористання <code>_x</code>.</p>
<p>Зверніть увагу, що існує тонка різниця між використанням тільки <code>_</code> і використанням імені яке починається з підкреслення. Синтаксис <code>_x</code> все ще прив'язує значення до змінної тоді як <code>_</code> не прив'язує взагалі. Щоб показати випадок, коли ця відмінність має значення, в Блоці Коду 18-21 ми наведемо помилку.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    if let Some(_s) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre>
<p><span class="caption">Блок Коду 18-21: Невикористана змінна, що починається з підкреслення все ще прив'язує значення, що може отримати над ним володіння</span></p>
<p>Ми отримаємо помилку, тому що значення <code>s</code> однаково буде переміщено в <code>_s</code>, що не дозволить нам використовувати <code>s</code> знову. Однак, використання символу підкреслення самого по собі ніколи не призведе до прив'язки до значення. Блок Коду 18-22 скомпілюється без помилок тому що <code>s</code> не переміщується в <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    if let Some(_) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок Коду 18-22: Використання символу підкреслення не прив'язує значення</span></p>
<p>Цей код працює, оскільки ми ніколи та ні до чого не прив'язували <code>s</code>; воно не зміщене.</p>
<h4 id="Ігнорування-Інших-Частин-Значення-з-"><a class="header" href="#Ігнорування-Інших-Частин-Значення-з-">Ігнорування Інших Частин Значення з <code>..</code></a></h4>
<p>Для значень, які мають багато частин, ми можемо використовувати синтаксис <code>..</code>, щоб використовувати певні частини та ігнорувати решту, уникаючи необхідності підкреслення кожного ігнорованого значення. Шаблон <code>..</code> ігнорує будь-які частини значення, які ми не зіставили явно в інших частинах шаблону. У Блоці Коду 18-23 ми маємо структуру <code>Point</code>, яка зберігає координату в тривимірному просторі. У виразі <code>match</code> ми хочемо оперувати тільки координатою <code>x</code> і ігнорувати значення в полях <code>y</code> та <code>z</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок Коду 18-23: Ігнорування всіх полів <code>Point</code> крім для <code>x</code> з використанням <code>..</code></span></p>
<p>Ми перераховуємо значення <code>x</code>, а потім просто додаємо шаблон <code>..</code>. Це швидше. ніж перераховувати <code>y: _</code> і <code>z: _</code>, особливо коли ми працюємо зі структурами, які мають багато полів, в ситуаціях, коли тільки одне або два поля є релевантними.</p>
<p>Синтаксис <code>..</code> буде поширюватися на стільки значень, скільки потрібно. У Блоці Коду 18-24 показано, як використовувати <code>..</code> з кортежем.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {first}, {last}&quot;);
        }
    }
}
</code></pre></pre>
<p><span class="caption">Блок Коду 18-24: Порівняння тільки першого та останнього значень кортежу та ігнорування усіх інших значень</span></p>
<p>У цьому коді першому та останньому значенню відповідають <code>first</code> та <code>last</code>. <code>..</code> буде зіставлятися та ігнорувати зі всім посередині.</p>
<p>Однак використання <code>..</code> має бути однозначним. Якщо незрозуміло, які значення призначені для зіставлення, а які слід ігнорувати, Rust видасть помилку. У Блоці Коду 18-25 наведено приклад неоднозначного використання <code>..</code>, тому він не буде компілюватися.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre>
<p><span class="caption">Блок Коду 18-25: Спроба використання <code>..</code> неоднозначним способом</span></p>
<p>Якщо ми скомпілюємо цей приклад, ми отримаємо цю помилку:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` due to previous error
</code></pre>
<p>Rust не може визначити, скільки значень у кортежі слід ігнорувати, перш ніж знайти значення з <code>second</code>, а потім скільки наступних значень слід ігнорувати після цього. Цей код може означати, що ми хочемо ігнорувати <code>2</code>, пов'язати <code>second</code> з <code>4</code>, а потім ігнорувати <code>8</code>, <code>16</code> та <code>32</code>; або що ми хочемо ігнорувати <code>2</code> і <code>4</code>, зв'язати <code>second</code> з <code>8</code>, а потім ігнорувати <code>16</code> і <code>32</code>; тощо. Назва змінної <code>second</code> нічого особливого для Rust не означає, тому ми отримуємо помилку компілятора, тому що використання <code>..</code> в двох таких місцях є неоднозначним.</p>
<h3 id="Додаткові-Умови-з-Запобіжниками-Зіставлення"><a class="header" href="#Додаткові-Умови-з-Запобіжниками-Зіставлення">Додаткові Умови з Запобіжниками Зіставлення</a></h3>
<p><em>Запобіжник match</em> є додатковою умовою <code>if</code>, зазначеною після шаблону в рукаві <code>match</code>, яка також повинна збігатися для того, щоб цей рукав було обрано. Запобіжники match корисні для вираження складніших ідей, ніж дозволяє один тільки шаблон.</p>
<p>В умові можуть використовуватись змінні, створені в шаблоні. У Блоці Коду 18-26 показано <code>match</code>, де перший рукав має шаблон <code>Some(x)</code>, а також має запобіжник match <code>if x % 2 == 0</code> (що буде істинним, якщо число парне).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!(&quot;The number {} is even&quot;, x),
        Some(x) =&gt; println!(&quot;The number {} is odd&quot;, x),
        None =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок Коду 18-26: Додавання запобіжника зіставлення до шаблона</span></p>
<p>Цей приклад виведе в консолі <code>The number 4 is even</code>. Коли <code>num</code> порівнюється з у першому рукаві, вони збігаються, оскільки <code>Some(4)</code> збігається з <code>Some(x)</code>. Потім запобіжник match перевіряє, чи залишок від ділення <code>x</code> на 2 дорівнює 0, і якщо це так, то вибирається перший рукав.</p>
<p>Якби замість <code>num</code> було <code>Some(5)</code>, то запобіжник match у першому рукаві був би хибним, оскільки остача від ділення 5 на 2 дорівнює 1, що не дорівнює 0. Rust потім перейде до другого рукава, який збігатиметься, тому що другий рукав не має запобіжника match і тому збігається з будь-яким варіантом <code>Some</code>.</p>
<p>Немає можливості виразити умову <code>if x % 2 == 0</code> в шаблоні, тому запобіжник дає можливість виразити цю логіку. Недоліком цієї додаткової виразності є те, що компілятор не намагатиметься перевіряти на вичерпність, коли задіяні вирази запобіжнику match.</p>
<p>У Блоці Коду 18-11 ми згадували, що могли б використовувати запобіжники match для вирішення нашої проблему тінізації шаблонів. Нагадаємо, що ми створили нову змінну всередині шаблону у виразі <code>match</code> замість того, щоб використовувати змінну за межами <code>match</code>. Ця нова змінна означала, що ми не могли перевіряти значення зовнішньої змінної. У Блоці Коду 18-27 показано, як ми можемо використовувати запобіжник match, щоб розв'язати цю проблему.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {n}&quot;),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {y}&quot;, x);
}
</code></pre></pre>
<p><span class="caption">Блок Коду 18-27: Використання запобіжника match для перевірки рівності із зовнішньою змінною</span></p>
<p>Цей код виведе в консолі <code>Default case, x = Some(5)</code>. Шаблон у другому рукаві збігу не вводить нову змінну <code>y</code>, яка б затінювала зовнішню <code>y</code>, що означає, що ми можемо використовувати зовнішню <code>y</code> у запобіжнику match. Замість того, щоб вказати шаблон як <code>Some(y)</code>, що затінило б зовнішнє <code>y</code>, ми вказуємо <code>Some(n)</code>. Це створює нову змінну <code>n</code>, яка нічого не затінює, оскільки немає змінної <code>n</code> за межами <code>match</code>.</p>
<p>Запобіжник match <code>if n == y</code> не є шаблоном і тому не вводить нових змінних. Цей <code>y</code> <em>дорівнює</em> зовнішньому <code>y</code>, а не новому затіненому <code>y</code>, і ми можемо шукати значення, яке має те саме значення, що й зовнішнє <code>y</code>, порівнюючи <code>n</code> з <code>y</code>.</p>
<p>Ви також можете використовувати <em>or</em> оператор <code>|</code> в запобіжнику match для вказування декількох шаблонів; умова запобіжнику match буде застосовуватися до всіх шаблонів. У Блоці Коду 18-28 показано черговість при об'єднанні шаблону, який використовує <code>|</code> з запобіжником match. Важливою частиною цього прикладу є те, що запобіжник match <code>if y</code> застосовується до <code>4</code>, <code>5</code>, <em>та</em> <code>6</code>, хоча це може виглядати як <code>if y</code> тільки застосовується лише до <code>6</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок Коду 18-28: Об'єднання декількох шаблонів за допомогою запобіжнику match</span></p>
<p>Умова match вказує, що рукав збігається, тільки якщо значення <code>x</code> дорівнює <code>4</code>, <code>5</code> або <code>6</code> <em>та</em> якщо <code>y</code> дорівнює <code>true</code>. При виконанні цього коду шаблон першого рукава збігається, оскільки <code>x</code> дорівнює <code>4</code>, але запобіжник збігу <code>if y</code> є хибним, тому перший рукав не обирається. Код переходить на другий рукав, який збігається, і ця програма виводить в консолі <code>no</code>. Причина в тому, що умова <code>if</code> застосовується до всього шаблону <code>4 | 5 | 6</code>, а не тільки до останнього значення <code>6</code>. Іншими словами, черговість запобіжнику match відносно шаблону наступна:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>замість:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>Після виконання коду, поведінка пріоритету очевидна: якби запобіжник match був застосований тільки до кінцевого значення в списку значень, заданих з допомогою оператора <code>|</code>, то рукав збігся б і програма вивела б <code>yes</code>.</p>
<h3 id="-звязування"><a class="header" href="#-звязування"><code>@</code> зв'язування</a></h3>
<p><code>@</code>, що вимовляється &quot;оператор <em>at</em>&quot;, дозволяє нам створити змінну, яка містить значення, у той час, коли ми перевіряємо значення на відповідність шаблону. У Блоці коду 18-29 ми хочемо перевірити, що поле <code>id</code> у <code>Message::Hello</code> є в межах <code>3..=7</code>. Ми також хочемо зв'язати значення зі змінною <code>id_variable</code>, щоб ми могли використати її у коді рукава. Ми могли назвати цю змінну <code>id</code>, так само як і поле, але для цього прикладу ми використаємо іншу назву.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;Found an id in range: {}&quot;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;Found an id in another range&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;Found some other id: {}&quot;, id),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 18-29: використання <code>@</code> для зв'язування зі значенням у шаблоні і водночас перевірки</span></p>
<p>Цей приклад виведе в консолі <code>Found an id in range: 5</code>. Зазначивши <code>id_variable @</code> перед інтервалом <code>3..=7</code> ми захоплюємо будь-яке значення, що відповідає інтервалу, перевіряючи при цьому, що значення відповідає шаблону.</p>
<p>У другому рукаві, де є лише інтервал, зазначений у шаблоні, код, асоційований з цим рукавом, не має змінної, яка містила б фактичне значення поля <code>id</code>. Значення поля <code>id</code> могло б бути 10, 11, або 12, але код, що йде з цим шаблоном, не знає, яким воно є. Код шаблону нездатний використати значення поля <code>id</code>, оскільки ми не зберегли значення <code>id</code> у змінній.</p>
<p>В останньому рукаві, де ми вказали змінну без інтервалу, ми маємо значення, доступне для використання в коді рукава, в змінній з назвою <code>id</code>. Це тому, що ми скористалися скороченим синтаксисом поля структури. Але ми не застосували жодної перевірки для поля <code>id</code> у цьому рукаві, як робили у двох перших рукавах: будь-яке значення відповідає цьому шаблону.</p>
<p>Використання <code>@</code> дозволяє нам перевірити значення і зберегти його в змінній в одному шаблоні.</p>
<h2 id="Підсумок-17"><a class="header" href="#Підсумок-17">Підсумок</a></h2>
<p>Шаблони в Rust дуже корисні для розрізнення між різновидами даних. При використанні у виразах <code>match</code> Rust гарантує, що ваші шаблони покривають усі можливі значення, бо інакше ваша програма не скомпілюється. Шаблони в інструкціях <code>let</code> і параметрах функцій роблять ці конструкції кориснішими, дозволяючи деструктуризацію значень на менші частини одночасно з що присвоєнням їх змінним. Ми можемо створювати прості або складні шаблони відповідно до наших потреб.</p>
<p>Далі, у передостанньому розділі книжки ми подивимося на деякі розширені аспекти низки функціоналів Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Просунутий-функціонал"><a class="header" href="#Просунутий-функціонал">Просунутий функціонал</a></h1>
<p>Наразі, ви вже вивчили найуживаніші частини мови програмування Rust. Перш ніж ми реалізуємо ще один проект у Розділі 20, ми розглянемо кілька аспектів мови, з якими ви будете стикатися час від часу, але не використовуватимете їх на постійній основі. Ви можете використовувати цей розділ як довідник, коли ви зіткнетеся з чимось невідомим. Описаний тут функціонал корисний в дуже специфічних ситуаціях. Хоча ви, ймовірно, не будете користуватися ним часто, ми хочемо переконатися, що ви добре розумієте всі можливості, які пропонує Rust.</p>
<p>В цьому розділі, ми розглянемо:</p>
<ul>
<li>Небезпечний Rust: як відмовитися від деяких гарантій Rust і взяти на себе відповідальність за дотримання цих гарантій</li>
<li>Просунуті трейти: асоційовані типи (associated types), параметри типу за замовчуванням, повністю кваліфікований синтаксис, шаблон нового типу (newtype) відносно трейтів</li>
<li>Просунуті типи: більше про шаблон нового типу (newtype), псевдонім типу, тип &quot;never&quot;, а також типи із динамічним розміром</li>
<li>Просунуті функції та замикання: вказівники на функції та повертаючі замикання</li>
<li>Макроси: способи визначати код, що визначає інший код в час компіляції (compile time)</li>
</ul>
<p>Це набір функціоналу Rust, де кожен знайде щось для себе! Давайте починати!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Небезпечний-rust"><a class="header" href="#Небезпечний-rust">Небезпечний Rust</a></h2>
<p>Весь код, що ми до цього моменту обговорювали, мав гарантії безпеки памʼяті, які Rust забезпечував під час компіляції. Однак, Rust має другу мову мову, сховану всередині нього, що не надає ці гарантії: вона називається <em>небезпечний Rust</em> і працює так само як і звичайний Rust, але надає додаткові суперсили.</p>
<p>Небезпечний Rust існує тому, що за своєю природою, статичний аналіз є консервативним. Коли компілятор намається визначити чи надає код потрібні гарантії, краще відхилити деякі валідні програми, ніж в подальшому скомпілювати невалідні програми. Хоча код <em>може бути</em> в порядку, якщо компілятор Rust не має достатньо інформації, щоб бути в цьому впевненим, він відхилить такий код. В таких випадках ви можете використовувати небезпечний код, щоб сказати компілятору, &quot;Довірся мені, я знаю що роблю&quot;. Однак майте на увазі, що ви використовуєте небезпечний Rust на свій страх і ризик: якщо ви неправильно використовуєте небезпечний код, можуть виникнути проблеми, повʼязані з памʼяттю, такі як розіменування нульового вказівника (null pointer).</p>
<p>Іншою причиною, чому Rust має небезпечне альтер его, є те, що саме комп'ютерне обладнання є небезпечним за своєю суттю. Якби Rust не дозволяв вам виконувати небезпечні операції, ви не могли б виконувати певні завдання. Rust вимушений дозволити вам низькорівневе системне програмування, таке як пряму взаємодію з операційною системою чи навіть написання власної операційної системи. Робота з низькорівневим системним програмуванням є однією з цілей мови. Дослідимо, що ми можемо зробити з небезпечним Rust і як це зробити.</p>
<h3 id="Небезпечні-суперсили"><a class="header" href="#Небезпечні-суперсили">Небезпечні суперсили</a></h3>
<p>Щоб перейти до небезпечного Rust, скористайтеся ключовим словом <code>unsafe</code> і почніть новий блок, що містить небезпечний код. Ви можете робити п'ять дій в небезпечному Rust, які не можна робити в безпечному Rust, який ми називаємо <em>небезпечними суперсилами</em>. Ці суперсили охоплюють такі можливості:</p>
<ul>
<li>Розіменування сирого вказівника</li>
<li>Виклик небезпечної функції або методу</li>
<li>Доступ або модифікація мутабельних статичних змінних</li>
<li>Реалізація небезпечного трейта</li>
<li>Доступ до полів <code>union</code></li>
</ul>
<p>Важливо розуміти, що <code>unsafe</code> не вимикає перевірку позик чи відключає будь-які перевірки безпеки Rust: якщо ви використовуєте посилання в небезпечному коді, його все одно буде перевірено. Ключове слово <code>unsafe</code> лише надає доступ до цих п'яти можливостей, які потім не перевіряються компілятором на безпечність використання пам'яті. Ви, як і раніше, маєте певний ступінь безпеки всередині небезпечного блоку.</p>
<p>Крім того, <code>unsafe</code> не означає, що код усередині блоку обов'язково створює небезпеку чи точно матиме проблеми з безпекою пам'яті: передбачається, що ви, як програміст, гарантуєте, що код всередині блоку <code>unsafe</code> буде працювати з пам'яттю коректно.</p>
<p>Люди роблять помилки, але вимога, щоб ці п'ять небезпечних операцій були в блоках, позначених як <code>unsafe</code>, дає вам знати, що помилки, пов'язані з безпекою пам'яті, мають бути якомусь із таких блоків <code>unsafe</code>. Хай блоки <code>unsafe</code> будуть якомога меншими; ви будете вдячні пізніше, коли будете досліджувати помилки в пам'яті.</p>
<p>Для ізоляції небезпечного коду, наскільки це можливо, найкраще розміщати небезпечний код у безпечній абстракції та надавати безпечний API, про що ми поговоримо пізніше в цьому розділі, коли розберемо небезпечні функції та методи. Частини стандартної бібліотеки реалізовані як безпечні абстракції навколо небезпечного коду, що пройшов перевірку. Обгортання небезпечного коду в безпечну абстракцію запобігає необхідності використовувати <code>unsafe</code> у всіх місцях, де ви або ваші користувачі можуть захотіти використати функціонал, реалізований за допомогою <code>unsafe</code>, тому що використання безпечної абстракції є безпечним.</p>
<p>Подивімося на кожну з п'яти небезпечних суперсил по черзі. Ми також подивимося на деякі абстракції, що надають безпечний інтерфейс для небезпечного коду.</p>
<h3 id="Розіменування-сирого-вказівника"><a class="header" href="#Розіменування-сирого-вказівника">Розіменування сирого вказівника</a></h3>
<p>У Розділі 4, підрозділі <a href="">&quot;Підвішені посилання&quot;</a><!-- ignore
--> , ми згадували, що компілятор гарантує, що посилання є завжди коректними. Небезпечний Rust має два нові типи під назвою </p>
<p><em>сирі вказівники</em>, схожі на посилання. Як і з посиланнями, сирі вказівники можуть бути немутабельними або мутабельними і записуються як <code>*const T</code> і <code>*mut T</code> відповідно. Зірочка тут не є оператором розіменування; це частина назви типу. У контексті сирих вказівників, <em>немутабельність</em> означає, що вказівнику не можна присвоїти значення після розіменування.</p>
<p>На відміну від посилань і розумних вказівників, сирі вказівники:</p>
<ul>
<li>Можуть ігнорувати правила позичання, маючи як немутабельні, так і мутабельні вказівники або декілька мутабельних вказівників на одне місце</li>
<li>Не гарантують, що вказують на коректну пам'ять</li>
<li>Можуть бути null</li>
<li>Не реалізовують жодного автоматичного очищення</li>
</ul>
<p>Відмовляючись від цих гарантій Rust, ви поступаєтеся гарантованою безпекою в обмін на вищу продуктивність чи здатність взаємодії з іншою мовою чи обладнянням, які не забезпечують гарантій Rust.</p>
<p>Блок коду 19-1 показує, як створити немутабельний і мутабельний сирі вказівники з посилання.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 19-1: Створення сирих вказівників із посилань</span></p>
<p>Зверніть увагу, що ми не включаємо в цей код ключове слово <code>unsafe</code>. Ми можемо створювати сирі вказівники у безпечному коді; ми не можемо лише розіменовувати сирі вказівники поза блоками unsafe, як ви зараз побачите.</p>
<p>Ми створили сирі вказівники за допомогою  <code>as</code>, щоб перетворити немутабельне і мутабельне посилання у відповідні типи сирих вказівників. Оскільки ми створили їх безпосередньо з посилань, які є гарантовано коректними, ми знаємо, що ці конкретні сирі вказівники є коректними, але ми не можемо робити таке припущення про довільні сирі вказівники.</p>
<p>Щоб продемонструвати це, дали ми створимо сирий вказівник, у коректності якого ми не можемо бути певними. Блок коду 19-2 показує, як створити сирий вказівник до довільного місця у пам'яті. Спроба використання довільної пам'яті є невизначеною операцією: за вказаною адресою можуть бути дані або ні, компілятор може оптимізувати код, прибравши доступ до пам'яті, або програма може завершитися з помилкою сегментації. Зазвичай немає жодної причини писати подібний код, але це можливо.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 19-2: Створення сирого вказівника на довільну адресу памʼяті</span></p>
<p>Пригадайте, що ми можемо створювати сирі вказівники в безпечному коді, але ми не можемо <em>розіменовувати</em> сирі вказівники і читати дані, на які вони вказують. У Блоці коду 19-3 ми використовуємо оператор розіменування <code>*</code> на сирому вказівнику, що потребує блоку <code>unsafe</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    unsafe {
        println!(&quot;r1 is: {}&quot;, *r1);
        println!(&quot;r2 is: {}&quot;, *r2);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 19-3: Розіменування сирого вказівника в блоці <code>unsafe</code></span></p>
<p>Створення вказівника не може нашкодити; лише тоді, коли ми намагаємося отримати доступ до значення, на яке він указує, ми можемо отримати в результаті некоректне значення.</p>
<p>Зауважте, що у Блоках коду 19-1 і 19-3 ми створили сирі вказівники <code>*const i32</code> і <code>*mut i32</code>, які обидва вказують на те саме місце в пам'яті, де зберігається <code>num</code>. Якби ми натомість спробували створити немутабельне і мутабельне посилання на <code>num</code>, код би не скомпілювався, бо правила володіння Rust забороняють мати мутабельне посилання одночасно з немутабельними посиланнями. З сирими вказівниками ми можемо створити мутабельний і немутабельний вказівники на одне й те саме місце і змінити дані через мутабельний вказівник, потенційно створивши гонитву даних. Будьте обережні!</p>
<p>З усіма цими небезпеками, нащо вам узагалі потрібні сирі вказівники? Одним з основних застосувань є взаємодія з кодом С, як ви побачите в наступному розділі, <a href="ch19-01-unsafe-rust.html#calling-an-unsafe-function-or-method">&quot;Виклик небезпечної функції або Методу.&quot;</a><!-- ignore --> Інший сценарій використання - побудова безпечної абстракції, яку borrow checker не розуміє. Ми представимо небезпечні функції, а потім подивимося на приклад безпечної абстракції, яка використовує небезпечний код.</p>
<h3 id="Виклик-небезпечної-функції-або-методу"><a class="header" href="#Виклик-небезпечної-функції-або-методу">Виклик небезпечної функції або методу</a></h3>
<p>Другий тип операцій, які ви можете виконувати в блоці unsafe - це виклик небезпечних функцій. Небезпечні функції та методи виглядають точно як звичайні функції та методи, але мають додаткове <code>unsafe</code> перед початком визначення. Ключове слово <code>unsafe</code> в цьому контексті позначає, що функція має вимоги, яких ми маємо дотримуватися при виклику цієї функції, бо Rust не може гарантувати виконання цих вимог. Викликаючи небезпечну функцію в межах блоку <code>unsafe</code>, ми заявляємо, що читали документацію цієї функції і беремо на себе відповідальність за дотримання контрактів функції.</p>
<p>Ось небезпечна функція з назвою <code>dangerous</code> яка не робить нічого в своєму тілі:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}
</span></code></pre></pre>
<p>Ми маємо викликати функцію <code>dangerous</code> з окремого блоку <code>unsafe</code>. Якщо ми спробуємо викликати <code>dangerous</code> без блоку <code>unsafe</code>, то отримаємо помилку:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<p>Блоком <code>unsafe</code> ми запевняємо Rust, що ми прочитали документацію функції, розуміємо, як її правильно використовувати, і ми підтверджуємо, що виконуємо контракт функції.</p>
<p>Тіла небезпечних функцій є фактично блоками <code>unsafe</code>, таким чином, щоб виконати інші небезпечні операції в небезпечній функції, нам не потрібно додавати ще один блок <code>unsafe</code>.</p>
<h4 id="Створення-безпечної-абстракції-над-небезпечним-кодом"><a class="header" href="#Створення-безпечної-абстракції-над-небезпечним-кодом">Створення безпечної абстракції над небезпечним кодом</a></h4>
<p>Те, що функція містить небезпечний код, не означає, що нам потрібно позначити всю функцію як небезпечну. Насправді обгортання небезпечного коду в безпечну функцію є звичайною абстракцією. Як приклад, розглянемо функцію <code>split_at_mut</code> зі стандартної бібліотеки, якій потрібен небезпечний код для роботи. Ми дослідимо, як ми можемо її реалізувати. Цей безпечний метод визначено на мутабельних слайсах: він бере слайс і робить з нього два, ділячи слайс по індексу, заданому аргументом. Блок коду 19-4 показує, як використовувати <code>split_at_mut</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 19-4: Використання безпечної функції <code>split_at_mut</code></span></p>
<p>Ми не можемо реалізувати цю функцію за допомогою лише безпечного Rust. Спроба може бути дещо схожою на Блок коду 19-5, але вона не компілюється. Для простоти, ми реалізуємо <code>split_at_mut</code> як функцію, а не метод, і тільки для слайсів значень <code>i32</code> замість узагальненого типу <code>T</code>.</p>
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 19-5: спроба реалізації <code>split_at_mut</code> за допомогою лише безпечного Rust</span></p>
<p>Функція спочатку отримує загальну довжину слайса. Потім стверджує, що індекс, заданий параметром, знаходиться в слайсі, перевіривши, що він менший чи дорівнює довжині. Твердження означає, що якщо ми передамо індекс, більший за довжину, щоб розділити по ньому слайс, функція запанікує перед спробою використати цей індекс.</p>
<p>Тоді ми повертаємо два мутабельні слайси у кортежі: один від початку вихідного слайса до індексу <code>mid</code>, і другий з <code>mid</code> до кінця слайса.</p>
<p>Коли ми спробуємо скомпілювати код в Блоці коду 19-5, ми отримаємо помилку.</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<p>Перевірка позичання Rust не розуміє, що ми позичаємо різні частини слайса; вона лише знає, що ми позичаємо з одного слайса двічі. Позичання різних частин слайса є принципово правильним, оскільки два слайси не перетинаються, але Rust недостатньо розумна, щоб знати це. Коли ми знаємо, що код не містить помилок, але Rust так не вважає, настає час долучити небезпечний код.</p>
<p>Блок коду 19-6 показує, як використовувати блок <code>unsafe</code>, сирий вказівник і деякі виклики небезпечних функцій, щоб реалізація <code>split_at_mut</code> запрацювала.</p>
<pre><pre class="playground"><code class="language-rust">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 19-6: Використання небезпечного коду у реалізації функції <code>split_at_mut</code></span></p>
<p>Згадайте з підрозділу <a href="ch04-03-slices.html#the-slice-type">&quot;Тип даних слайс&quot;</a><!-- ignore --> Розділу 4, що слайси є вказівником на певні дані і довжиною слайса. Ми використовуємо метод <code>len</code>, щоб отримати довжину слайса, і метод <code>as_mut_ptr</code>, щоб отримати сирий вказівник зі слайса. У цьому випадку, оскільки ми маємо мутабельний слайс зі значень <code>i32</code>, <code>as_mut_ptr</code> повертає сирий вказівник типу <code>*mut i32</code>, який ми зберігаємо у змінній <code>ptr</code>.</p>
<p>Ми зберігаємо твердження, що індекс <code>mid</code> знаходиться у межах слайса. Далі ми дістаємося небезпечного коду: функція <code>slice::from_raw_parts_mut</code> приймає сирий вказівник і довжину, і створює слайс. Ми використовуємо цю функцію для створення слайса, що починається з <code>ptr</code> має довжину <code>mid</code> елементів. Тоді ми викликаємо метод <code>add</code> для <code>ptr</code> з <code>mid</code> як аргументом, щоб отримати сирий вказівник, що починається з <code>mid</code>, і створюємо слайс за допомогою цього вказівника і числа елементів, що залишилися після <code>mid</code>, як довжини.</p>
<p>Функція <code>slice::from_raw_parts_mut</code> є небезпечною, бо приймає сирий вказівник і має покладатися на те, що цей вказівник є коректним. Метод <code>add</code> для сирих вказівників також є небезпечним, бо має покладатися на те, що місце зсуву також є коректним вказівником. Саме тому ми маємо поставити блок <code>unsafe</code> навколо наших викликів <code>slice::from_raw_parts_mut</code> і <code>add</code>, щоб ми могли їх викликати. Поглянувши на код і додавши твердження, що <code>mid</code> має бути меншим або рівним <code>len</code>, ми можемо сказати що всі сирі вказівники, що використовуються в блоці <code>unsafe</code>, будуть коректними вказівниками на дані в межах слайса. Це є прийнятним і доречним використанням <code>unsafe</code>.</p>
<p>Зверніть увагу, що нам не потрібно позначати остаточну функцію <code>split_at_mut</code> як <code>unsafe</code>, і ми можемо викликати цю функцію з безпечного Rust. Ми створили безпечну абстракція для небезпечного коду з реалізацією функції, які використовує код <code>unsafe</code> у безпечний спосіб, тому що він створює тільки коректні вказівники з даних, до яких ця функція має доступ.</p>
<p>Натомість використання <code>slice::from_raw_parts_mut</code> у Блоці коду 19-7, схоже, призведе до падіння при використанні слайса. Цей код бере довільне місце в пам'яті і створює слайс довжиною 10 000 елементів.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 19-7: створення слайса з довільного розташування в пам'яті</span></p>
<p>Ми не володіємо пам'яттю у цьому довільному місці, і немає гарантії, що слайс, створений цим кодом, містить коректні значення <code>i32</code>. Спроба використання <code>values</code>, ніби це коректний слайс, призводить до невизначеної поведінки.</p>
<h4 id="Використання-extern-функцій-для-виклику-зовнішнього-коду"><a class="header" href="#Використання-extern-функцій-для-виклику-зовнішнього-коду">Використання <code>extern</code> функцій для виклику зовнішнього коду</a></h4>
<p>Іноді вашому коду Rust потрібно взаємодіяти з кодом, написаним іншою мовою. Для цього Rust має ключове слово <code>extern</code>, яке полегшує створення і використання <em>Інтерфейсу Зовнішніх Функцій (Foreign Function Interface, FFI)</em>. FFI - це засіб мови програмування для визначення функцій і дозволу іншій (зовнішній) мові програмування викликати ці функції.</p>
<p>Блок коду 19-8 демонструє, як налаштувати інтеграцію із функцією <code>abs</code> зі стандартної бібліотеки C. Функції, проголошені в блоках <code>extern</code>, завжди є небезпечними для виклику з коду Rust. Причина в тому, що інші мови не забезпечують правила і гарантії Rust, і Rust не може перевірити їх, тож відповідальність за гарантування безпеки покладається на програміста.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<p><span class="caption">Блок коду 19-8: проголошення і виклик зовнішньої (<code>extern</code>) функції, написаної іншою мовою</span></p>
<p>У блоці <code>extern &quot;C&quot;</code>, ми перелічуємо назви і сигнатури зовнішніх функцій з іншої мови, які ми хочемо викликати. Частина <code>&quot;C&quot;</code> визначає, який <em>двійковий інтерфейс застосунку (application binary interface, ABI)</em> використовується зовнішньою функцією: ABI визначає спосіб виклику функції на рівні асемблера. ABI <code>&quot;C&quot;</code> є найпоширенішим і відповідає ABI мови програмування C.</p>
<blockquote>
<h4 id="Виклик-функцій-rust-з-інших-мов"><a class="header" href="#Виклик-функцій-rust-з-інших-мов">Виклик функцій Rust з інших мов</a></h4>
<p>Ми також можемо скористатися <code>extern</code>, щоб створити інтерфейс, що дозволяє іншим мовам викликати функції Rust. Замість створення цілого блоку <code>extern</code>, додамо ключове слово <code>extern</code> і зазначимо ABI, який треба використовувати перед ключовим словом <code>fn</code> у відповідної функції. Нам також треба додати анотацію <code>#[no_mangle]</code>, щоб сказати компілятору Rust не перетворювати назву цієї функції. <em>Перетворення (mangling)</em> - це коли компілятор змінює назву, яку ми дали функції, на іншу назву, яка містить більше інформації для інших частин процесу компіляції, але є менш зручною для людини. Кожен компілятор мови програмування дещо по-різному перетворює назви, тому для того, щоб функцію Rust можна було назвати в інших мовах, ми маємо відключити перетворення назв компілятором Rust.</p>
<p>У наступному прикладі ми робимо функцію <code>call_from_c</code> доступною з C після того, як вона буде скомпільована у спільну бібліотеку та злінкована з C:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Використання <code>extern</code> не вимагає використання <code>unsafe</code>.</p>
</blockquote>
<h3 id="Доступ-або-модифікація-мутабельних-статичних-змінних"><a class="header" href="#Доступ-або-модифікація-мутабельних-статичних-змінних">Доступ або модифікація мутабельних статичних змінних</a></h3>
<p>У цій книзі ми ще не говорили про <em>глобальні змінні</em>, які Rust підтримує, але які можуть створювати проблеми з правилами володіння Rust. Якщо два потоки отримують доступ до однієї мутабельної глобальної змінної, це може викликати гонитву даних.</p>
<p>У Rust глобальні змінні називаються <em>статичними</em> змінними. Блок коду 19-9 показує приклад визначення і використання статичної змінної зі значенням стрічкового слайсу.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p><span class="caption">Блок коду 19-9: визначення і використання немутабельної статичної змінної</span></p>
<p>Статичні змінні подібні до констант, які ми обговорювали в підрозділі <a href="">&quot;Константи&quot;</a><!-- ignore --> у Розділі 3. Назви статичних змінних за домовленістю пишуться <code>ВЕРХНІМ_РЕГІСТРОМ_З_ПІДКРЕСЛЕННЯМИ</code>. Статичні змінні можуть зберігати лише посилання з часом існування <code>'static</code>, що означає, що компілятор Rust може знайти час існування, а ми не зобов'язані анотувати його явно. Доступ до немутабельних статичних змінних є безпечним.</p>
<p>Тонка різниця між константами і немутабельними статичними змінними полягає в тому, що значення в статичній змінній має фіксовану адресу в пам'яті. Коли ви використовуєте значення, то завжди матимете доступ до тих самих даних. Константи, з іншого боку, можуть дублювати дані всюди, де їх використовують. Інша відмінність полягає в тому, що статичні змінні можуть бути мутабельними. Доступ і зміна мутабельних статичних змінних є <em>небезпечним</em>. Блок коду 19-10 показує, як проголошувати, отримувати доступ і змінювати мутабельну статичну змінну, що називається <code>COUNTER</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<p><span class="caption">Блок коду 19-10: читання і запис мутабельної статичної змінної є небезпечним</span></p>
<p>Як і зі звичайними змінними, ми визначаємо мутабельність ключовим словом <code>mut</code>. Будь-який код, який читає чи записує <code>COUNTER</code>, має бути в блоці <code>unsafe</code>. Цей код компілюється і виводить <code>COUNTER: 3</code>, як ми й маємо очікувати, бо він однопоточний. Якщо ж багато потоків матимуть доступ до <code>COUNTER</code>, це, швидше за все, призведе до гонитви даних.</p>
<p>З глобально доступними мутабельними даними важко забезпечити, щоб не було гонитви даних, і саме тому Rust вважає мутабельні статичні змінні небезпечними. Де це можливо, бажано використовувати методи конкурентності та потокобезпечні розумні вказівники, які ми обговорювали в Розділі 16, щоб компілятор перевіряв, що доступ до даних з різних потоків здійснюється безпечно.</p>
<h3 id="Реалізація-небезпечного-трейта"><a class="header" href="#Реалізація-небезпечного-трейта">Реалізація небезпечного трейта</a></h3>
<p>Ми можемо скористатися <code>unsafe</code> для реалізації небезпечного трейта. Трейт є небезпечним, якщо хоча б один з його методів має якийсь інваріант, який компілятор не може перевірити. Ми проголошуємо, що трейт є <code>небезпечним</code>, додаючи ключове слово <code>unsafe</code> перед <code>trait</code> та позначивши реалізацію трейта як <code>unsafe</code>, як показано у Блоці коду 19-11.</p>
<pre><pre class="playground"><code class="language-rust">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}
</code></pre></pre>
<p><span class="caption">Блок коду 19-11: визначення та реалізація небезпечного трейта</span></p>
<p>За допомогою <code>unsafe impl</code>, ми обіцяємо, що дотримуватимемося інваріантів, які компілятор не може перевірити.</p>
<p>Як приклад, згадайте маркерні трейти <code>Sync</code> і <code>Send</code>, які ми обговорювали в підрозділі <a href="">&quot;Розширювана конкурентність із трейтами <code>Sync</code> і <code>Send</code>&quot;</a><!-- ignore -->
у Розділі 16: компілятор реалізує ці трейти автоматично, якщо наші типи повністю складаються з типів <code>Send</code> і <code>Sync</code>. Якщо ми реалізуємо тип, який містить тип, що неє <code>Send</code> або <code>Sync</code>, такий як сирі вказівники, і ми хочемо позначити цей тип як <code>Send</code> або <code>Sync</code>, ми маємо використовувати <code>unsafe</code>. Довіра не може переконатися, що наш тип дотримується гарантій, щоб його можна було безпечно передавати між потоками або мати до нього доступ з декількох потоків; таким чином, нам потрібно робити ці перевірки вручну і позначити це за допомогою <code>unsafe</code>.</p>
<h3 id="Доступ-до-полів-обʼєднання"><a class="header" href="#Доступ-до-полів-обʼєднання">Доступ до полів обʼєднання</a></h3>
<p>Остання дія, яка працює лише за допомогою <code>unsafe</code> - це доступ до полів <em>об'єднання</em>. Об'єднання (<code>union</code>) схоже на структуру <code>struct</code>, але лише одне проголошене поле використовується у конкретному екземплярі у кожен певний момент часу. Об'єднання передусім використовується для інтерфейсу з об'єднаннями в коді C. Доступ до полів об'єднання є небезпечним, бо Rust не може гарантувати, який саме тип даних зараз зберігається у екземплярі об'єднання. Більше про об'єднання ви можете дізнатися у <a href="../reference/items/unions.html">Довіднику Rust</a>.</p>
<h3 id="Коли-використовувати-небезпечний-код"><a class="header" href="#Коли-використовувати-небезпечний-код">Коли використовувати небезпечний код</a></h3>
<p>Використання <code>unsage</code> для отримання однієї з п'яти дій (суперсил), про які ми щойно говорили, не є неправильним чи навіть несхвальним. Але код <code>unsafe</code> складніше зробити коректним, бо компілятор не може підтримувати безпеку пам'яті. Коли ви маєте причину використовувати <code>unsafe</code>, ви можете так робити, а наявність явних анотацій <code>unsafe</code> полегшує відстеження джерела проблем, коли вони виникають.
ch04-02-references-and-borrowing.html#dangling-references ch03-01-variables-and-mutability.html#constants ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Поглиблено-про-трейти"><a class="header" href="#Поглиблено-про-трейти">Поглиблено про трейти</a></h2>
<p>Ми вже розповідали про трейти у підрозділі <a href="">“Трейти: визначення загальної поведінки”</a><!-- ignore --> Розділу 10, але ми не говорили про глибші деталі. Тепер, коли ви більше знаєте про Rust, ми можемо перейти до дрібніших деталей.</p>
<h3 id="Зазначення-заповнювача-типу-у-визначенні-трейтів-за-допомогою-асоційованих-типів"><a class="header" href="#Зазначення-заповнювача-типу-у-визначенні-трейтів-за-допомогою-асоційованих-типів">Зазначення заповнювача типу у визначенні трейтів за допомогою асоційованих типів</a></h3>
<p><em>Асоційовані типи</em> зв'язують заповнювач типу з трейтом таким чином, що методи трейту можуть використовувати ці заповнювачі типу у своїх сигнатурах. Той, хто реалізовуватиме трейт, зазначить конкретний тип, що буде використовуватися, замість заповнювача типу для конкретної реалізації. Таким чином ми можемо визначити трейт, що використовує деякі типи, без потреби точно знати ці типи до моменту реалізації трейту.</p>
<p>Ми описували більшість поглиблених особливостей у цьому розділі як такі, що рідко потрібні. Пов'язані типи десь посередині: вони використовуються рідше за функціонал, описаний в решті книги, але частіше ніж багато іншого функціоналу, обговорюваного в цьому розділі.</p>
<p>Одним з прикладів трейту з асоційованим типом є трейт <code>Iterator</code>, наданий стандартною бібліотекою. Асоційований тип називається <code>Item</code> і позначає тип значень, по яких ітерує тип, що реалізує трейт <code>Iterator</code>. Визначення трейту <code>Iterator</code> показано у Блоці коду 19-12.</p>
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
</code></pre>
<p><span class="caption">Блок коду 19-12: визначення трейту <code>Iterator</code>, що має асоційований тип <code>Item</code></span></p>
<p>Тип <code>Item</code> є заповнювачем, і визначення методу <code>next</code> показує, що він повертає значення типу <code>Option&lt;Self::Item&gt;</code>. Ті, хто реалізовуватимуть трейт <code>Iterator</code>, зазначать конкретний тип для <code>Item</code>, і метод <code>next</code> повертатиме <code>Option</code>, що міститиме значення цього конкретного типу.</p>
<p>Асоційовані типи можуть видатися концепцією, подібною до узагальнень, у тому, що останні дозволяють визначити функцію без зазначення, які типи вона може обробляти. Для вивчення відмінностей між двома концепціями, погляньмо на реалізацію трейту <code>Iterator</code> для типу, що зветься <code>Counter</code> із зазначеним типом <code>Item</code> <code>u32</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Цей синтаксис здається схожим на узагальнені параметри. То чому ж просто не визначити трейт <code>Iterator</code> з узагальненим параметром, як показано в Блоці коду 19-13?</p>
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
</code></pre>
<p><span class="caption">Блок коду 19-13: гіпотетичне визначення трейту <code>Iterator</code> за допомогою узагальненого параметра</span></p>
<p>Різниця полягає в тому, що при використанні узагальнених параметрів, як у Блоці коду 19-13, ми маємо анотувати типи у кожній реалізації; а оскільки ми також можемо реалізувати <code>Iterator&lt;String&gt; для Counter</code> чи будь-якого іншого типу, ми можемо мати багато реалізацій <code>Iterator</code> для <code>Counter</code>. Іншими словами, коли трейт має узагальнений параметр, він може бути реалізованим для типу багато разів, кожного разу для іншого конкретного типу узагальненого параметра. Коли ми використовуємо метод <code>next</code> для <code>Counter</code>, нам доведеться надавати анотації типу, щоб позначити, яку реалізацію <code>Iterator</code> ми хочемо використати.</p>
<p>З асоційованими типами нам не треба анотувати типи, бо ми не можемо реалізувати трейт для типу кілька разів. У Блоці коду 19-12, з визначенням, яке використовує асоційовані типи, ми можемо обрати тип <code>Item</code> лише один раз, бо може бути лише один <code>impl Iterator for Counter</code>. Нам не треба зазначати, що ми хочемо ітератор по значеннях <code>u32</code> всюди, де ми викликаємо <code>next</code> для <code>Counter</code>.</p>
<p>Асоційовані типи також стають частиною контракту трейту: ті, хто реалізують трейт, мають зазначити тип для заповнювача асоційованого типу. Асоційовані типи часто мають назву, що описує, як цей тип буде використано, і документування асоційованого типу в документації API є доброю практикою.</p>
<h3 id="Узагальнені-параметри-типу-за-замовчуванням-і-перевантаження-операторів"><a class="header" href="#Узагальнені-параметри-типу-за-замовчуванням-і-перевантаження-операторів">Узагальнені параметри типу за замовчуванням і перевантаження операторів</a></h3>
<p>Коли ми використовуємо узагальнені параметри типу, то можемо вказати конкретний тип за замовчуванням для узагальненого типу. Це усуває потребу для тих, хто реалізовуватиме трейт, вказувати конкретний тип, якщо тип за замовчанням працює. Ви можете вказати тип за замовчуванням при проголошенні узагальненого типу за допомогою синтаксису <code>&lt;PlaceholderType=ConcreteType&gt;</code>.</p>
<p>Чудовий приклад ситуації, коли ця техніка корисна, це <em>перевантаження операторів</em>, де ви налаштовуєте поведінку оператора (наприклад, <code>+</code>) в певних ситуаціях.</p>
<p>Rust не дозволяє вам створювати власні оператори або перевантажувати довільні оператори. Але ви можете перевантажити операції і відповідні трейти, перелічені в <code>std::ops</code>, реалізувавши трейти, пов'язані з оператором. Наприклад, у Блоці коду 19-14 ми перевантажуємо оператор <code>+</code>, щоб додавати два екземпляри <code>Point</code>. Ми робимо це, реалізуючи трейт <code>Add</code> для <code>Point</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
</code></pre></pre>
<p><span class="caption">Блок коду 19-14: реалізація трейту <code>Add</code> для перевантаження оператора <code>+</code> для екземплярів <code>Point</code></span></p>
<p>Метод <code>add</code> додає значення <code>x</code> двох екземплярів <code>Point</code> і значення <code>y</code> двох екземплярів <code>Point</code>, щоб створити нову <code>Point</code>. Трейт <code>Add</code> має асоційований тип, що називається <code>Output</code>, який визначає тип, який повертає метод <code>add</code>.</p>
<p>Узагальнений параметр типу за замовчанням у цьому коді належить трейту <code>Add</code>. Ось його визначення:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>Цей код має виглядати в цілому знайомо: трейт з одним методом і асоційованим типом. Новим тут є <code>Rhs=Self</code>: цей синтаксис зветься <em>параметром типу за замовчанням</em>. Узагальнений параметр типу <code>Rhs</code> (скорочено для &quot;right hand side&quot; - &quot;правий бік&quot;) визначає тип параметра <code>rhs</code> у методі <code>add</code>. Якщо ми не зазначимо конкретний тип для <code>Rhs</code>, коли ми реалізуємо трейт <code>Add</code>, тип <code>Rhs</code> буде взято за замовчанням як <code>Self</code>, тобто тип, для якого ми реалізуємо <code>Add</code>.</p>
<p>Коли ми реалізували <code>Add</code> для <code>Point</code>, ми використали значення за замовчанням для <code>Rhs</code>, бо ми хотіли додавати два екземпляри <code>Point</code>. Розгляньмо приклад реалізації трейта <code>Add</code>, де ми хочемо виставити свій тип <code>Rhs</code>, а не використовувати значення за замовчуванням.</p>
<p>Ми маємо дві структури, <code>Millimeters</code> і <code>Meters</code>, що містять значення в різних одиницях. Ця тонка обгортка типу, що існує, у іншу структуру відома як <em>шаблон новий тип</em>, який ми описували детальніше у підрозділі <a href="ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">“Використання шаблону новий тип для реалізації зовнішніх трейтів на зовнішніх типах”</a><!-- ignore
--> . Ми хочемо додавати значення у міліметрах до значень у метрах, щоб реалізація </p>
<p><code>Add</code> коректно виконувала перетворення. Ми можемо реалізувати <code>Add</code> для <code>Millimeters</code> з <code>Meters</code> як <code>Rhs</code>, як показано в Блоці коду 19-15.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
</code></pre>
<p><span class="caption">Блок коду 19-15: реалізація трейту <code>Add</code> для <code>Millimeters</code>, щоб додавати <code>Millimeters</code> до <code>Meters</code></span></p>
<p>Щоб додати <code>Millimeters</code> і <code>Meters</code>, вказуємо <code>impl Add&lt;Meters&gt;</code>, щоб встановити значення параметра типу <code>Rhs</code> замість встановленого за замовчуванням <code>Self</code>.</p>
<p>Параметри типу за замовчанням використовуються у двох основних випадках:</p>
<ul>
<li>Щоб розширити тип, не порушуючи коду, що існує</li>
<li>Щоб дозволити налаштування у певних випадках, не потрібних більшості користувачів</li>
</ul>
<p>Трейт <code>Add</code> зі стандартної бібліотеки є прикладом другого призначення: зазвичай ви додаєте однакові типи, але трейт <code>Add</code> надає можливість глибшого налаштування. Використовуючи параметр типу за замовчуванням в трейті <code>Add</code> означає, що у більшості випадків вам не потрібно вказувати додатковий параметр. Іншими словами, не потрібно вказувати шматок шаблонного коду реалізації, що полегшує використання трейту.</p>
<p>Перше призначення схоже на друге, але навпаки: якщо ви хочете додати параметр типу до трейту, що вже існує, ви можете надати йому параметр типу за замовчуванням, щоб розширити функціональність трейту не порушивши наявного коду реалізації.</p>
<h3 id="Повністю-кваліфікований-синтаксис-для-уникнення-двозначностей-виклик-методів-з-однаковою-назвою"><a class="header" href="#Повністю-кваліфікований-синтаксис-для-уникнення-двозначностей-виклик-методів-з-однаковою-назвою">Повністю кваліфікований синтаксис для уникнення двозначностей: виклик методів з однаковою назвою</a></h3>
<p>Ніщо у Rust не забороняє трейту мати метод з такою самою назвою, як і в іншому трейті, ані реалізувати обидва трейти для одного типу. Також можна реалізувати метод з такою ж назвою, як у трейтах, напряму для типу.</p>
<p>При виклику методів з однаковою назвою вам треба вказати Rust, котрий саме метод ви хочете використати. Розгляньмо код у Блоці коду 19-16, де ми визначили два трейти, <code>Pilot</code> і <code>Wizard</code>, що обидва мають метод <code>fly</code>. Тоді ми реалізуємо обидва трейти для типу <code>Human</code>, що також має реалізований на ньому метод з назвою <code>fly</code>. Кожен метод <code>fly</code> робить щось інше.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Блок коду 19-16: два трейти маю визначення, що містить метод &quot;fly&quot; і реалізовані для типу <code>Human</code>, а також метод <code>fly</code>, реалізований безпосередньо для <code>Human</code></span></p>
<p>Коли ми викликаємо <code>fly</code> на екземплярі <code>Human</code>, компілятор за замовчуванням викликає метод, реалізований безпосередньо на типі, як показано у Блоці коду 19-17.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}
</code></pre></pre>
<p><span class="caption">Блок коду 19-17: виклик <code>fly</code> для екземпляра <code>Human</code></span></p>
<p>Запуск цього коду виведе <code>*waving arms furiously*</code>, показуючи, що Rust викликав метод <code>fly</code>, реалізований безпосередньо для <code>Human</code>.</p>
<p>Щоб викликати методи <code>fly</code> з трейту <code>Pilot</code> або трейту <code>Wizard</code>, нам треба використати більш явний синтаксис, щоб зазначити, який саме метод <code>fly</code> ми маємо на увазі. Блок коду 19-18 демонструє такий синтаксис.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre></pre>
<p><span class="caption">Блок коду 19-18: уточнення, метод <code>fly</code> якого саме трейту ми хочемо викликати</span></p>
<p>Зазначення назви трейту перед назвою методу прояснює для Rust, котру реалізацію <code>fly</code> ми хочемо викликати. Ми також могли б написати <code>Human::fly(&amp;person)</code>, що є еквівалентом <code>person.fly()</code>, який ми використали в Блоці коду 19-18, але так трохи довше писати, якщо нам не треба уникнути двозначності.</p>
<p>Виконання цього коду виведе наступне:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>Оскільки метод <code>fly</code> приймає параметр <code>self</code>, то якщо ми маємо два <em>типи</em>, що обидва реалізують один <em>трейт</em>, Rust може зрозуміти, яку реалізацію трейту використати, виходячи з типу <code>self</code>.</p>
<p>Однак асоційовані функції, що не є методами, не мають параметру <code>self</code>. Коли є багато типів чи трейтів, що визначають функції, що не є методами, з однаковими назвами, Rust не завжди знає, який тип ви мали на увазі, якщо ви не використаєте <em>повний кваліфікований синтаксис</em>. Наприклад, у Блоці коду 19-19 ми створюємо трейт для притулку тварин, що хоче називати всіх маленьких собак <em>Spot</em>. Ми створюємо трейт <code>Animal</code> з асоційованою функцією - не методом <code>baby_name</code>. Трейт <code>Animal</code> реалізований для структури <code>Dog</code>, для якої ми також визначаємо напряму асоційовану функцію - не метод <code>baby_name</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}
</code></pre></pre>
<p><span class="caption">Блок коду 19-19: трейт з асоційованою функцією і тип з асоційованою функцією з такою ж назвою, що реалізує цей трейт</span></p>
<p>Ми реалізували код для називання всіх цуценят Spot у асоційованій функції <code>baby_name</code>, визначеній для <code>Dog</code>. Тип <code>Dog</code> також реалізує трейт <code>Animal</code>, що описує характеристики, спільні для всіх тварин. Дитинчата собак звуться цуценятами, і це виражено в реалізації трейту <code>Animal</code> доя <code>Dog</code> у функції <code>baby_name</code>, асоційованій з трейтом <code>Animal</code>.</p>
<p>У <code>main</code> ми викликаємо функцію <code>Dog::baby_name</code>, яка викликає асоційовану функцію, визначену безпосередньо для <code>Dog</code>. Цей код виводить таке:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
</code></pre>
<p>Ми хотіли не такого виведення. Ми хотіли викликати функцію <code>baby_name</code>, що є частиною трейту <code>Animal</code>, який ми реалізували для <code>Dog</code>, щоб код вивів <code>A baby dog is called a puppy</code>. Техніка зазначення назви трейту, яку ми використали у Блоці коду 19-18 тут не допомагає; якщо ми змінимо <code>main</code> на код, наведений у Блоці коду 19-20, ми отримаємо помилку компіляції.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;puppy&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
}
</code></pre>
<p><span class="caption">Блок коду 19-20: спроба викликати функцію <code>baby_name</code> з трейту <code>Animal</code>, але Rust не знає, яку реалізацію використати</span></p>
<p>Оскільки <code>Animal::baby_name</code> не має параметру <code>self</code>, і можуть бути інші типи, що реалізують трейт <code>Animal</code>, Rust не може з'ясувати, яку реалізацію <code>Animal::baby_name</code> ми хочемо. Ми отримуємо цю помилку компілятора:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0283]: type annotations needed
  --&gt; src/main.rs:20:43
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^ cannot infer type
   |
   = note: cannot satisfy `_: Animal`

For more information about this error, try `rustc --explain E0283`.
error: could not compile `traits-example` due to previous error
</code></pre>
<p>Щоб розрізнити реалізації і сказати Rust, що ми хочемо використати реалізацію <code>Animal</code> для <code>Dog</code>, а не реалізацію <code>Animal</code> для якогось іншого типу, ми маємо використати повний кваліфікований синтаксис. Блок коду 19-21 демонструє, як використовувати повний кваліфікований синтаксис.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;puppy&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre></pre>
<p><span class="caption">Блок коду 19-21: використання повністю кваліфікованого синтаксису, щоб вказати, що ми хочемо викликати функцію <code>baby_name</code> з трейту <code>Animal</code>, реалізованого для <code>Dog</code></span></p>
<p>Ми надаємо Rust анотацію типу в кутових дужках, що показує, що ми хочемо викликати метод <code>baby_name</code> з трейту <code>Animal</code>, як він реалізований для <code>Dog</code>, кажучи, що ми хочемо розглядати тип e <code>Dog</code> як <code>Animal</code> для цього виклику функції. Цей код тепер виведе те, що ми хотіли:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
</code></pre>
<p>В цілому, повний кваліфікований синтаксис визначений таким чином:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<p>Для асоційованих функцій, які не є методами, не використовується <code>receiver</code>: там буде лише список решти аргументів. Ви можете використовувати повний кваліфікований синтаксис всюди, де викликаєте функції або методи. Однак, ви можете пропустити будь-яку частину синтаксису, яку Rust може визначити за допомогою іншої інформації у програмі. Вам потрібно використовувати цей більш багатослівний синтаксис у випадках, коли є декілька реалізацій, які використовують одну назву і Rust потребує допомоги, щоб визначити, яку реалізацію ви хочете викликати.</p>
<h3 id="Використання-супертрейтів-для-вимоги-функціонала-одного-трейта-в-іншому-трейті"><a class="header" href="#Використання-супертрейтів-для-вимоги-функціонала-одного-трейта-в-іншому-трейті">Використання супертрейтів для вимоги функціонала одного трейта в іншому трейті</a></h3>
<p>Іноді ви можете написати визначення трейта, що залежить від іншого трейта: для типу, що реалізує перший трейт, ви хочете вимагати, щоб цей тип також реалізовував другий трейт. Вам може бути таке потрібно, якщо визначення вашого трейта використовує асоційовані елементи другого трейта. Трейт, на який покладається визначення вашого трейта, зветься <em>супертрейтом</em> вашого трейта.</p>
<p>Наприклад, припустимо, що ми хочемо зробити трейт <code>OutlinePrint</code> з методом <code>outline_print</code>, що виводить задане значення, форматоване рамкою з зірочок. Тобто, якщо структура <code>Point</code> реалізує трейт зі стандартної бібліотеки <code>Display</code> і виводить <code>(x, y)</code>, то коли ми викликаємо <code>outline_print</code> на екземплярі <code>Point</code>, що має значення <code>1</code> для <code>x</code> і <code>3</code> для <code>y</code>, він має вивести таке:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>У реалізації методу <code>outline_print</code> ми хочемо використати функціональність трейту <code>Display</code>. Відповідно, нам потрібно вказати що трейт <code>OutlinePrint</code> буде працювати тільки для типів, які також реалізують <code>Display</code> і надають функціональність, потрібну <code>OutlinePrint</code>. Ми можемо зробити це у визначені трейта, вказавши <code>OutlinePrint: Display</code>. Ця техніка схожа на додавання до трейта трейтового обмеження. Блок коду 19-22 показує реалізацію трейту <code>OutlinePrint</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Блок коду 19-22: реалізація трейту <code>OutlinePrint</code>, який вимагає функціональності <code>Display</code></span></p>
<p>Оскільки ми вказали, що <code>OutlinePrint</code> потребує трейту <code>Display</code>, ми можемо використовувати функцію <code>to_string</code>, автоматично реалізовану для будь-якого типу, що реалізовує <code>Display</code>. Якби ми спробували використати <code>to_string</code>, не додавши двокрапки і трейту <code>Display</code> після назви трейту, ми б отримали помилку про те, що метод <code>to_string</code> не був знайдений для типу <code>&amp;Self</code> у поточній області видимості.</p>
<p>Подивімося, що станеться, коли ми спробуємо реалізувати <code>OutlinePrint</code> для типу, що не реалізує <code>Display</code>, такому як структура <code>Point</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, output);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre>
<p>Ми отримуємо помилку, яка повідомляє, що <code>Display</code> є потрібним, але не реалізованим:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` due to previous error
</code></pre>
<p>Щоб виправити це, ми реалізуємо <code>Display</code> для <code>Point</code> і задовольняємо обмеження для <code>OutlinePrint</code> ось таким чином:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, output);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre></pre>
<p>To fix this, we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that <code>OutlinePrint</code> requires, like so:</p>
<h3 id="Використання-паттерну-новий-тип-для-реалізації-зовнішніх-трейтів-на-зовнішніх-типах"><a class="header" href="#Використання-паттерну-новий-тип-для-реалізації-зовнішніх-трейтів-на-зовнішніх-типах">Використання паттерну &quot;новий тип&quot; для реалізації зовнішніх трейтів на зовнішніх типах</a></h3>
<p>У Розділі 10, у підрозділі <a href="">“Реалізація трейта для типу”</a><!-- ignore --> , ми згадали правило сироти, яке каже, що ми можемо реалізовувати трейт для типу, якщо трейт або тип є локальним для нашого крейта. Це обмеження можна обійти за допомогою <em>паттерна &quot;новий тип&quot;</em>, що передбачає створення нового типу у структурі-кортежі. (Про структури-кортежі ми говорили у підрозділі <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">&quot;Використання структур-кортежів без названих полів для створення нових типів&quot;</a><!--
ignore --> Розділу 5.) Структури-кортежі мають одне поле і є тонкою обгорткою для типу, для якого ми хочемо реалізувати трейт. Тоді тип-обгортка є локальним для нашого крейта, і ми можемо реалізувати трейт для обгортки. </p>
<p><em>Новий тип</em> - це термін, який походить з мови програмування Haskell. Використання цього шаблону не призводить до втрат швидкодії, а тип обгортки приховується під час компіляції.</p>
<p>Наприклад, скажімо, ми хочемо реалізувати <code>Display</code> для <code>Vec&lt;T&gt;</code>, що безпосередньо заборонено правилом сироти, тому що трейт <code>Display</code> і тип <code>Vec&lt;T&gt;</code> визначається поза нашим крейтом. Ми можемо зробити структуру <code>Wrapper</code>, що містить екземпляр <code>Vec&lt;T&gt;</code>; тоді ми можемо реалізувати <code>Display</code> для <code>Wrapper</code> використати значення <code>Vec&lt;T&gt;</code>, як показано в Блоці коду 19-23.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p><span class="caption">Блок коду 19-23: створення типу <code>Wrapper</code> навколо <code>Vec&lt;String&gt;для реалізації </code>Display`</span></p>
<p>Реалізація <code>Display</code> використовує <code>self.0</code> для доступу до внутрішнього <code>Vec&lt;T&gt;</code>, оскільки <code>Wrapper</code> - це структура-кортеж, а <code>Vec&lt;T&gt;</code> - це елемент з індексом 0 в кортежі. Тоді ми можемо використати функціонал типу <code>Display</code> на <code>Wrapper</code>.</p>
<p>Недоліком використання цієї техніки є те, що <code>Wrapper</code> є новим типом, тож він не має методів значення, яке він містить. Ми мали б реалізувати всі методи <code>Vec&lt;T&gt;</code> безпосередньо на <code>Wrapper</code>, делегуючи всі методи <code>self.0</code>, що дозволить нам використовувати <code>Wrapper</code> точно як і <code>Vec&lt;T&gt;</code>. Якби ми хотіли, щоб новий тип мав кожен метод, який має внутрішній тип, то реалізація трейту <code>Deref</code> (про який йдеться у Розділі 15 у підрозділі <a href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">“Використання розумних вказівників як звичайних посилань за допомогою трейта <code>Deref</code>”</a><!-- ignore --> ) для <code>Wrapper</code>, щоб повертав внутрішній тип, могла б бути розв'язанням проблеми. Якщо ж ми не хочемо, щоб тип <code>Wrapper</code> мав усі методи внутрішнього типу - наприклад, для обмеження поведінки типу <code>Wrapper</code> - то нам треба реалізувати потрібні нам методи вручну.</p>
<p>Цей паттерн &quot;новий тип&quot; також корисний навіть без залучення трейтів. Змінімо фокус і погляньмо на деякі поглиблені способи взаємодії з системою типів Rust.
ch10-02-traits.html#implementing-a-trait-on-a-type ch10-02-traits.html#traits-defining-shared-behavior</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Поглиблено-про-типи"><a class="header" href="#Поглиблено-про-типи">Поглиблено про типи</a></h2>
<p>Система типів Rust має певні особливості, про які ми вже згадували, але не обговорювали. Почнемо з обговорення нових типів у цілому, розбираючи, чому нові типи корисні як типи. Тоді ми перейдемо до псевдонімів типів, функціоналу, подібному до нових типів, але з трохи іншою семантикою. Також ми обговоримо тип <code>!</code> і типи з динамічним розміром.</p>
<h3 id="Використання-паттерну-новий-тип-для-безпеки-і-абстракції-типів"><a class="header" href="#Використання-паттерну-новий-тип-для-безпеки-і-абстракції-типів">Використання паттерну &quot;новий тип&quot; для безпеки і абстракції типів</a></h3>
<blockquote>
<p>Примітка: цей підрозділ передбачає, що ви вже прочитали попередній підрозділ <a href="ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">“Використання паттерну &quot;новий тип&quot; для реалізації зовнішніх трейтів на зовнішніх типах.”</a><!-- ignore --></p>
</blockquote>
<p>Паттерн &quot;новий тип&quot; також корисний для задач поза тими, які ми досі обговорили, включно зі статичним гарантуванням, що значення не переплутаються, і вказанням одиниць значення. Ви бачили приклад використання нових типів для позначення типів у Блоці коду 19-15: згадайте структури <code>Millimeters</code> і <code>Meters</code>, що обгортали значення <code>u32</code> у новий тип. Якщо ми напишемо функцію з параметром типу <code>Millimeters</code>, то не зможемо скомпілювати програму, де випадково спробуємо викликати цю функцію зі значенням типу <code>Meters</code> або просто <code>u32</code>.</p>
<p>Ми також можемо використовувати патерн &quot;новий тип&quot;, щоб абстрагуватися від деталей реалізації типу: новий тип може надати публічний API, що відрізняється від API приватного внутрішнього типу.</p>
<p>Нові типи також можуть приховувати внутрішню реалізацію. Наприклад, ми могли б надати тип <code>People</code> для того, щоб загорнути <code>HashMap&lt;i32, String&gt;</code>, що зберігає ID людини, пов'язаний з її ім'ям. Код, що використовує <code>People</code>, взаємодіятиме лише з наданим нами публічним API, таким як метод, щоб додати ім'я - стрічку до колекції <code>People</code>; тому коду не треба знати, що внутрішньо ми присвоюємо іменам ID типу <code>i32</code>. Паттерн &quot;новий тип&quot; є простим способом досягти інкапсуляції, щоб приховати деталі реалізації, про яку ми говорили у підрозділі <a href="">“Інкапсуляція, яка приховує деталі реалізації”</a><!-- ignore -->
Розділу 17.</p>
<h3 id="Створення-синонімів-типів-за-допомогою-псевдонімів-типів"><a class="header" href="#Створення-синонімів-типів-за-допомогою-псевдонімів-типів">Створення синонімів типів за допомогою псевдонімів типів</a></h3>
<p>Rust надає можливість проголосити <em>псевдонім типу</em>, щоб надати типу, що існує, іншу назву. Для цього використовується ключове слово <code>type</code>. Наприклад, ми можемо створити псевдонім <code>Kilometers</code> для <code>i32</code> ось таким чином:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!(&quot;x + y = {}&quot;, x + y);
</span><span class="boring">}
</span></code></pre></pre>
<p>Тепер псевдонім <code>Kilometers</code> є <em>синонімом</em> для <code>i32</code>; на відміну від типів <code>Millimeters</code> і <code>Meters</code>, які ми створили в Блоці коду 19-15, <code>Kilometers</code> не є окремим новим типом. Значення, що мають тип <code>Kilometers</code> будуть оброблятись так само як і значення типу <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<p>Оскільки <code>Kilometers</code> та <code>i32</code> є одним типом, ми можемо додавати значення обох типів, і ми можемо передавати значення <code>Kilometers</code> у функції, що приймають параметром <code>i32</code>. Однак, за допомогою цього методу ми не отримуємо переваг перевірки типів, які ми отримали від паттерну &quot;новий тип&quot;, про який говорили раніше. Іншими словами, якщо ми десь переплутаємо значення <code>Kilometers</code> і <code>i32</code>, компілятор не повідомить нам про помилку.</p>
<p>Основним випадком використання синонімів типу є зменшення повторень. Наприклад, у нас може бути такий довгий тип:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;
</code></pre>
<p>Писати цей довгий тип у сигнатурах функцій і анотаціях типів по всьому коду утомлює і призводить до помилок. Уявімо, що в нас є проєкт, повний коду, подібного до Блоку коду 19-24.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --snip--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 19-25: використання довгого типу в багатьох місцях</span></p>
<p>Псевдонім типу робить цей код більш керованим шляхом зменшення повторень. У Блоці коду 19-25 ми ввели псевдонім з назвою <code>Thunk</code> для багатослівного типу і можемо замінити всі використання цього типу на коротший псевдонім <code>Thunk</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -&gt; Thunk {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 19-25: введення псевдоніма типу <code>Thunk</code> для зменшення повторень</span></p>
<p>Цей код набагато легше читати і писати! Вибір осмисленої назви для псевдоніма типу також може допомогти передати ваш намір (<em>thunk</em> означає код для обчислення пізніше, то ж це доречна назва для замикання, що зберігається).</p>
<p>Псевдоніми типів також широко використовуються з типом <code>Result&lt;T, E&gt;</code> для зменшення повторень. Подивімося на модуль <code>std::io</code> зі стандартної бібліотеки. Операції введення-виведення часто повертають <code>Result&lt;T, E&gt;</code>, щоб обробити ситуації, де операції не вдалися. Ця бібліотека має структуру <code>std::io::Error</code>, що представляє всі можливі помилки введення-виведення. Багато з функцій з <code>std::io</code> повертають <code>Result&lt;T, E&gt;</code>, де <code>E</code> - це <code>std::io::Error</code>, наприклад ці функції у трейті <code>Write</code>:</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
</code></pre>
<p><code>Result&lt;..., Error&gt;</code> повторюється багато разів. Тому <code>std::io</code> проголошує псевдонім цього типу:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}
</span></code></pre>
<p>Оскільки це проголошення знаходиться в модулі <code>std::io</code>, ми можемо використовувати повний кваліфікований псевдонім <code>std::io::Result&lt;T&gt;</code>, тобто <code>Result&lt;T, E&gt;</code>, в якому <code>E</code> визначено як <code>std::io::Error</code>. Сигнатури функцій трейту <code>Write</code> в результаті виглядають ось так:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<p>Псевдоніми типів допомагають у два способи: спрощують написання коду <em>і</em> надають нам цілісний інтерфейс у всьому <code>std::io</code>. Оскільки це псевдонім, це лише звичайний <code>Result&lt;T, E&gt;</code>, що означає, що ми можемо використовувати для нього будь-які методи, що працюють з <code>Result&lt;T, E&gt;</code>, а також особливий синтаксис на кшталт оператора <code>?</code>.</p>
<h3 id="Тип-ніколи-що-ніколи-не-повертається"><a class="header" href="#Тип-ніколи-що-ніколи-не-повертається">Тип &quot;ніколи&quot;, що ніколи не повертається</a></h3>
<p>Rust має спеціальний тип, що зветься <code>!</code>, також відомий у термінології теорії типів як <em>empty type</em>, бо він не має значень. Ми радше називаємо його <em>тип &quot;ніколи&quot;</em>, бо він стоїть замість типу, що повертається, коли функція ніколи не повертає значення. Ось приклад:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --snip--
<span class="boring">    panic!();
</span>}
</code></pre>
<p>Цей код читається як &quot;функція <code>bar</code> ніколи не повертає.&quot; Функції, що ніколи не повертають, звуться <em>розбіжними функціями</em>. Ми не можемо створювати значень типу <code>!</code>, тож <code>bar</code> ніколи не може нічого повернути.</p>
<p>Але яка користь від типу, для якого неможливо створити значення? Згадайте код з Блоку коду 2-5, частину гри &quot;Відгадай число&quot;; ми відтворимо частину його тут, у Блоці коду 19-26.</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 19-26: <code>match</code> з рукавом, що закінчується на <code>continue</code></span></p>
<p>Цього разу ми пропустили деякі деталі в цьому коді. У Розділі 6 у підрозділі <a href="">&quot;Конструкція управління <code>match</code>&quot;</a><!-- ignore -->
ми говорили, що рукави <code>match</code> мають усі повертати один і той самий тип. Тож, наприклад, цей код не працює:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = &quot;3&quot;;
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;hello&quot;,
    };
<span class="boring">}
</span></code></pre>
<p>Тип <code>guess</code> у цьому коді має бути цілим числом <em>і</em> стрічкою, а Rust вимагає, щоб <code>guess</code> був лише одного типу. То що ж повертає <code>continue</code>? Як у нас вийшло повернути <code>u32</code> з одного рукава та мати інший рукав, що закінчується на <code>continue</code> у Блоці коду 19-26?</p>
<p>Як ви вже мабуть здогадалися, <code>continue</code> має значення <code>!</code>. Тобто, коли Rust обчислює тип <code>guess</code>, він перевіряє обидва рукави match, перший зі значенням <code>u32</code> і другий зі значенням <code>!</code>. Оскільки <code>!</code> ніколи не має значення, Rust вирішує, що типом <code>guess</code> є <code>u32</code>.</p>
<p>Формальним ця поведінка описується так: вираз типу <code>!</code> може бути приведений до будь-якого іншого типу. Ми можемо поставити<code>continue</code> в кінці рукава <code>match</code>, бо <code>continue</code> не повертає значення; натомість, він передає управління назад на початок циклу, тож у випадку <code>Err</code> ми ніколи не присвоїмо значення <code>guess</code>.</p>
<p>Тип &quot;ніколи&quot; також використовується у макросі <code>panic!</code>. Згадайте функцію <code>unwrap</code>, яку ми викликаємо для значень типу <code>Option&lt;T&gt;</code>, щоб отримати значення чи запанікувати; ось її визначення:</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>У цьому коді відбувається те ж саме, що й у <code>match</code> з Блоку коду 19-26: Rust бачить, що <code>val</code> має тип <code>T</code> а <code>panic!</code> має тип <code>!</code>, отже, результат усього виразу <code>match</code> є <code>T</code>. Цей код працює, оскільки <code>panic!</code> не виробляє значення; він завершує програму. У випадку <code>None</code>, ми не повертаємо значення з <code>unwrap</code>, тож цей код є коректним.</p>
<p>Іще один останній вираз, що має значення <code>!</code> - це <code>loop</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!(&quot;forever &quot;);

    loop {
        print!(&quot;and ever &quot;);
    }
<span class="boring">}
</span></code></pre>
<p>Тут цикл ніколи не закінчується, тож значенням виразу є <code>!</code>. Однак це не було б так, якби ми додали <code>break</code>, оскільки цикл завершиться, коли дістанеться до <code>break</code>.</p>
<h3 id="Типи-з-динамічним-розміром-і-трейт-sized"><a class="header" href="#Типи-з-динамічним-розміром-і-трейт-sized">Типи з динамічним розміром і трейт <code>Sized</code></a></h3>
<p>Rust має знати деякі деталі про типи, такі, як скільки місця розподілити під значення певного типу. Це лишає один куток системи типів, на перший погляд, незрозумілим: концепцію <em>типів з динамічним розміром</em>. Ці типи, які іноді звуться <em>DST (dymamically sized types)</em> чи <em>безрозмірні типи</em>, дозволяють нам писати код з використанням значень, розмір яких ми можемо дізнатися лише під час виконання.</p>
<p>Копнімо деталі типу з динамічним розміром, що зветься <code>str</code>, який ми використовуємо скрізь у книзі. Саме так, не <code>&amp;str</code>, а <code>str</code> як такий, що є DST. Ми не можемо знати довжину стрічки до часу виконання, що означає, що ми не можемо створити змінну типу <code>str</code>, ані прийняти аргумент типу <code>str</code>. Розгляньмо такий код, що не працює:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = &quot;Hello there!&quot;;
    let s2: str = &quot;How's it going?&quot;;
<span class="boring">}
</span></code></pre>
<p>Rust має знати, скільки пам'яті виділяти для будь-якого значення певного типу, і всі значення цього типу мають використовувати однакову кількість пам'яті. Якби Rust дозволив нам написати такий код, ці два значення <code>str</code> мали б займати однакову кількість місця в пам'яті. Але вони мають різні довжини: <code>s1</code> потребує 12 байтів пам'яті, а <code>s2</code> - 15. Ось чому неможливо створити змінну, що міститиме тип з динамічним розміром.</p>
<p>То що ж нам робити? В цьому випадку ви вже знаєте відповідь: ми робимо типи <code>s1</code> і <code>s2</code> <code>&amp;str</code> замість <code>str</code>. Згадайте з підрозділу <a href="ch04-03-slices.html#string-slices">&quot;Стрічкові слайси&quot;</a><!-- ignore --> Розділу 4, що структура даних слайс зберігає лише початкове положення і довжину слайса. Тож хоча  <code>&amp;T</code> і є одним значенням, що зберігає адресу в пам'яті, де знаходиться <code>T</code>,  <code>&amp;str</code> є <em>двома</em> значенням: адресою <code>str</code> і її довжиною. Таким чином ми можемо знати розмір значення <code>&amp;str</code> під час компіляції: два розміри <code>usize</code>. Тобто ми завжди знаємо розмір <code>&amp;str</code>, не важливо якою довгою буде стрічка, на яку воно посилається. В цілому типи з динамічним розміром у Rust використовуються саме у такий спосіб: вони мають додаткову крихту метаданих, що зберігають розмір динамічної інформації. Золоте правило типів із динамічним розміром є те, що ми завжди маємо ховати значення типів з динамічним розміром за вказівником певного роду.</p>
<p>Ми можемо комбінувати <code>str</code> з усіма видами вказівників: наприклад, <code>Box&lt;str&gt;</code> чи <code>Rc&lt;str&gt;</code>. Фактично ви вже бачили це раніше, але з іншими типами з динамічним розміром: трейтами. Будь-який трейт є типом із динамічним розміром, до якого ми можемо звертатися за допомогою назви трейту. У Розділі 17, підрозділі <a href="">“Використання трейт-об'єктів, які допускають значення різних типів”</a><!--
ignore --> , ми згадали, що для використання трейтів як трейтових об'єктів ми маємо сховати їх за вказівником, таким як </p>
<p><code>&amp;dyn Trait</code> чи <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> теж підійде).</p>
<p>Щоб працювати з DST, Rust надає трейт <code>Sized</code> для визначення, чи розмір типу відомий під час компіляції. Цей трейт автоматично реалізується для усього, чий розмір є відомим під час компіляції. Крім того, Rust неявно додає обмеження <code>Sized</code> на кожну узагальнену функцію. Тобто визначення ось таке узагальненої функції:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>насправді розглядається, ніби ми написали таке:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>За замовчуванням узагальнені функції працюють лише з типами, чий розмір є відомим під час компіляції. Однак ви можете застосувати наступний спеціальний синтаксис для послаблення цього обмеження:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
</code></pre>
<p>Трейтове обмеження <code>?Sized</code> означає “<code>T</code> може бути чи не бути <code>Sized</code>” і цей запис знімає обмеження за замовчуванням, що узагальнені типи мусять мати відомий розмір під час компіляції. Синтаксис <code>?Trait</code> із цим значенням можна застосовувати лише для <code>Sized</code>, але не для решти трейтів.</p>
<p>Також зауважте, що ми змінили тип параметра <code>t</code> з <code>T</code> на <code>&amp;T</code>. Оскільки тип може не бути <code>Sized</code>, ми маємо використати його, сховавши за якогось роду вказівником. У цьому випадку ми обрали посилання.</p>
<p>Далі ми поговоримо про функції та замикання!
ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details ch06-02-match.html#the-match-control-flow-operator ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Поглиблено-про-функції-та-замикання"><a class="header" href="#Поглиблено-про-функції-та-замикання">Поглиблено про функції та замикання</a></h2>
<p>Цей підрозділ поглиблено досліджує функціонал, що стосується функцій та замикань, і включає з вказівники на функції та повернення замикань.</p>
<h3 id="Вказівники-на-функції"><a class="header" href="#Вказівники-на-функції">Вказівники на функції</a></h3>
<p>Ми говорили про те, як передати замикання до функцій; ви також можете передати звичайні функції до функцій! Ця техніка є корисною, коли ви хочете передати вже визначену функцію, а не визначати нове замикання. Функції приводяться до типу <code>fn</code> (f у нижньому регістрі), не плутайте з трейтом замикань <code>Fn</code>. Тип <code>fn</code> зветься <em>вказівником на функцію</em>. Передача функцій за допомогою вказівників на функції дозволяє вам використовувати функції як аргументи до інших функцій.</p>
<p>Синтаксис для зазначення, що параметр є вказівником на функцію, схожий на замикання, як показано у Блоці коду 19-27, де ми визначили функцію <code>add_one</code>, яка додає один до свого параметра. Функція <code>do_twice</code> приймає два параметри: вказівник на функцію для будь-якої функції, що приймає параметр <code>i32</code> і повертає <code>i32</code>, та інше значення <code>i32</code>. Функція <code>do_twice</code> викликає функцію <code>f</code> двічі, передаючи їй значення <code>arg</code>, а потім додає результати двох викликів. Функція <code>main</code> викликає <code>do_twice</code> з аргументами <code>add_one</code> та <code>5</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;The answer is: {}&quot;, answer);
}
</code></pre></pre>
<p><span class="caption">Блок коду 19-27: використання типу <code>fn</code> для прийняття вказівник на функцію як аргументу</span></p>
<p>Цей код виводить <code>The answer is: 12</code>. Ми вказуємо, що параметр <code>f</code>у <code>do_twice</code> є <code>fn</code>, що приймає один параметр <code>i32</code> і повертає <code>i32</code>. Тоді ми можемо викликати <code>f</code> у тілі <code>do_twice</code>. У <code>main</code> ми можемо передати назву функції <code>add_one</code> першим аргументом <code>do_twice</code>.</p>
<p>На відміну від замикань, <code>fn</code> є типом, а не трейтом, тож ми вказуємо <code>fn</code> як тип параметра безпосередньо, а не заявляємо узагальнений параметр типу одного з трейтів <code>Fn</code>, як обмеження трейту.</p>
<p>Вказівники на функції реалізують усі три трейти замикань (<code>Fn</code>, <code>FnMut</code> і <code>FnOnce</code>), тобто ви завжди можете передати вказівник на функції аргументом до функції, що очікує на замикання. Найкраще писати функції, використовуючи узагальнений тип і один з трейтів замикань, щоб ваші функції могли приймати і функції, і замикання.</p>
<p>До слова, один приклад того, де ви хочете приймати лише <code>fn</code>, а не замикання - це коли ви надаєте інтерфейс зовнішньому коду, що не має замикань: функції C можуть приймати функції як аргументи, але у C немає замикань.</p>
<p>Як приклад того, де ви можете використовувати або визначене на місці замикання, або функцію, подивімося на використання методу <code>map</code> з трейту <code>Iterator</code> у стандартній бібліотеці. Щоб використати функцію <code>map</code> для перетворення вектора чисел на вектор стрічок, ми можемо використати замикання, ось так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}
</span></code></pre></pre>
<p>Або ж ми можемо передати функцію аргументом до <code>map</code> замість замикання, ось так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}
</span></code></pre></pre>
<p>Зверніть увагу, що ми повинні використовувати повністю кваліфікований синтаксис, про який ми говорили раніше у підрозділі <a href="">&quot;Поглиблено про трейти&quot;</a><!-- ignore --> , бо існує багато доступних функцій, що звуться <code>to_string</code>. Тут ми використовуємо функцію <code>to_string</code>, визначену у трейті <code>ToString</code>, який стандартна бібліотека реалізує для будь-якого типу, що реалізує <code>Display</code>.</p>
<p>Згадайте з підрозділу <a href="ch06-01-defining-an-enum.html#enum-values">&quot;Значення енумів&quot;</a><!-- ignore --> Розділу 6, що назва кожного варіанту енуму, який ми визначаємо, також стає функціює ініціалізації. Ми можемо використовувати ці функції ініціалізації як вказівники на функції, які реалізовують трейти замикань, що значить, що функції ініціалізації можуть бути аргументами для методів, що приймають замикання, ось так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}
</span></code></pre></pre>
<p>Тут ми створюємо екземпляри <code>Status::Value</code>, використовуючи кожне значення <code>u32</code> у діапазоні, для якого викликається <code>mao</code>, використовуючи функцію ініціалізації <code>Status::Value</code>. Деякі люди надають перевагу цьому стилю, а деякі люди вважають за краще використовувати замикання. Вони компілюються в однаковий код, тому використовуйте стиль, зрозуміліший для вас.</p>
<h3 id="Повертання-замикань"><a class="header" href="#Повертання-замикань">Повертання замикань</a></h3>
<p>Закриття представлено трейтами, що означає, що ви не можете повертати замикання безпосередньо. У більшості випадків, коли ви могли б повернути трейт, ви можете натомість використовувати конкретний тип, який реалізує трейт, як значення, що повертає функція. Однак ви не можете зробити цього з замиканнями, оскільки у них немає конкретного типу, який можна було б повернути; наприклад, ви не можете використовувати вказівник на функцію <code>fn</code> як типу, що повертається.</p>
<p>Наступний код намагається повернути замикання безпосередньо, але він не компілюється:</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<p>Ось помилка компілятора:</p>
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0746]: return type cannot have an unboxed trait object
 --&gt; src/lib.rs:1:25
  |
1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = note: for information on `impl Trait`, see &lt;https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits&gt;
help: use `impl Fn(i32) -&gt; i32` as the return type, as all return paths are of type `[closure@src/lib.rs:2:5: 2:14]`, which implements `Fn(i32) -&gt; i32`
  |
1 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
  |                         ~~~~~~~~~~~~~~~~~~~

For more information about this error, try `rustc --explain E0746`.
error: could not compile `functions-example` due to previous error
</code></pre>
<p>Помилка знову посилається на трейт <code>Sized</code>! Іржа не знає, скільки місця потрібно для зберігання замикання. Ви вже бачили розв'язок цієї проблеми. Ми можемо скористатися трейтовим об'єктом:</p>
<pre><code class="language-rust noplayground">fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
</code></pre>
<p>Цей код чудово компілюється. Щоб дізнатися більше про трейтові об'єкти, зверніться до підрозділу <a href="">&quot;Використання трейтових об'єктів, що можуть бути значеннями різних типів&quot;</a><!--
ignore --> з Розділу 17.</p>
<p>Далі розгляньмо макроси!
ch19-03-advanced-traits.html#advanced-traits ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Макроси"><a class="header" href="#Макроси">Макроси</a></h2>
<p>Ми використовували макроси на кшталт <code>println!</code> по всій книзі, але досі повністю не розкривали, що таке макроси і як вони працюють. Термін <em>макрос</em> стосується родини особливостей Rust: <em>декларативні</em> макроси за допомогою <code>macro_rules!</code> і три типи *процедурних * макросів:</p>
<ul>
<li>Користувацькі макроси <code>#[derive]</code>, які визначають код, що додається з атрибутом <code>derive</code>, застосованим на структурах та енумах</li>
<li>Атрибутоподібні макроси, що визначають користувацькі атрибути, застосовані до будь-чого</li>
<li>Функцієподібні макроси, що виглядають як функції, але оперують переданими ним як аргумент мовними конструкціями</li>
</ul>
<p>Ми поговоримо про кожен з них по черзі, але спершу погляньмо, чому нам взагалі потрібні макроси, коли ми вже маємо функції.</p>
<h3 id="Відмінність-між-макросами-та-функціями"><a class="header" href="#Відмінність-між-макросами-та-функціями">Відмінність між макросами та функціями</a></h3>
<p>Засадничо макроси є способом писати код, що пише інший код, що також відомо як <em>метапрограмування</em>. У Додатку C ми обговорюємо атрибут <code>derive</code>, який генерує для вас реалізацію різних трейтів. Ми також використовували макроси <code>println!</code> і <code>vec!</code> по всій книзі. Всі ці макроси <em>розгортаються</em>, виробляючи більше коду, ніж написаний вами вручну.</p>
<p>Метапрограмування є корисним для зменшення кількості коду, що вам треба писати та підтримувати, що також є однією з ролей функцій. Однак макроси мають деякі додаткові здібності, яких бракує функціям.</p>
<p>Сигнатура функції має проголосити число і тип її параметрів. Макрос, з іншого боку, може приймати довільне число параметрів: ми можемо викликати <code>println!(&quot;hello&quot;)</code> з одним аргументом чи <code>println!(&quot;hello {}&quot;, name)</code> з двома. Також макроси розгортаються до того, як компілятор інтерпретує значення коду, тож макрос може, наприклад, реалізувати трейт на заданому типі. Функція не може такого, бо її викликають під час виконання, а трейт має бути реалізованим під час компіляції.</p>
<p>Недоліком реалізації макросу замість функції є те, що визначення макросів складніші, ніж визначення функцій, бо ви пишете код на Rust, що пише код на Rust. Через таку опосередкованість визначення макросів у цілому складніше читати, розуміти та підтримувати, ніж визначення функцій.</p>
<p>Ще однією важливою відмінністю між макросами та функціями є те, що ви маєте визначити макроси або принести їх в область видимості <em>до</em> їхнього виклику у файлі, на відміну від функцій, які ви можете визначити будь-де і викликати звідки завгодно.</p>
<h3 id="Декларативні-макроси-проголошені-за-допомогою-macro_rules-для-загального-метапрограмування"><a class="header" href="#Декларативні-макроси-проголошені-за-допомогою-macro_rules-для-загального-метапрограмування">Декларативні макроси, проголошені за допомогою <code>macro_rules!</code>, для загального метапрограмування</a></h3>
<p>Найчастіше використана форма макросів у Rust - <em>декларативні макроси</em>. Їх також іноді називають &quot;макросами за прикладом&quot;, &quot;макросами <code>macro_rules!</code>&quot; чи просто &quot;макросами.&quot; За своєю суттю декларативні макроси дозволяють вам написати щось подібне до виразу Rust <code>match</code>. Як говорилося в Розділі 6, вирази <code>match</code> - це керівні структури, які приймають вираз, зіставляють результат обчислення виразу з шаблонами, а потім виконують код, пов'язаний з відповідним шаблоном. Макроси так само порівнюють значення з шаблонами, які пов'язані з певним кодом: в цій ситуації значенням є літерал початкового коду Rust, переданого макросу; шаблони зіставляються зі структурою цього початкового коду; і код, пов'язаний з кожним шаблоном, коли збігається, замінює код, переданий в макрос. Це все відбувається під час компіляції.</p>
<p>Щоб визначити макрос, використовується конструкція <code>macro_rules!</code>. Дослідимо, як користуватися <code>macro_rules!</code>, подивившися, як визначений макрос <code>vec!</code>. В Розділі 8 розповідалося, як використовувати макрос <code>vec!</code> для створення нового вектора з конкретними значеннями. Наприклад, наступний макрос створить новий вектор, що містить три цілі числа:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p>Ми також можемо використати макрос <code>vec!</code> для створення вектора з двох цілих чисел або вектора з 5 стрічкових слайсів. Ми б не змогли скористатися функцією, щоб зробити те саме, оскільки не знали б кількості або типу значень наперед.</p>
<p>Блок коду 19-28 показує трохи спрощене визначення макросу <code>vec!</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
</code></pre>
<p><span class="caption">Блок коду 19-28: спрощена версія визначення макросу <code>vec!</code></span></p>
<blockquote>
<p>Примітка: Справжнє визначення макросу <code>vec!</code> зі стандартної бібліотеки містить спершу код для розподілу необхідної кількості пам'яті. Цей код є оптимізацією, яку ми не включаємо тут для спрощення прикладу.</p>
</blockquote>
<p>Анотація <code>#[macro_export]</code> вказує, що цей макрос слід зробити доступним кожного разу, коли крейт, у якому його визначено вводиться до області видимості. Без цієї анотації макрос не було б введено до області видимості.</p>
<p>Потім ми почнемо визначення макросу за допомогою <code>macro_rules!</code> і назви макросу, який ми визначаємо, <em>без</em> знаку оклику. За назвою, у цьому випадку <code>vec</code>, слідують фігурні дужки, що позначають тіло визначення макросу.</p>
<p>Структура тіла <code>vec!</code> подібна до структури виразу <code>match</code>. Тут ми маємо один рукав із шаблоном <code>( $( $x:expr ),* )</code>, за яким іде <code>=&gt;</code> і блок коду, пов'язаний із цим шаблоном. Якщо шаблон зіставляється, буде видано пов'язаний блок коду. Оскільки це є єдиним шаблоном у цьому макросі, є лише один коректний спосіб зіставлення; будь-який інший шаблон призведе до помилки. Складніші макроси матимуть більше ніж один рукав.</p>
<p>Правильний синтаксис шаблону у макросах відрізняється від синтаксису шаблону, розглянутого у Розділі 18, оскільки шаблони макросів зіставляються зі структурою коду Rust, а не значеннями. Розберімо, що означають фрагменти шаблону в Блоці коду 19-28; повний синтаксис шаблонів макросів ви можете подивитися в <a href="../reference/macros-by-example.html">Rust Reference</a>.</p>
<p>Спочатку ми використовуємо набір дужок для того, щоб охопити весь шаблон. Ми використовуємо знак долара (<code>$</code>) для проголошення змінної у системі макросів, що міститиме код Rust, що відповідає шаблону. Знак долара дає зрозуміти, що це змінна макросу, а не звичайна змінна Rust. Далі іде набір дужок, що містять значення, що відповідають шаблону в дужках, для використання в коді для заміщення. У <code>$()</code> знаходиться <code>$x:expr</code>, що зіставляється з будь-яким виразом Rust і дає цьому виразу назву <code>$x</code>.</p>
<p>Кома після <code>$()</code> позначає, що символ-розділювач кома може опціонально з'явитися після коду, що зіставляється з кодом у <code>$()</code>. <code>*</code> позначає, що шаблон зіставляється з нулем чи більше того, що іде перед <code>*</code>.</p>
<p>Коли ми викликаємо цей макрос за допомогою <code>vec![1, 2, 3];</code>, шаблон <code>$x</code> зіставляється три рази з трьома виразами <code>1</code>, <code>2</code> і <code>3</code>.</p>
<p>Тепер погляньмо на шаблон у тілі коду, пов'язаного з цим рукавом: <code>temp_vec.push()</code> у <code>$()*</code> генерується для кожної частини, що зіставляється з <code>$()</code> у шаблоні нуль чи більше разів, залежно від того, скільки разів зіставляється шаблон. <code>$x</code> замінюється у кожному зіставленому виразі. Коли ми викликаємо цей макрос за допомогою <code>vec![1, 2, 3];</code>, згенерований код, що замінює виклик макросу, буде таким:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
</code></pre>
<p>Ми визначили макрос, який може прийняти будь-яку кількість аргументів будь-якого типу і може згенерувати код для створення вектора, що містить зазначені елементи.</p>
<p>Щоб дізнатися більше про те, як писати макроси, зверніться до документації в Інтернеті або інших ресурсів, таких як <a href="https://veykril.github.io/tlborm/">&quot;Маленька книжка макросів Rust&quot;</a>, яку розпочав Деніел Кіп та продовжує Лукас Вірт.</p>
<h3 id="Процедурні-макроси-для-генерації-коду-з-атрибутів"><a class="header" href="#Процедурні-макроси-для-генерації-коду-з-атрибутів">Процедурні макроси для генерації коду з атрибутів</a></h3>
<p>Друга форма макросів - це <em>процедурні макроси</em>, які працюють більш схоже на функції (і є типом процедур). Процедурні макроси беруть певний код на вході, працюють над цим кодом і виробляють певний код на виході замість зіставлення з шаблонами і заміни коду іншим кодом, як роблять декларативні макроси. Три види процедурних макросів це користувацькі вивідні, атрибутоподібні та функцієподібні макроси, і всі працюють схожим чином.</p>
<p>При створені процедурних макросів визначення мають розміщуватися у їхньому власному крейті з особливим типом крейта. Так зроблено зі складних технічних причин, які ми сподіваємося усунути в майбутньому. У Блоці коду 19-29 ми показуємо, як визначити процедурний макрос, де <code>some_attribute</code> є заповнювачем для використання конкретного різновиду макросу.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}
</code></pre>
<p><span class="caption">Блок коду 19-29: приклад визначення процедурного макросу</span></p>
<p>Функція, що визначає процедурний макрос, приймає <code>TokenStream</code> на вхід і продукує <code>TokenStream</code> на виході. Тип <code>TokenStream</code> визначений у крейті <code>proc_macro</code>, що постачається разом із Rust, і являє собою послідовність токенів. Це основа макросу: початковий код, з яким працює макрос, є вхідним <code>TokenStream</code>, а код, що макрос продукує, є вихідним <code>TokenStream</code>. Функція також має атрибут, що визначає, який вид процедурного макросу ми створюємо. Можна мати багато видів процедурних макросів в одному крейті.</p>
<p>Подивімося на різні види процедурних макросів. Ми почнемо з користувальницького вивідного макросу, а потім пояснимо невеликі розбіжності, що роблять інші форми відмінними.</p>
<h3 id="Як-писати-користувацький-макрос-derive"><a class="header" href="#Як-писати-користувацький-макрос-derive">Як писати користувацький макрос <code>derive</code></a></h3>
<p>Створімо крейт з назвою <code>hello_macro</code>, що визначає трейт з назвою <code>HelloMacro</code> з однією асоційованою функцією з назвою <code>hello_macro</code>. Замість примушувати користувачів крейту реалізовувати трейт <code>HelloMacro</code> для кожного з їхніх типів, ми надамо процедурний макрос, щоб користувачі могли анотувати свої типи <code>#[derive(HelloMacro)]</code> і отримувати реалізацію функції <code>hello_macro</code> за замовчуванням. Реалізація за замовчуванням виведе <code>Hello, Macro! My name is TypeName!</code>, де <code>TypeName</code> - це назва типу, для якого цей трейт визначено. Іншими словами, ми створимо крейт, за допомогою якого інші програмісти зможуть писати код на кшталт Блоку коду 19-30.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p><span class="caption">Блок коду 19-30: код, який користувачі нашого крету зможуть писати, використовуючи наш процедурний макрос</span></p>
<p>Коли ми закінчимо, цей код виведе <code>Hello, Macro! My name is Pancakes!</code> Перший крок - це створити новий бібліотечний крейт, ось так:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>Далі ми визначаємо трейт <code>HelloMacro</code> і асоційовану функцію:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}
</code></pre>
<p>Ми маємо трейт і його функцію. На цей момент користувач нашого крейта може реалізувати трейт для досягення бажаної функціональності, ось так:</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p>Однак для кожного типу, для якого хочеться використовувати <code>hello_macro</code>, треба написати блок реалізації, а ми хочемо позбавити їх від необхідності це робити.</p>
<p>Додатково, ми ще не в змозі надати реалізацію за замовчуванням для функції <code>hello_macro</code>, яка надрукує назву типу, для якого її реалізовано: Rust не має можливостей рефлексії, так що неможливо дізнатися назву типу під час виконання. Нам потрібен макрос для генерації коду під час компіляції.</p>
<p>Наступний крок - визначити процедурний макрос. На час написання цього, процедурні макроси мають міститися у своїх власних крейтах. Згодом це обмеження може бути зняте. За угодою, крейти і крейти для макросів мають бути такі: для крейту, що зветься <code>foo</code>, крейт з користувацьким вивідним макросом має зватися <code>foo_derive</code>. Почнімо новий крейт, що зветься <code>hello_macro_derive</code>, усередині нашого проєкту <code>hello_macro</code>:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Наші два крейти тісно пов'язані, тому ми створюємо крейт для процедурного макросу в каталозі нашого крейта <code>hello_macro</code>. Якщо ми змінимо визначення трейту в <code>hello_macro</code>, то мусимо також змінити реалізацію процедурного макросу в <code>hello_macro_derive</code>. Два крейти треба буде публікувати окремо, і програмістам, що використовують ці крейти, доведеться додавати обидва як залежності і вводити обидва до області видимості. Ми могли б натомість додати <code>hello_macro_derive</code> як залежність у <code>hello_macro</code> і реекспортувати код процедурного макросу. Однак те, як ми структурували проєкт, надає програмістам можливість використовувати <code>hello_macro</code> навіть якщо вони не хочуть мати функціонал <code>derive</code>.</p>
<p>Нам треба оголосити крейт <code>hello_macro_derive</code> як крейт процедурного макросу. Нам також знадобиться функціонал крейтів <code>syn</code> та <code>quote</code>, як ви побачите за хвилину, тому ми маємо додати їх як залежності. Додайте наступне у файл <em>Cargo.toml</em> для <code>hello_macro_derive</code>:</p>
<p><span class="filename">Файл: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<p>Щоб почати визначення процедурного макросу, розмістіть код з Блоку коду 19-31 у файлі <em>src/lib.rs</em> з крейту <code>hello_macro_derive</code>. Зверніть увагу, що цей код не компілюватиметься, поки ми не додамо визначення для функції <code>impl_hello_macro</code>.</p>
<p><span class="filename">Файл: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}
</code></pre>
<p><span class="caption">Блок коду 19-31: код, який потребують більшість крейтів з процедурними макросами для того, щоб обробляти код Rust</span></p>
<p>Зверніть увагу, що ми розділили код на функцію <code>hello_macro_derive</code>, що відповідає за аналіз <code>TokenStream</code>, і функцію <code>impl_hello_macro</code> що відповідає за перетворення синтаксичного дерева: це робить написання процедурного макросу зручнішим. Код у зовнішній функції (у цьому випадку <code>hello_macro_derive</code>) буде однаковим для майже кожного крейта процедурного макросу, що ви зустрінете або створення. Код, який ви вкажете у тілі внутрішньої функції (у цьому випадку <code>impl_hello_macro</code>), буде різним залежно від призначення вашого процедурного макросу.</p>
<p>Ми додали три нові крейти: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, а <a href="https://crates.io/crates/quote"><code>quote</code></a>. Крейт <code>proc_macro</code> постачається з Rust, тож нам не треба додавати його у залежності у <em>Cargo.toml</em>. Крейт <code>proc_macro</code> - це API компілятора, що дозволяє нам читати та маніпулювати кодом Rust у нашому коді.</p>
<p>Крейт <code>syn</code> розбирає код Rust зі стрічки у структуру даних, з якою ми можемо виконувати операції. Крейт <code>quote</code> перетворює структуру даних <code>syn</code> назад у код Rust. Ці крейти дуже спрощують розбір будь-якого коду Rust, який нам треба обробити: написати повний аналізатор коду Rust - це непросте завдання.</p>
<p>Функцію <code>hello_macro_derive</code> буде викликано, коли користувач нашої бібліотеки зазначить <code>#[derive(HelloMacro)]</code> для типу. Це можливо, тому що ми анотували функцію <code>hello_macro_derive</code> за допомогою <code>proc_macro_derive</code> і вказали назву <code>HelloMacro</code>, яка відповідає назві нашого трейта; цій угоді слідує більшість процедурних макросів.</p>
<p>Функція <code>hello_макро_derive</code> спочатку перетворює <code>input</code> з <code>TokenStream</code> на структури даних, яку ми потім можемо інтерпретувати та працювати з нею. І тут вступає в гру <code>syn</code>. Функція <code>parse</code> із <code>syn</code> приймає <code>TokenStream</code> і повертає структуру <code>DeriveInput</code>, що представляє розібраний код Rust. Блок коду 19-32 показує відповідні частини структури <code>DeriveInput</code>, яку ми отримали розбором стрічки <code>struct Pancakes;</code>:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
</code></pre>
<p><span class="caption">Блок коду 19-32: екземпляр <code>DeriveInput</code>, який ми отримаємо розбором коду, що має атрибут макросу з Блоку коду 19-30</span></p>
<p>Поля цієї структури показують, що код Rust, який ми розібрали, є одиничною структурою з <code>ident</code> (ідентифікатором, тобто назвою) <code>Pancakes</code>. У цієї структури є більше полів для опису різноманітних кодів Rust; зверніться до документації <a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html"><code>syn</code> про <code>DeriveInput</code></a> для детальнішої інформації.</p>
<p>Незабаром ми визначатимемо функцію <code>impl_hello_macro</code>, де ми зберемо новий код Rust, який ми хочемо додати. Але перед тим зауважте, що вихід для нашого макросу - це також <code>TokenStream</code>. <code>TokenStream</code>, що повертається, додається до коду, написаного користувачами нашого крейту, тод коли вони компілюватимуть свої крейти, то отримають додатковий функціонал, наданий нами в зміненому <code>TokenStream</code>.</p>
<p>Ви могли не звернути увагу, що ми викликаємо <code>unwrap</code>, щоб функція <code>hello_macro_derive</code> запанікувала, якщо виклик функції <code>syn::parse</code> буде невдалим. Необхідно, щоб наш процедурний макрос панікував при помилках, бо функції <code>proc_macro_derive</code> мають повертати <code>TokenStream</code>, а не <code>Result</code>, щоб відповідати API процедурних макросів. Ми спростили цей приклад, використовуючи <code>unwrap</code>; у реальному коді ви маєте забезпечувати конкретніші повідомлення про помилки, описуючи, що саме пішло не так за допомогою <code>panic!</code> або <code>expect</code>.</p>
<p>Тепер, коли у нас є код, що перетворює анотований код Rust з <code>TokenStream</code> на екземпляр <code>DeriveInput</code>, згенеруймо код, що реалізує трейт <code>HelloMacro</code> на анотованому типі, як показано у Блоці коду 19-33.</p>
<p><span class="filename">Файл: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">use syn;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Rust code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}!&quot;, stringify!(#name));
            }
        }
    };
    gen.into()
}
</code></pre>
<p><span class="caption">Блок коду 19-33: реалізація трейту <code>HelloMacro</code> за допомогою розібраного коду Rust</span></p>
<p>Ми отримуємо екземпляр структури <code>Ident</code>, що містить назву (ідентифікатор) анотованого типу, використовуючи <code>ast.ident</code>. Структура у Блоці коду 19-32 показує, що коли ми запускаємо функцію <code>impl_hello_macro</code> на коді з Блоку коду 19-30, <code>ident</code>, що ми отримуємо, має поле <code>ident</code> зі значенням <code>&quot;Pancakes&quot;</code>. Таким чином, змінна <code>name</code> з Блоку коду 19-33 міститиме екземпляр структури <code>Ident</code>, який при виведенні стане стрічкою <code>&quot;Pancakes&quot;</code>, назвою структури з Блоку коду 19-30.</p>
<p>Макрос <code>quote!</code> дозволяє нам визначати код Rust, який ми хочемо повернути. Компілятор очікує на щось відмінне від безпосереднього результату виконання макросу <code>quote!</code>, тож ми маємо конвертувати його у <code>TokenStream</code>. Ми це робимо викликом методу <code>into</code>, який <code>TokenStream</code>.</p>
<p>Макрос <code>quote!</code> також надає дуже круті механізми шаблонізації: ми можемо ввести <code>#name</code> і <code>quote!</code> замінить його на значення у змінній <code>name</code>. Ви можете навіть зробити деякі повторення, схожі на те, як працюють звичайні макроси. Зверніться до <a href="https://docs.rs/quote">документації крейту <code>quote</code></a> для детального ознайомлення.</p>
<p>Ми хочемо, щоб наш процедурний макрос генерував реалізацію трейту <code>HelloMacro</code> для анотованого користувачем типи, який ми можемо отримати за допомогою <code>#name</code>. Реалізація трету має одну функцію <code>hello_macro</code>, чиє тіло містить функціональність, яку ми хочемо надати: виводить <code>Hello, Macro! My name is</code> і потім назву анотованого типу.</p>
<p>Використаний тут макрос <code>stringify!</code> вбудований у Rust. Він приймає вираз Rust, такий як <code>1 + 2</code>, і під час компіляції перетворює цей вираз у стрічковий літерал на кшталт <code>&quot;1 + 2&quot;</code>. Це відрізняється від макросів <code>format!</code> чи <code>println!</code>, які обчислюють вираз і потім перетворюють результат на <code>String</code>. Є можливість, що вхідний <code>#name</code> може бути виразом, який треба вивести буквально, тож ми використовуємо <code>stringify!</code>. Використання <code>stringify!</code> також економить розподілену пам'ять, бо перетворює <code>#name</code> на стрічковий літерал під час компіляції.</p>
<p>На цей момент <code>cargo build</code> має успішно завершуватися для обох <code>hello_macro</code> та <code>hello_macro_derive</code>. Під'єднаймо ці крейти до коду з Блок коду 19-30, щоб побачити процедурні макроси в дії! Створіть новий двійковий проєкт у каталозі <em>projects</em> командою <code>cargo new pancakes</code>. Нам треба додати <code>hello_macro</code> та <code>hello_macro_derive</code> як залежності до файлу <em>Cargo.toml</em> крейту <code>pancakes</code>. Якщо ви публікуєте ваші версії <code>hello_macro</code> та <code>hello_macro_derive</code> на <a href="https://crates.io/">crates.io</a>, вони будуть звичайними залежностями; якщо ж ні, ви можете зазначити як залежності із <code>path</code>, ось так:</p>
<pre><code class="language-toml">hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>Помістіть код з Блоку коду 19-30 до <em>src/main.rs</em> і запустіть <code>cargo run</code>: має вивестися <code>Hello, Macro! My name is Pancakes!</code> Реалізація трейту <code>HelloMacro</code> з процедурного макросу була включена без потреби в реалізації у крейті <code>pancakes</code>; анотація <code>#[derive(HelloMacro)]</code> додала реалізацію трейту.</p>
<p>Далі дослідімо, як інші види процедурних макросів відрізняються від користувацьких вивідних макросів.</p>
<h3 id="Атрибутоподібні-макроси"><a class="header" href="#Атрибутоподібні-макроси">Атрибутоподібні макроси</a></h3>
<p>Атрибутоподібні макроси схожі на користувацькі вивідні макроси, але замість генерації коду для атрибута <code>derive</code> вони дозволяють вам створювати нові атрибути. Вони також гнучкіші: <code>derive</code> працює лише зі структурами та енумами; атрибути можна застосовувати також і до інших елементів, наприклад функцій. Ось приклад використання атрибутоподібного макросу: скажімо, ви маєте атрибут з назвою <code>route</code>, що анотує функції при використанні фреймворку вебзастосунків:</p>
<pre><code class="language-rust ignore">#[route(GET, &quot;/&quot;)]
fn index() {
</code></pre>
<p>Цей атрибут <code>#[route]</code> буде визначено фреймворком як процедурний макрос. Сигнатура функції, що визначає макрос, виглядатиме ось так:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
</code></pre>
<p>Тут ми маємо два параметри типу <code>TokenStream</code>. Перший для вмісту атрибута, тобто частини <code>GET, &quot;/&quot;</code>. Другий - це тіло елементу, до якого застосований атрибут, у цьому випадку <code>fn index() {}</code> і решта тіла функції.</p>
<p>Окрім цього, атрибутоподібні макроси працюють так само, як і користувацькі вивідні макроси: ви створюєте крейт із типом крейту <code>proc-macro</code> і реалізуєте функцію, що створює потрібний вам код!</p>
<h3 id="Функцієподібні-макроси"><a class="header" href="#Функцієподібні-макроси">Функцієподібні макроси</a></h3>
<p>Функцієподібні макроси визначають макроси, що виглядають, як виклики функцій. Подібно до макросів <code>macro_rules!</code>, вони гнучкіші за функції; наприклад, вони можуть приймати довільну кількість аргументів. Однак <code>macro_rules!</code> можуть бути визначені лише за допомогою синтаксису, схожого на match, про який ми говорили раніше у підрозділі <a href="ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming">Декларативні макроси, проголошені за допомогою <code>macro_rules!</code>, для загального метапрограмування</a><!-- ignore --> . Функцієподібні макроси приймають параметр <code>TokenStream</code>, а їхнє визначення маніпулює цим <code>TokenStream</code> за допомогою коду Rust, як і два інші типи процедурних макросів. Прикладом функцієподібних макросів може бути макрос <code>sql!</code>, який міг би бути викликаний таким чином:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);
</code></pre>
<p>Цей макрос розбирає інструкції SQL і перевіряє їх на синтаксичну коректність, що значно складніше, ніж обробка, яку може здійснювати <code>macro_rules!</code>. Макрос <code>sql!</code> був би визначений ось так:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre>
<p>Це визначення схоже на сигнатуру користувацького вивідного макросу: ми отримаємо токени, що знаходяться в дужках, і повертаємо код, який нам треба створити.</p>
<h2 id="Підсумок-18"><a class="header" href="#Підсумок-18">Підсумок</a></h2>
<p>Хух! Тепер у вашому інструментарії є функціонал Rust, який ви навряд чи часто використовуватимете, але ви знатимете, що він доступний за певних обставин. Ми ознайомили вас із кількома складними темами, щоб зустрівши їх у пропозиціях у повідомленнях про помилки або в коді інших людей ви могли розпізнати ці концепції та синтаксис. Використовуйте цей розділ як довідник, що приведе вас до рішення.</p>
<p>Далі ми покажемо на практиці все, що ми обговорювали протягом усієї книги, і зробимо ще один проєкт!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Останній-проєкт-збірка-багатопотокового-вебсервера"><a class="header" href="#Останній-проєкт-збірка-багатопотокового-вебсервера">Останній проєкт: збірка багатопотокового вебсервера</a></h1>
<p>Це була довга подорож, та нарешті ми дійшли до кінця книжки. У цьому розділі ми разом зберемо ще один проєкт для демонстрації деяких концепцій, про які йшлося в останніх розділах, а також згадаємо деякі раніші уроки.</p>
<p>Для нашого останнього проєкту ми зробимо вебсервер, що скаже &quot;привіт&quot; і виглядає як Рисунок 20-1 у веббраузері.</p>
<p><img src="img/trpl20-01.png" alt="hello from rust" /></p>
<p><span class="caption">Рисунок 20-1: Наш останній спільний проєкт</span></p>
<p>Ось наш план збірки вебсервера:</p>
<ol>
<li>Дізнатися трохи про TCP та HTTP.</li>
<li>Прослуховувати TCP-підключення на сокеті.</li>
<li>Розібрати невелику кількість HTTP-запитів.</li>
<li>Створити коректну HTTP відповідь.</li>
<li>Поліпшити пропускну здатність нашого сервера за допомогою пула потоків.</li>
</ol>
<p>Перед тим як розпочати, ми маємо згадати про одну деталь: метод, який ми будемо використовувати, не буде найкращим способом створення вебсервера на Rust. Учасники спільноти опублікували ряд готових для використання у виробництві крейтів, доступних на <a href="https://crates.io/">crates.io</a>, які забезпечують повніші реалізації вебсервера та пула потоків, ніж те, що ми збираємо. Однак, наш намір у цьому розділі допомогти вам вчитися, а не іти легким шляхом. Оскільки Rust є системною мовою програмування, ми можемо вибрати рівень абстракції, з яким ми хочемо працювати й можемо піти на нижчий рівень, ніж це можливо чи практично в інших мовах. Тому ми напишемо базовий HTTP-сервер і пул потоків вручну, щоб ви могли вивчити загальні ідеї та техніки, застосовані в крейтах, які ви можете використати в майбутньому.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Збірка-однопотокового-вебсервера"><a class="header" href="#Збірка-однопотокового-вебсервера">Збірка однопотокового вебсервера</a></h2>
<p>Ми розпочнемо з запуску однопотокового вебсервера. Перш ніж почати, розгляньмо короткий огляд протоколів, залучених до створення вебсерверів. Деталі цих протоколів лежать поза межами цієї книги, але короткий огляд надасть вам потрібну інформацію.</p>
<p>Два основні протоколи, залучені у вебсерверах, це <em>Протокол передачі гіпертексту</em> <em>(HTTP)</em> і <em>Протокол керування передаванням</em> <em>(TCP)</em>. Обидва протоколи є <em>протоколами відповіді на запит</em>, тобто <em>клієнт</em> ініціює запити, а <em>сервер</em> слухає запити та надає відповідь клієнту. Вміст цих запитів та відповідей визначається протоколами.</p>
<p>TCP - це протокол нижчого рівня, який описує деталі того, як інформація дістається від одного сервера до іншого, але не вказує, що це за інформація. HTTP є надбудовою над TCP і визначає зміст запитів та відповідей. Технічно можливо використовувати HTTP з іншими протоколами, але переважній більшості випадків HTTP відправляє його дані через TCP. Ми працюватимемо з необробленими байтами TCP та запитами і відповідями HTTP.</p>
<h3 id="Прослуховування-зєднання-tcp"><a class="header" href="#Прослуховування-зєднання-tcp">Прослуховування з'єднання TCP</a></h3>
<p>Наш вебсервер має прослуховувати TCP-з'єднання, тож це буде першою частиною над якою ми працюватимемо. Стандартна бібліотека надає модуль <code>std::net</code>, який дозволить нам це зробити. Створімо новий проєкт у звичний спосіб:</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Тепер введіть код з Блока коду 20-1 у <em>src/main.rs</em> для початку. Цей код прослуховує локальну адресу <code>127.0.0.1:7878</code> на вхідні потоки TCP. Коли він отримує вхідний потік, то виведе <code>Connection established!</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Connection established!&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Блок коду 20-1: прослуховування вхідних потоків і виведення повідомлення, коли прийняли потік</span></p>
<p>За допомогою <code>TcpListener</code> ми можемо прослуховувати TCP-з'єднання за адресою <code>127.0.0.1:7878</code>. У адресі розділ перед двокрапкою є IP-адресою, що представляє ваш комп'ютер (вона однакова для всіх комп'ютерів і не представляє конкретно комп'ютер автора), а <code>7878</code> - порт. Ми обрали цей порт з двох причин: HTTP зазвичай не приймається на цьому порті, тож наш сервер навряд чи конфліктуватиме з іншим вебсервером, що може працювати на вашій машині, і 7878 - це <em>rust</em>, набране на кнопках телефона.</p>
<p>Функція <code>bind</code> у цьому сценарії працює як функція <code>new</code> функція в тому, що повертає новий екземпляр <code>TcpListener</code>. Функція називається <code>bind</code> тому, що в організації мережі підключення до порту для прослуховування відоме як &quot;прив'язування до порту.&quot;</p>
<p>Функція <code>bind</code> повертає <code>Result&lt;T, E&gt;</code>, що позначає, що зв'язування може бути невдалим. Наприклад, для підключення до порту 80 потрібні права адміністратора (не-адміністратори можуть слухати лише порти вище ніж 1023), так що, якщо ми намагались під'єднатися до порту 80 без прав адміністратора, зв'язування не спрацює. Зв'язування також не спрацює, наприклад, якщо ми запустимо два екземпляри нашої програми і відтак матимемо дві програми, що слухають один порт. Оскільки ми пишемо базовий сервер лише для навчальних цілей, ми не турбуватимемося про обробку таких помилок; натомість, ми використаємо <code>unwrap</code>, щоб зупинити програму, якщо виникнуть помилки.</p>
<p>Метод <code>incoming</code> для <code>TcpListener</code> повертає ітератор, який дає нам послідовність потоків (точніше, потоків типу <code>TcpStream</code>). Кожен <em>stream</em> представляє відкрите з'єднання між клієнтом і сервером. З'єднання <em>connection</em> є назвою для усього процесу запиту та відповіді, в якому клієнт підключається до сервера, сервер генерує відповідь, і сервер же закриває з'єднання. Таким чином ми читатимемо з <code>TcpStream</code>, щоб побачити, що надіслав клієнт, а потім писатимемо нашу відповідь до потоку, щоб відправити дані назад до клієнта. Загалом, цей циклу <code>for</code> буде обробляти кожне підключення по черзі і створить ряд потоків, які ми оброблятимемо.</p>
<p>Наразі наша обробка потоку складається з виклику <code>unwrap</code> для припинення нашої програми, якщо потік має будь-які помилки; якщо помилок немає, програма виводить повідомлення. У наступному блоці коду ми додамо більше функціональності для варіанту вдалого з'єднання. Причина, з якої ми можемо отримувати помилки з методу <code>incoming</code>, коли клієнт підключається до сервера це те, що ми насправді ітеруємо не по з'єднаннях. Натомість ми ітеруємо по <em>спробах з'єднання</em>. З'єднання може бути невдалим з ряду причин, багато з них специфічні для різних операційних систем. Наприклад, багато операційних систем мають обмеження на кількість одночасних відкритих підключень, які вони можуть підтримувати; нове спроба підключення після цієї кількості призводитиме до помилки, поки якісь з відкритих підключень не закриються.</p>
<p>Спробуймо запустити цей код! Викличте <code>cargo run</code> у терміналі та завантажите <em>127.0.0.1:7878</em> у веббраузері. Браузер повинен показати повідомлення про помилку на кшталт &quot;З'єднання скинуто&quot;, оскільки сервер поки що не надсилає жодних даних. Але поглянувши в термінал, ви маєте побачити кілька повідомлень, які ми виводимо, коли браузер з'єднується із сервером!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>Іноді ви бачитимете кілька виведених повідомлень на один запит браузера; причина може бути в тому, що браузер запитує сторінку, а також деякі інші ресурси на кшталт піктограми <em>favicon.ico</em>, що показується у вкладці браузера.</p>
<p>Також можливо, що браузер намагається з'єднатися із сервером багато разів, бо сервер не надіслав у відповідь жодних даних. Коли <code>stream</code> виходить з області видимості й очищується в кінці циклу, з'єднання закривається, бо це є частиною реалізації <code>drop</code>. Браузери іноді намагаються повторно з'єднатися із закритими підключеннями, оскільки проблема може бути тимчасовою. Але важливим тут є те, що ми успішно отримали TCP-з'єднання!</p>
<p>Не забудьте зупинити програму, натиснувши <span class="keystroke">ctrl-c</span>, коли ви закінчили працювати з певною версією коду. Потім перезапустіть програму, запустивши команду <code>cargo run</code> після того, як робите кожен набір змін у коді для того, щоб переконатися, що у вас працює найновіший код.</p>
<h3 id="Читання-запиту"><a class="header" href="#Читання-запиту">Читання запиту</a></h3>
<p>А тепер реалізуймо функціональність для читання запиту з браузера! Для поділу інтересів - спершу встановлення з'єднання, а потім вживання якихось дій зі з'єднанням, ми почнемо нову функцію для обробки з'єднань. У цій новій функції <code>handle_connection</code> ми прочитаємо дані з потоку TCP і виведемо їх, щоб ми могли побачити дані. що пересилаються з браузера. Змініть код, щоб він виглядав як у Блоці коду 20-2.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!(&quot;Request: {:#?}&quot;, http_request);
}
</code></pre></pre>
<p><span class="caption">Блок коду 20-2: читання з <code>TcpStream</code> і виведення даних</span></p>
<p>Ми вносимо <code>std::io::prelude</code> і <code>std::io::BufReader</code> до області видимості, щоб отримати доступ до трейтів і типів, що дозволяють нам читати і писати до потоку. У циклі <code>for</code> у функції <code>main</code> замість того, щоб виводити повідомлення про те, що ми встановили з'єднання, тепер ми викликаємо нову функцію <code>handle_connection</code> і передаємо їй <code>stream</code>.</p>
<p>У функції <code>handle_connection</code> ми створюємо новий екземпляр <code>BufReader</code>, який огортає мутабельне посилання на <code>stream</code>. <code>BufReader</code> додає буферизацію, керуючи викликами до трейтових методів <code>std::io::Read</code> замість нас.</p>
<p>Ми створюємо змінну з назвою <code>http_request</code> для збору рядків запиту, що браузер відправляє на наш сервер. Ми позначаємо, що хочемо зібрати ці рядки у вектор, додавши анотацію типу <code>Vec&lt;_&gt;</code>.</p>
<p><code>BufReader</code> реалізує трейт <code>std::io::BufRead</code>, що надає метод <code>lines</code>. Метод <code>lines</code> повертає ітератор <code>Result&lt;String, std::io::Error&gt;</code>, розділяючи потік даних кожного разу, коли він бачить байт нового рядка. Щоб отримати кожен <code>String</code>, ми відображаємо і робимо <code>unwrap</code> для кожного <code>Result</code>. <code>Result</code> може бути помилкою, якщо дані не є коректним UTF-8 або виникли проблеми із читанням з потоку. Знову ж таки, готова програма повинна обробляти ці помилки більш майстерно, але для простоти ми просто зупиняємо програму у випадку помилки.</p>
<p>Браузер сигналізує про кінець запиту на HTTP, надіславши поспіль два символи нового рядка, тож щоб отримати один запит з потоку, ми беремо рядки, доки не отримаємо рядок, що є порожньою стрічкою. Коли ми зберемо рядки у вектор, ми виводимо їх за допомогою гарного форматування для налагодження, щоб ми могли подивитися на інструкції, що веббраузер надсилає на наш сервер.</p>
<p>Спробуймо цей код! Запустіть програму і знову зробіть запит у веббраузері. Зверніть увагу, що ми все ще бачимо сторінку помилку в браузері, але виведення від нашої програми в термінал виглядатиме тепер схожим на це:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    &quot;GET / HTTP/1.1&quot;,
    &quot;Host: 127.0.0.1:7878&quot;,
    &quot;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0&quot;,
    &quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&quot;,
    &quot;Accept-Language: en-US,en;q=0.5&quot;,
    &quot;Accept-Encoding: gzip, deflate, br&quot;,
    &quot;DNT: 1&quot;,
    &quot;Connection: keep-alive&quot;,
    &quot;Upgrade-Insecure-Requests: 1&quot;,
    &quot;Sec-Fetch-Dest: document&quot;,
    &quot;Sec-Fetch-Mode: navigate&quot;,
    &quot;Sec-Fetch-Site: none&quot;,
    &quot;Sec-Fetch-User: ?1&quot;,
    &quot;Cache-Control: max-age=0&quot;,
]
</code></pre>
<p>Залежно від вашого браузера ви можете отримати трохи інше виведення. Тепер, коли ми виводимо дані запиту, ми бачимо, чому ми отримуємо декілька підключень з одного запиту до браузера, дивлячись на шлях за <code>GET</code> в першому рядку запиту. Якщо повторні з'єднання всі запитують <em>/</em>, то ми знатимемо, що браузер повторно намагається отримати <em>/</em>, бо не отримує відповіді від нашої програми.</p>
<p>Розберімо дані цього запиту, щоб зрозуміти, що саме браузер запитує в нашої програми.</p>
<h3 id="Ближчий-погляд-на-http-запит"><a class="header" href="#Ближчий-погляд-на-http-запит">Ближчий погляд на HTTP-запит</a></h3>
<p>HTTP - це протокол на основі тексту і запит використовує такий формат:</p>
<pre><code class="language-text">Метод URI-запит HTTP-версія CRLF
заголовки CRLF
тіло повідомлення
</code></pre>
<p>Перший рядок це рядок <em>рядок запиту</em>, який містить інформацію про те, що саме клієнт запитує. Перша частина рядка запиту позначає на <em>метод</em>, наприклад <code>GET</code> чи <code>POST</code>, який описує як клієнт робить цей запит. Наш клієнт використав запит <code>GET</code>, що означає, що він запитує інформацію.</p>
<p>Наступна частина рядка запиту - це <em>/</em>, що є <em>уніфікованим ідентифікатором ресурсу</em> <em>(Uniform Resource Identifier, URI)</em>, який запитує клієнт: URI це майже те, хоча й не зовсім, що й <em>уніфікований локатор ресурсу</em> <em>(Uniform Resource Locator, URL)</em>. Різниця між URI і URL не є важливою для наших цілей у цьому розділі, але специфікація HTTP використовує термін URI, тому ми тут можемо просто думати про URL замість URI.</p>
<p>Остання частина - це версія HTTP, яку використовує клієнт, а потім рядок запиту закінчується <em>послідовністю CRLF</em>. (CRLF означає <em>повернення каретки</em> і <em>зміна рядка</em>, тобто терміни з часів друкарських машинок!) Послідовність CRLF також записується як <code>\r\n</code>, де<code>\r</code> - повернення каретки, а <code>\n</code> - зміна рядка. Послідовність CRLF відділяє рядок запиту від решти даних запиту. Зверніть увагу, що коли виводиться CRLF, ми бачимо початок нового рядка, а не <code>\r\n</code>.</p>
<p>Дивлячись на дані рядка запиту, який ми отримали, запустивши нашу програму, ми бачимо, що <code>GET</code> - це метод, <em>/</em> - URI запиту і <code>HTTP/1.1</code> - це версія.</p>
<p>Рядки після рядка запиту, починаючи від <code>Host:</code> і далі - це заголовки. Запити <code>GET</code> не мають тіла.</p>
<p>Спробуйте запит з іншого браузера або запросіть іншу адресу, наприклад, <em>127.0.0.1:78/test</em>, щоб побачити, як змінюються дані запиту.</p>
<p>Тепер, коли ми знаємо, що браузер запитує, спробуймо відправити трохи даних у відповідь!</p>
<h3 id="Написання-відповіді"><a class="header" href="#Написання-відповіді">Написання відповіді</a></h3>
<p>Ми збираємось реалізувати виправляння даних у відповідь на запит клієнта. Відповіді мають такий формат:</p>
<pre><code class="language-text">HTTP-версія статус-код фраза-прояснення CRLF
заголовки CRLF
тіло повідомлення
</code></pre>
<p>Перший рядок - це <em>рядок стану</em>, що містить версію HTTP, використану у відповіді, числовий код стану, що підсумовує результат запиту, і фразу-пояснення з текстовим описом коду статусу. Після послідовності CRLF ідуть заголовками, ще одна послідовність CRLF та тіло відповіді.</p>
<p>Ось приклад відповіді, що використовує HTTP версії 1.1, має код стану 200, фразу-пояснення OK, без заголовків і без тіла:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>Код стану 200 це стандартна відповідь про успіх. Цей текст є крихітною успішною відповіддю HTTP. Запишімо її в потік, як нашу відповідь на успішний запит! З функції <code>handle_connection</code> видалімо <code>println!</code>, який друкував дані запиту, і замінімо їх кодом з Блоку коду 20-3.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write_all(response.as_bytes()).unwrap();
}
</code></pre></pre>
<p><span class="caption">Блок коду 20-3: написанні крихітної успішної відповіді HTTP до потоку</span></p>
<p>Перший новий рядок визначає змінну <code>response</code>, яка містить дані повідомлення про успіх. Потім ми викликаємо <code>as_bytes</code> для <code>response</code>, щоб перетворити стрічку даних на байти. Метод <code>write_all</code> для <code>stream</code> приймає <code>&amp;[u8]</code> і відправляє ці байти безпосередньо у з'єднання. Оскільки операція <code>write_all</code> можуть бути невдалою, ми застосовуємо <code>unwrap</code> для будь-яких помилок, як і раніше. Знову ж таки в реальній програмі ви маєте додати тут обробку помилок.</p>
<p>Змінивши так код, запустімо його і зробимо запит. Ми більше не виводимо жодних даних до термінала, тому не побачимо нічого крім того, що виведе Cargo. При завантаженні <em>127.0.0.1:7878</em> у веббраузері ви маєте отримати порожню сторінку замість помилки. Ви щойно своїми руками закодували отримання запиту HTTP і відправлення відповіді!</p>
<h3 id="Повертаємо-справжній-html"><a class="header" href="#Повертаємо-справжній-html">Повертаємо справжній HTML</a></h3>
<p>Реалізуймо функціональність для повернення чогось більшого за порожню сторінку. Створіть новий файл <em>hello.html</em> у кореневій теці вашого проєкту, а не в теці <em>src</em>. Ви можете ввести будь-який HTML за вашим бажанням; Блок коду 20-4 показує одну з можливостей.</p>
<p><span class="filename">Файл: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Блок коду 20-4: зразок HTML файлу для повернення у відповідь</span></p>
<p>Це мінімальний документ HTML5 із заголовком та текстом. Щоб сервер повернув це після отримання запиту, ми змінимо функцію <code>handle_connection</code>, як показано у Блоці коду 20-5, щоб вона читала HTML файл, додавала його до відповіді як тіло і відправляла його.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};
// --snip--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = &quot;HTTP/1.1 200 OK&quot;;
    let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}
</code></pre></pre>
<p><span class="caption">Блок коду 20-5: відправлення вмісту <em>hello.html</em> як тіла відповіді</span></p>
<p>Ми додали <code>fs</code> в інструкцію <code>use</code>, щоб ввести в область видимості модуль файлової системи зі стандартної бібліотеки. Код для читання вмісту файлу до стрічки має бути вам знайомим; ми використовували його в Розділі 12, коли читали вміст файлу для нашого проєкту I/O в Блоці коду 12-4.</p>
<p>Далі, ми використовуємо <code>format!</code>, щоб додати вміст файлу як тіло успішної відповіді. Для забезпечення коректної HTTP відповіді ми додаємо заголовок <code>Content-Length</code>, встановлений у розмір тіла нашої відповіді, у цьому випадку розмір <code>hello.html</code>.</p>
<p>Запустіть цей код за допомогою <code>cargo run</code> і завантажте <em>127.0.0.1:78</em> у браузері; ви повинні побачити зображеним свій HTML!</p>
<p>Наразі ми ігноруємо дані запиту у <code>http_request</code> і лише безумовно відправляємо у відповідь вміст HTML файлу. Це означає, що якщо ви спробуєте запитати <em>127.0.0.1:7878/something-else</em> у своєму браузері, то все одно отримаєте ту ж саму HTML відповідь. На зараз наш сервер украй обмежений і не робить того, що робить більшість вебсерверів. Ми хочемо налаштувати наші відповіді залежно від запиту і відправляти назад HTML файл лише для правильного сформованого запиту <em>/</em>.</p>
<h3 id="Перевірка-запиту-і-вибіркова-відповідь"><a class="header" href="#Перевірка-запиту-і-вибіркова-відповідь">Перевірка запиту і вибіркова відповідь</a></h3>
<p>Зараз наш вебсервер поверне HTML з файлу, незалежно від того, що клієнт запитував. Додамо функціональність для перевірки, чи браузер запитує <em>/</em>, перед поверненням HTML файлу і повертатимемо помилку, якщо браузер запитав щось інше. Для цього нам потрібно змінити <code>handle_connection</code>, як показано у Блоці коду 20-6. Цей новий код порівнює вміст отриманого запиту із тим, як, як ми знаємо, має виглядати запит до <em>/</em>, і додає блоки <code>if</code> та <code>else</code>, щоб нарізно обробляти запити.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == &quot;GET / HTTP/1.1&quot; {
        let status_line = &quot;HTTP/1.1 200 OK&quot;;
        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
        let length = contents.len();

        let response = format!(
            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // some other request
    }
}
</code></pre></pre>
<p><span class="caption">Блок коду 20-6: обробка запитів до <em>/</em> окремо від інших запитів</span></p>
<p>Ми збираємося проглядати лише перший рядок HTTP запиту, тож замість зчитувати весь запит у вектор, ви викликаємо <code>next</code>, щоб отримати перший елемент з ітератора. Перший <code>unwrap</code> обробляє <code>Option</code> і зупиняє програму, якщо ітератор не має елементів. Другий <code>unwrap</code> обробляє <code>Result</code> і має такий самий ефект, що й <code>unwrap</code>, який був у <code>map</code>, доданому в Блоці коду 20-2.</p>
<p>Далі ми перевіряємо, чи <code>request_line</code> дорівнює рядку запиту для запиту GET до шляху <em>/</em>. Якщо це так, блок <code>if</code> поверне вміст нашого HTML файлу.</p>
<p>Якщо <code>request_line</code> <em>не</em> дорівнює GET запиту до шляху <em>/</em>, це означає, що ми отримали якийсь інший запит. Ми додамо код блоку <code>else</code>, щоб відповісти на всі інші запити, за хвилинку.</p>
<p>Запустіть цей код і запросіть <em>127.0.0.1:7878</em>; ви повинні отримати HTML з <em>hello.html</em>. Якщо ви зробите будь-який інший запит, наприклад, <em>127.0.0.1:7878/something-else</em>, то отримаєте помилку з'єднання, схожу на ті, які ви бачили, коли запускали код з Блоків коду 20-1 і 20-2.</p>
<p>Тепер у Блоці коду 20-7 додамо код до блоку <code>else</code>, щоб повернути відповідь з кодом статусу 404, що означає, що запитаний вміст не був знайдений. Також ми повернемо трохи HTML для відображення сторінки в браузері, щоб показати відповідь кінцевому користувачу.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == &quot;GET / HTTP/1.1&quot; {
</span><span class="boring">        let status_line = &quot;HTTP/1.1 200 OK&quot;;
</span><span class="boring">        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --snip--
    } else {
        let status_line = &quot;HTTP/1.1 404 NOT FOUND&quot;;
        let contents = fs::read_to_string(&quot;404.html&quot;).unwrap();
        let length = contents.len();

        let response = format!(
            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 20-7: відповідь з кодом стану 404 і сторінкою помилки, якщо було запитано щось відмінне від <em>/</em></span></p>
<p>Тут наша відповідь має рядок стану з кодом стану 404 і фразу-пояснення <code>NOT FOUND</code>. Тіло відповіді буде HTML з файлу <em>404.html</em>. Вам треба створити файл <em>404.html</em> поруч із <em>hello.html</em> для сторінки помилки; знову ж можете використати будь-який HTML, який бажаєте, чи зразок HTML з Блоку коду 20-8.</p>
<p><span class="filename">Файл: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Блок коду 20-8: зразок вмісту для сторінки, яку відправляють у відповідь із кодом 404</span></p>
<p>Після цих змін запустіть ваш сервер знову. Запит <em>127.0.0.1:7878</em> повинен повернути вміст <em>hello.html</em>, а будь-який інший запит, наприклад <em>127.0.0.1:7878/foo</em>, повинен повернути HTML помилки з <em>404.html</em>.</p>
<h3 id="Трохи-рефакторингу"><a class="header" href="#Трохи-рефакторингу">Трохи рефакторингу</a></h3>
<p>На цей момент блоки <code>if</code> та <code>else</code> мають багато повторень: обидва читають файли і записують вміст файлів до потоку. Єдиною відмінністю є рядок стану й ім'я файлу. Зробімо код виразнішим, витягши ці відмінності в окремі рядки <code>if</code> та <code>else</code>, які присвоять значення рядка стану та імені файлу змінним; тоді ми можемо використати ці змінні безумовно в коді, щоб прочитати файл і записати відповідь. Блок коду 20-9 показує отриманий код після заміни великих блоків <code>if</code> та <code>else</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--
<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == &quot;GET / HTTP/1.1&quot; {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}
</code></pre></pre>
<p><span class="caption">Блок коду 20-9: рефакторизація блоків <code>if</code> та <code>else</code>, щоб містили лише відмінний у двох випадках код</span></p>
<p>Тепер блоки <code>if</code> та <code>else</code> лише повертають відповідні значення для рядка стану й імені файлу в кортежі; далі ми використовуємо деструктуризацію, щоб присвоїти ці два значення змінним <code>status_line</code> і <code>filename</code> скориставшись шаблоном в інструкції <code>let</code>, як пояснювалося в Розділі 18.</p>
<p>Цей раніше дубльований код знаходиться поза межами блоків <code>if</code> та <code>else</code> і використовує змінні <code>status_line</code> і <code>filename</code>. Це дає змогу легше бачити відмінності між двома випадками, і це означає, що у нас є тільки одне місце, щоб змінити код, якщо ми хочемо змінити, як працює читання файлів чи відправлення відповіді. Поведінка коду у Блоці коду 20-9 буде такою ж, як у Блоці коду 20-8.</p>
<p>Блискуче! Тепер ми маємо простий вебсервер з приблизно 40 рядків коду на Rust, що відповідає на один запит сторінкою з вмістом і на всі інші запити відповіддю 404.</p>
<p>Наразі наш сервер працює в одному потоці, тобто він може обслуговувати лише один запит за раз. Дослідимо, чому це може бути проблемою, симулюючи повільні запити. Тоді ми полагодимо цю проблему, щоб наш сервер міг обробляти багато запитів одночасно.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Перетворюємо-наш-однопотоковий-сервер-на-багатопотоковий"><a class="header" href="#Перетворюємо-наш-однопотоковий-сервер-на-багатопотоковий">Перетворюємо наш однопотоковий сервер на багатопотоковий</a></h2>
<p>Зараз наш сервер обробляє кожен запит по черзі, тобто він не обробить друге з'єднання, поки не завершить обробку першого. Якщо сервер отримує більше і більше запитів, це послідовне виконання буде все менш і менш оптимальним. Якщо сервер отримує запит, що обробляється довгий час, наступні запити муситимуть чекати, доки довгий запит не буде завершено, навіть якщо нові запити можна обробити швидко. Нам потрібно буде виправити це, але спершу ми поглянемо на цю проблему в дії.</p>
<h3 id="Симуляція-повільного-запиту-в-поточній-реалізації-сервера"><a class="header" href="#Симуляція-повільного-запиту-в-поточній-реалізації-сервера">Симуляція повільного запиту в поточній реалізації сервера</a></h3>
<p>Ми подивимося на те, як запит з повільною обробкою може вплинути на інші запити, зроблені до нашої поточної реалізації сервера. Блок коду 20-10 реалізує обробку запиту до <em>/sleep</em> з симуляцією повільної реакції, що заблокує сервер у режимі сну на 5 секунд до відповіді.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --snip--

<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
            thread::sleep(Duration::from_secs(5));
            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
        }
        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
    };

    // --snip--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}
</code></pre></pre>
<p><span class="caption">Блок коду 20-10: симуляція повільного запиту режимом сну на 5 секунд</span></p>
<p>Тепер ми перейшли з <code>if</code> на <code>match</code>, бо у нас є три випадки. Ми маємо явно зіставляти слайс з <code>request_line</code> із шаблоном зі стрічковими літералами; <code>match</code> не робить автоматичних посилань і розіменувань, як методи порівняння на рівність.</p>
<p>Перший рукав той же, що й у блоці <code>if</code> з Блоку коду 20-9. Другий рукав зіставляє запит зі <em>/sleep</em>. Коли цей запит отримано, сервер спатиме 5 секунд перед передачею успішної HTML сторінки. Третій рукав той же, що й у блоці <code>else</code> з Блоку коду 20-9.</p>
<p>Ви можете побачити, наскільки примітивними є наш сервер: справжні бібліотеки оброблять розпізнавання кількох запитів у набагато менш розлогий спосіб!</p>
<p>Запустімо сервер командою <code>cargo run</code>. Тоді відкрийте два вікна браузера: одне для <em>http://127.0.0.1:7878/</em>, а інше - для <em>http://127.0.0.1:7878/sleep</em>. Якщо ви введете URL <em>/</em> кілька разів, то, як і раніше, ви побачите, що відповідь надходить швидко. Але якщо ви введете <em>/sleep</em>, а потім завантажте <em>/</em>, ви побачите, що <em>/</em> чекає, доки <code>sleep</code> &quot;проспить&quot; 5 секунд до завантаження.</p>
<p>Існує безліч методів, якими ми могли б скористатися, щоб уникнути гальмування через повільний запит; те, що ми реалізуємо - це пул потоків.</p>
<h3 id="Поліпшення-пропускної-здатності-за-допомогою-пулу-потоків"><a class="header" href="#Поліпшення-пропускної-здатності-за-допомогою-пулу-потоків">Поліпшення пропускної здатності за допомогою пулу потоків</a></h3>
<p><em>Пул потоків</em> - це група породжених потоків, що чекають і готові до обробки завдання. Коли програма отримує нове завдання, то призначає один із потоків з пулу на це завдання, і цей потік обробляє завдання. Решта потоків у пулі доступні, щоб обробити будь-яке інше завдання, що надійде, поки перший потік зайнятий обробкою. Коли перший потік завершить обробку свого завдання, то повернеться до пулу незайнятих потоків, готовий обробляти нове завдання. Пул потоків дозволяє вам обробляти з'єднання конкурентно, збільшуючи пропускну здатність вашого сервера.</p>
<p>Ми обмежимо кількість потоків в пулі невеликим числом, щоб захистити нас від атак на відмову в обслуговуванні (Denial of Service, DoS); якби наша програма створювала по потоку на кожен вхідний запит, то хтось, створивши 10 мільйонів запитів до нашого сервера, може обвалити його, вичерпавши всі його ресурси та призвівши до повної зупинки обробки запитів.</p>
<p>Замість необмеженого породження потоків ми матимемо фіксовану кількість потоків, що чекатимуть у пулі. Вхідні запити надсилатимуться в пул для обробки. Пул підтримуватиме чергу вхідних запитів. Кожен з потоків у пулі братиме запит з цієї черги, оброблятиме його і запитуватиме наступний запит з черги. З таким дизайном ми можемо обробити до <code>N</code> запитів конкурентно, де <code>N</code> є кількістю потоків. Якщо кожен потік відповідатиме на довгий запит, наступні запити все ж накопичуватиметься в черзі, але ми збільшили кількість довгих запитів, які ми можемо обробити до досягнення цього моменту.</p>
<p>Ця техніка - лише один із багатьох способів покращити пропускну здатність вебсервера. Інші варіанти, які ви можете дослідити, включають <em>модель fork/join</em>, <em>однопотокова модель асинхронного I/O</em> та *багатопотокова модель асинхронного I/O *. Якщо ви зацікавилися цією темою, то можете прочитати більше про інші рішення і спробувати реалізувати їх; усі ці варіанти доступні низькорівневій мові на кшталт Rust.</p>
<p>Перед тим, як почати реалізовувати пул тредів, поговоримо про те, як має виглядати його використання. Коли ви намагаєтеся проєктувати код, написання спершу клієнтського інтерфейсу може допомогти керувати проєктуванням. Напишіть API коду, щоб він був структурованим відносно способу його виклику; тоді реалізуйте функціональність відповідно до цієї структури, а не спершу реалізуйте функціональність, а тоді проєктуйте публічний API.</p>
<p>Подібно до того, як ми використовували керовану тестами розробку у проєкті з Розділу 12, ми використаємо тут керовану компілятором розробку. Ми напишемо код, що викликає потрібні нам функції, а потім ми подивимося на помилки компілятора, щоб вирішити, що ми маємо далі змінити, щоб цей код працював. Але перед цим ми дослідимо техніку, яку ми не збираємося використовувати, як відправну точку.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="code-structure-if-we-could-spawn-a-thread-for-each-request"></a></p>
<h4 id="Породження-потоку-для-кожного-запиту"><a class="header" href="#Породження-потоку-для-кожного-запиту">Породження потоку для кожного запиту</a></h4>
<p>Спершу дослідимо, як наш код міг би виглядати, якби створював новий потік для кожного з'єднання. Як зазначено раніше, ми не плануємо так робити через проблеми з потенційним породженням нескінченої кількості потоків, але це вихідна точка, щоб спершу отримати робочий багатопотоковий сервер. Тоді ми покращимо код, додавши пул потоків, і відмінності між двома рішеннями стануть очевиднішими. Блок коду 20-11 показує зміни, які треба внести, щоб <code>main</code> породжував новий потік для обробки кожного потоку у циклі <code>for</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 20-11: породження нового потоку виконання для кожного вхідного потоку</span></p>
<p>Як ви дізналися у Розділі 16, <code>thread::spawn</code> створить новий потік, а потім запустить код у замиканні в цьому новому потоці. Якщо ви запустите цей код і завантажите в браузері <em>/sleep</em>, а тоді <em>/</em> у двох додаткових вкладках браузера, ви й справді побачите, що запит до <em>/</em> не мусить чекати, доки не завершиться <em>/sleep</em>. Однак, як ми згадували, це кінець-кінцем перенавантажить систему, бо нові потоки створюються без будь-яких обмежень.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-similar-interface-for-a-finite-number-of-threads"></a></p>
<h4 id="Створення-скінченної-кількості-потоків"><a class="header" href="#Створення-скінченної-кількості-потоків">Створення скінченної кількості потоків</a></h4>
<p>Ми хочемо, щоб наш пул потоків працював у схожий, знайомий спосіб, щоб перехід з потоків до пулу потоків не вимагав значних змін у коді, що використовує наш API. Блок коду 20-12 показує гіпотетичний інтерфейс для структури <code>ThreadPool</code>, яку ми хочемо використати замість <code>thread::spawn</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 20-12: наш ідеальний інтерфейс <code>ThreadPool</code></span></p>
<p>Ми використовуємо <code>ThreadPool::new</code> для створення нового пулу потоків налаштовуваним числом потоків, у цьому випадку чотирма. Тоді, в циклі <code>for</code> циклу, <code>pool.execute</code> має інтерфейс, подібний до <code>thread::spawn</code> у тому, що він для кожного вхідного потоку приймає замикання, яке пул має виконати. Ми маємо реалізувати <code>pool.execute</code> так, щоб він приймав замикання і передавав його треду в пулі на виконання. Цей код ще не компілюється, але ми спробуємо це зробити, щоб компілятор міг підказати, як це виправити.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="building-the-threadpool-struct-using-compiler-driven-development"></a></p>
<h4 id="Збірка-threadpool-за-допомогою-керованої-компілятором-розробки"><a class="header" href="#Збірка-threadpool-за-допомогою-керованої-компілятором-розробки">Збірка <code>ThreadPool</code> за допомогою керованої компілятором розробки</a></h4>
<p>Внесіть зміни з Блоку коду 20-12 до <em>src/main.rs</em>, а потім використаймо помилки компілятора з <code>cargo check</code> для керування розробкою. Ось яку першу помилку ми отримуємо:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Чудово! Ця помилка говорить, що нам потрібен тип чи модуль <code>ThreadPool</code>, тож ми його створимо. Наша реалізація <code>ThreadPool</code> буде незалежною від виду роботи, що її виконує наш вебсервер. Отже, переробимо крейт <code>hello</code> з двійкового крейта на бібліотеку, де міститиметься наша реалізація <code>ThreadPool</code>. Після перероблення на бібліотечний крейт ми також могли б використати окрему бібліотеку пулу потоків для будь-якої роботи, яку ми хочемо виконати за допомогою пулу потоків, а не лише для обслуговування вебзапитів.</p>
<p>Створіть <em>src/lib.rs</em>, що містить найпростіше визначення структури <code>ThreadPool</code>, яке ми можемо наразі мати:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;
</code></pre>
<p>Далі відредагуйте файл <em>main.rs</em>, щоб ввести <code>ThreadPool</code> до області видимості з бібліотечного крейта, додавши наступний код зверху <em>src/main.rs</em>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}
</span></code></pre>
<p>Цей код все ще не працює, але перевірмо його ще раз, щоб отримати наступну помилку, над якою нам потрібно буде працювати:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Ця помилка означає, що нам необхідно створити для <code>ThreadPool</code> асоційовану функцію з назвою <code>new</code>. Ми також знаємо, що <code>new</code> повинна мати один параметр, який може прийняти <code>4</code> як аргумент і має повернути екземпляр <code>ThreadPool</code>. Реалізуймо найпростішу функцію <code>new</code>, що матиме такі характеристики:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
</code></pre>
<p>Ми обрали типом параметра <code>size</code> тип <code>usize</code>, бо ми знаємо що від'ємна кількість потоків не має сенсу. Ми також знаємо, що ми використаємо 4 як число елементів у колекції потоків, а це саме те, для чого призначений тип <code>usize</code>, як говорилося у підрозділі <a href="ch03-02-data-types.html#integer-types">“Цілі типи”</a><!--
ignore --> Розділу 3.</p>
<p>Ще раз перевіримо код:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |              ^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Тепер стається помилка, бо ми не маємо методу <code>execute</code> на <code>ThreadPool</code>. Згадайте з підрозділу <a href="ch20-02-multithreaded.html#creating-a-finite-number-of-threads">&quot;Створення скінченної кількості потоків&quot;</a><!-- ignore --> , що ми вирішили, що інтерфейс нашого пула тредів має бути схожим на <code>thread::spawn</code>. На додачу ми реалізуємо функцію <code>execute</code>, щоб приймала передане їй замикання і передавало її вільному потоку з пула на виконання.</p>
<p>Ми визначимо метод <code>execute</code> для <code>ThreadPool</code> так, щоб він приймав параметром замикання. Згадайте з підрозділу <a href="">“Переміщення захоплених значень із замикання та трейти <code>Fn</code>”</a><!-- ignore --> Розділу 13, що ми можемо приймати замикання параметрами за допомогою трьох різних трейтів: <code>Fn</code>, <code>FnMut</code> і <code>FnOnce</code>. Ми маємо вирішити, який тип замикань використовується тут. Ми знаємо, що в результаті вийде щось схоже на реалізацію <code>thread::spawn</code> зі стандартної бібліотеки, тож можемо подивитися на обмеження на параметр з сигнатури <code>thread::spawn</code>. Документація показує нам таке:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,
</code></pre>
<p>Тип-параметр <code>F</code> - це те, що нас тут цікавить; тип-параметр <code>T</code> стосується значення, що повертається, і він нас не цікавить. Ми бачимо, що <code>spawn</code> використовує <code>FnOnce</code> як обмеження трейту для <code>F</code>. Ймовірно, це те саме, що нам треба, тому що ми зрештою передамо аргумент, який отримали у <code>execute</code>, до <code>spawn</code>. Ми можемо бути впевнені, що <code>FnOnce</code> - це трейт, який ми хочемо використовувати, оскільки потік для виконання запиту виконає замикання цього запиту тільки один раз, що відповідає <code>Once</code> у <code>FnOnce</code>.</p>
<p>Тип-параметр <code>F</code> також має трейтове обмеження <code>Send</code> і обмеження часу Існування <code>'static</code>, що є корисним у нашій ситуації: нам потрібен <code>Send</code>, щоб передавати замикання від одного потоку до іншого, і <code>'static</code>, бо ми не знаємо, скільки часу виконуватиметься потік. Створімо метод <code>execute</code> для <code>ThreadPool</code>, що прийматиме узагальнений параметр типу <code>F</code> із цими обмеженнями:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
</code></pre>
<p>Ми все ще використовуємо <code>()</code> після <code>FnOnce</code>, бо <code>FnOnce</code> представляє замикання, що не приймає параметрів і повертає одиничний тип <code>()</code>. Як і у визначеннях функцій, тип, що повертається, можна не вказувати у сигнатурі, але навіть якщо ми не маємо параметрів, то все одно потребуємо дужки.</p>
<p>Знову ж таки, це найпростіша реалізація методу <code>execute</code>: вона не робить нічого, але ми намагаємося лише змусити наш код компілюватися. Ще раз перевіримо:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>Компілюється! Але зверніть увагу, що якщо ви спробуєте запустити <code>cargo run</code> і зробити запит у браузері, то побачите в браузері помилки, які ми вже бачили на початку розділу. Наша бібліотека ще не викликає замикання, передане до <code>execute</code>!</p>
<blockquote>
<p>Примітка: ви могли чути, що про мови з жорсткими компіляторами, такими як Haskell and Rust, кажуть &quot;якщо код компілюється, то він працює.&quot; Але це твердження не завжди правильне. Наш проєкт компілюється, але абсолютно нічого не робить! Якби ми збирали реальний, повний проєкт, це був би вдалий час почати написати юніт-тести, щоб перевірити, що код компілюється <em>і</em> має бажану поведінку.</p>
</blockquote>
<h4 id="Валідація-числа-потоків-у-new"><a class="header" href="#Валідація-числа-потоків-у-new">Валідація числа потоків у <code>new</code></a></h4>
<p>Ми ще нічого не робимо з параметрами <code>new</code> та <code>execute</code>. Реалізуймо тіла цих функцій з бажаною для нас поведінкою. Для початку, подумаємо про <code>new</code>. Раніше ми вибрали беззнаковий тип для параметра <code>size</code>, бо пул з від'ємним числом потоків не має сенсу. Однак пул з нулем потоків також не має жодного сенсу, проте нуль є абсолютно валідним <code>usize</code>. Ми додамо код, щоб перевірити, чи <code>size</code> є більшим, ніж нуль, перш ніж повертати екземпляр <code>ThreadPool</code> і змусимо програму паніку якщо вона отримує нуль, використовуючи макрос <code>assert!</code>, як показано в Блоці коду 20-13.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">Блок коду 20-13: реалізація <code>ThreadPool::new</code>, що панікує, якщо <code>size</code> буде нулем</span></p>
<p>Ми також додали трохи документації до нашого <code>ThreadPool</code> документаційним коментарем. Зверніть увагу, що ми слідували за хорошими практиками документації, додавши розділ, який описує ситуації, в яких наша функція може панікувати, як обговорювалося в Розділі 14. Спробуйте запустити <code>cargo doc --open</code> і натисніть на структуру <code>ThreadPool</code>, щоб побачити як виглядає документація для <code>new</code>!</p>
<p>Замість додавати макрос <code>assert!</code>, як ми зробили тут, ми могли б змінити <code>new</code> на <code>build</code> і повертати <code>Result</code>, як ми робили з <code>Config::build</code> у проєкті I/O з Блоку коду 12-9. Але ми вирішили, що в цьому випадку створити пул потоків без жодного потоку має бути невиправною помилкою. Якщо ви почуваєтеся амбітним, спробуйте написати функцію, що зветься <code>build</code>, щоб порівняти з функцією <code>new</code>, з такою сигнатурою:</p>
<pre><code class="language-rust ignore">pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {
</code></pre>
<h4 id="Створення-місця-для-зберігання-потоків"><a class="header" href="#Створення-місця-для-зберігання-потоків">Створення місця для зберігання потоків</a></h4>
<p>Тепер, коли ми можемо переконатися, що маємо валідну кількість потоків для зберігання в пулі, ми можемо створити ці потоки і зберегти їх у структурі <code>ThreadPool</code> перед тим, як її повертати. Але як нам &quot;зберегти&quot; потік? Ще раз погляньмо на сигнатуру <code>thread::spawn</code>:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,
</code></pre>
<p>Функція <code>spawn</code> повертає <code>JoinHandle&lt;T&gt;</code>, де <code>T</code> - тип, що повертає замикання. Спробуймо також використати <code>JoinHandle</code> і побачимо, що вийде. У нашому випадку, замикання, які ми передаємо до пулу потоків, будуть обробляти з'єднання, нічого не повертаючи, так що <code>T</code> буде одинчним типом <code>()</code>.</p>
<p>Код у Блоці коду 20-14 скомпілюється, але ще не створює жодних потоків. Ми змінили визначення <code>ThreadPool</code>, додавши в нього вектор екземплярів <code>thread::JoinHandle&lt;()&gt;</code>, ініціалізували цей вектор об'ємом <code>size</code>, організували цикл <code>for</code>, який виконуватиме певний код для створення потоків, та повернули екземпляр <code>ThreadPool</code>, що містить їх.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">Блок коду 20-14: створення вектора, що містить потоки, у <code>ThreadPool</code></span></p>
<p>Ми ввели до області видимості <code>std::thread</code> з бібліотечного крейта, бо ми використовуємо <code>thread::JoinHandle</code> як тип елементів у векторі у <code>ThreadPool</code>.</p>
<p>Коли отримано валідний розмір, наш <code>ThreadPool</code> створює новий вектор, що може містити <code>size</code> елементів. Функція <code>with_capacity</code> виконує те саме завдання, що й <code>Vec::new</code>, але з важливою відмінністю: вона наперед виділяє місце у векторі. Оскільки ми знаємо, що нам потрібно зберігати <code>size</code> елементів у векторі, цей розподіл наперед є дещо ефективнішим, ніж використання <code>Vec::new</code>, який змінює розмір при вставленні елементів.</p>
<p>Коли ви знову запустите <code>cargo check</code>, він має відпрацювати успішно.</p>
<h4 id="Структура-worker-відповідальна-за-пересилання-коду-з-threadpool-до-потоку"><a class="header" href="#Структура-worker-відповідальна-за-пересилання-коду-з-threadpool-до-потоку">Структура <code>Worker</code>, відповідальна за пересилання коду з <code>ThreadPool</code> до потоку</a></h4>
<p>Ми залишили коментар у циклі <code>for</code> у Блоці коду 20-14 про створення потоків. Тут ми розберемо, як насправді створювати потоки. Стандартна бібліотека уможливлює створення потоків через <code>thread::spawn</code>, який очікує отримати якийсь код, який потік має запустити, щойно його було створено. Однак у нашому випадку ми хочемо створити потоки, що <em>очікують</em> на код, який ми надішлемо пізніше. Реалізація зі стандартної бібліотеки не надає жодного способу це зробити; ми маємо реалізувати його вручну.</p>
<p>Ми реалізуємо таку поведінку, впровадивши нову структуру даних між <code>ThreadPool</code> і потоками, що оброблятиме цю поведінку. Ми назвемо цю структуру даних <em>Worker</em>, що є звичним терміном у реалізації пула. Worker бере код, який потрібно запустити і запускає його в своєму потоці. Уявіть працівників кухні в ресторані: вони чекають, поки не прийде замовлення від клієнтів, і тоді вони відповідають за прийняття цих замовлень і їхнє виконання.</p>
<p>Замість зберігання вектора екземплярів <code>JoinHandle&lt;()&gt;</code> у пулі потоків, Ми зберігатимемо екземпляри структури<code>Worker</code>. Кожен <code>Worker</code> зберігатиме один екземпляр <code>JoinHandle&lt;()&gt;</code>. Тоді ми реалізуємо метод для <code>Worker</code>, який прийматиме замикання з кодом для запуску і відправлятиме його в уже робочий потік на виконання. Також ми надамо кожному worker <code>id</code>, щоб ми могли розрізняти різних worker в пулі для журналювання або налагодження.</p>
<p>Ось новий процес, що відбудеться, коли ми створимо <code>ThreadPool</code>. Ми реалізуємо код, який відправляє замикання в потік після того, як в нас вже є <code>Worker</code>, налаштований таким чином:</p>
<ol>
<li>Визначимо структуру <code>Worker</code>, яка містить <code>id</code> і <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Змінимо <code>ThreadPool</code>, щоб містив вектор екземплярів <code>Worker</code>.</li>
<li>Визначимо функцію <code>Worker::new</code>, що приймає номер <code>id</code> і повертає екземпляр <code>Worker</code>, що містить <code>id</code> та потік, породжений із порожнім замиканням.</li>
<li>У <code>ThreadPool::new</code> ми використовуємо лічильник циклу <code>for</code>, щоб згенерувати <code>id</code>, створити нового <code>Worker</code> з цим <code>id</code>, і зберегти worker у векторі.</li>
</ol>
<p>If you’re up for a challenge, try implementing these changes on your own before looking at the code in Listing 20-15.</p>
<p>Готові? Ось Блок коду 20-15 з одним із можливих способів зробити описані зміни.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">Блок коду 20-15: зміни до <code>ThreadPool</code>, щоб містив екземпляри <code>Worker</code> замість безпосередньо потоків</span></p>
<p>Ми змінили назву поля у <code>ThreadPool</code> з <code>threads</code> на <code>workers</code>, бо воно тепер містить екземпляри <code>Worker</code> замість <code>JoinHandle&lt;()&gt;</code>. Ми використовуємо лічильник циклу <code>for</code> циклі як аргумент <code>Worker::new</code>, і зберігаємо кожен новий <code>Worker</code> у векторі під назвою <code>workers</code>.</p>
<p>Зовнішній код (скажімо, наш сервер з <em>src/main.rs</em>) не має знати деталей реалізації стосовно використання структури <code>Worker</code> у <code>ThreadPool</code>, тож ми робимо структуру <code>Worker</code> і її функцію <code>new</code> приватними. Функція <code>Worker::new</code> використовує <code>id</code>, що ми їй передаємо, і зберігає екземпляр <code>JoinHandle&lt;()&gt;</code>, створений породженням нового потоку за допомогою порожнього замикання.</p>
<blockquote>
<p>Примітка: якщо операційна система не може створити потік через нестачу системних ресурсів, <code>thread::spawn</code> панікуватиме. Це призведе до паніки усього нашого сервера, навіть якщо створення деяких потоків і буде вдалим. Заради простоти ця поведінка прийнятна, але у виробничій реалізації пулу потоків ви, швидше за все, захочете скористатися <a href="../std/thread/struct.Builder.html"><code>std::thread::Builder</code></a><!-- ignore --> і його методом <a href="../std/thread/struct.Builder.html#method.spawn"><code>spawn</code></a><!-- ignore --> , що повертає натомість <code>Result</code>.</p>
</blockquote>
<p>Цей код скомпілюється і зберігатиме кількість екземплярів <code>Worker</code>, яку ми передали як аргумент для <code>ThreadPool::new</code>. Але ми <em>все ще</em> не обробляємо замикання, які ми отримали у <code>execute</code>. Подивімося, як це зробити, далі.</p>
<h4 id="Надсилання-запитів-до-потоків-через-канали"><a class="header" href="#Надсилання-запитів-до-потоків-через-канали">Надсилання запитів до потоків через канали</a></h4>
<p>Наступна проблема, якою ми займемося, полягає в тому, що замикання, передані <code>thread::spawn</code>, не роблять абсолютно нічого. Наразі ми отримуємо замикання, що хочемо виконати, у методі <code>execute</code>. Але ми маємо передати до <code>thread::spawn</code> якесь замикання, коли ми створюємо кожного <code>Worker</code> при створенні <code>ThreadPool</code>.</p>
<p>Ми хочемо, щоб щойно створені структури <code>Worker</code> отримували код з черги, що міститься в <code>ThreadPool</code>, і відправляли цей код у свій потік на виконання.</p>
<p>Канали, про які ми дізналися у Розділі 16 — простий спосіб спілкування між двома потоками — ідеально підходять для цього випадку. Ми скористаємося каналом як чергою завдань, і <code>execute</code> відправить завдання з <code>ThreadPool</code> до екземплярів <code>Worker</code>, які перешлють завдання до своїх потоків. Ось наш план:</p>
<ol>
<li><code>ThreadPool</code> створить канал і утримуватиме відправника.</li>
<li>Кожен <code>Worker</code> утримуватиме отримувача.</li>
<li>Ми створимо нову структуру <code>Job</code>, що міститиме замикання, що їх ми хочемо відправити каналом.</li>
<li>Метод <code>execute</code> відправить завдання, яке треба виконати, через відправника.</li>
<li>У своєму потоці <code>Worker</code> буде в циклі запитувати свого отримувача і виконувати замикання з отриманих завдань.</li>
</ol>
<p>Почнімо з створення каналу в <code>ThreadPool::new</code> та утримання відправника у екземплярі <code>ThreadPool</code>, як показано у Блоці коду 20-16. Структура <code>Job</code> наразі не містить нічого, але буде типом елементів, що їх ми відправляємо каналом.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 20-16: змінюємо <code>ThreadPool</code>, зберігаючи відправника каналу, що передає екземпляри <code>Job</code></span></p>
<p>У <code>ThreadPool::new</code>ми створюємо новий канал і пул тепер містить відправника. Це успішно компілюється.</p>
<p>Спробуймо передати отримувача каналу усім worker, коли пул потоків створює канал. Ми знаємо, що хотіли б використати приймач у потоці, породженому worker, тож ми посилатимемося на параметр <code>receiver</code> у замиканні. Код у Блоці коду 20-17 поки що не компілюється.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">Блок коду 20-17: передавання приймача до worker</span></p>
<p>Ми зробили деякі дрібні і очевидні зміни: ми передаємо приймач до <code>Worker::new</code>, а потім використовуємо його всередині замикання.</p>
<p>Коли ми спробуємо перевірити цей код, то отримаємо таку помилку:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Код намагається передати <code>receiver</code> кільком екземплярам <code>Worker</code>. Так не виходить, бо, як ви пам'ятаєте з Розділу 16, реалізація каналу в Rust має багатьох <em>виробників</em> і одного <em>споживача</em>. Це означає, що ми не можемо просто клонувати споживацький вихід каналу, щоб виправити код. Також ми не хочемо надсилати повідомлення кілька разів декільком споживачам; ми хочемо єдиниц список повідомлень з декількома worker, таким чином, щоб кожне повідомлення було оброблене один раз.</p>
<p>На додачу, приймання завдання з черги в каналі включає зміну <code>receiver</code>, тож потокам потрібен безпечний спосіб спільно використовувати та змінювати <code>receiver</code>; інакше ми можемо отримати стан гонитви (як розповідалося в Розділі 16).</p>
<p>Згадайте потокобезпечні розумні вказівники, про які йшлося в Розділі 16: щоб розділити володіння між кількома потоками і дозволити потокам змінювати значення, нам треба було скористатися <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. Тип <code>Arc</code> дозволить кільком worker володіти приймачем, а <code>Mutex</code> гарантує, що лише один worker отримує завдання з приймача за раз. Блок коду 20-18 показує зміни, які ми маємо зробити.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --snip--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}
</code></pre>
<p><span class="caption">Блок коду 20-18: спільне використання приймача worker за допомогою <code>Arc</code> і <code>Mutex</code></span></p>
<p>У <code>ThreadPool::new</code>, ми розміщуємо приймач у <code>Arc</code> і <code>Mutex</code>. Для кожного нового worker ми клонуємо <code>Arc</code>, щоб збільшити лічильник посилань, щоб worker могли спільно володіти приймачем.</p>
<p>З цими змінами, код компілюється! Ми вже близько!</p>
<h4 id="Реалізація-методу-execute"><a class="header" href="#Реалізація-методу-execute">Реалізація методу <code>execute</code></a></h4>
<p>Нарешті реалізуймо метод <code>execute</code> для <code>ThreadPool</code>. Також ми змінимо <code>Job</code> зі структури на псевдонім типу для трейтового об'єкта, який містить тип замикання, яку приймає <code>execute</code>. Як уже говорилося в підрозділі <a href="">“Створення типів-синонімів за допомогою псевдонімів типів”</a><!-- ignore -->
Розділу 19, псевдоніми типів дозволяють нам скорочувати довгі типи для простоти використання. Подивіться на Блок коду 20-19.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 20-19: створення псевдоніма типу <code>Job</code> для <code>Box</code>, що містить кожне замикання, і відправлення завдання каналом</span></p>
<p>Після створення нового екземпляра <code>Job</code> за допомогою замикання, що ми отримали в <code>execute</code>, ми підправляємо це завдання через вхід каналу. Ми викликаємо <code>unwrap</code> для <code>send</code> на випадок, якщо відправлення буде невдалим. Це може статися якщо, наприклад, ми зупинимо всі потоки, тобто вихід каналу припинить отримувати нові повідомлення. На цей час ми не можемо зупинити наші потоки: вони продовжують виконуватись, доки пул існує. Причина, чому ми використовуємо <code>unwrap</code>, полягає в тому, що ми знаємо, що невдача тут неможлива, але компілятор цього не знає.</p>
<p>Та ми ще не зовсім закінчили! У worker наше замикання, що передається до <code>thread::spawn</code>, лише <em>посилається</em> на вихід каналу. Натомість нам треба, щоб замикання у вічному циклі отримувало з вихідного кінця каналу завдання і після отримання виконувало його. Зробімо зміни, показані в Блоці коду 20-20, у <code>Worker::new</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!(&quot;Worker {id} got a job; executing.&quot;);

            job();
        });

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">Блок коду 20-20: отримання і виконання завдань у потоці worker</span></p>
<p>Тут ми спершу викликаємо <code>lock</code> для <code>receiver</code>, щоб отримати м'ютекс, а потім викликаємо <code>unwrap</code> для паніки, якщо сталася якась помилка. Здійснення блокування може призвести до невдачі, якщо м'ютекс знаходиться у стані <em>poisoned</em>, що може статися, якщо якийсь інший потік запанікував, поки утримував блокування, а не відпустив його. У цій ситуації виклик <code>unwrap</code> для паніки є правильною дією. Можете за бажання змінити <code>unwrap</code> на <code>expect</code> зі змістовним для вас повідомленням про помилку.</p>
<p>Якщо ми отримали блокування м'ютекса, то викличемо <code>recv</code>, щоб отримати <code>Job</code> з каналу. Останній <code>unwrap</code> також покриває всі помилки, що могли виникнути якщо потік, що утримує відправника, завершився, так само як метод <code>send</code> повертає <code>Err</code>, якщо отримувач завершився.</p>
<p>Виклик <code>recv</code> блокує, тож якщо завдань немає, поточний потік чекатиме, доки не з'явиться доступне завдання. <code>Mutex&lt;T&gt;</code> гарантує, що лише один потік <code>worker</code> за раз намагатиметься отримати завдання.</p>
<p>Наш пул потоків нарешті у робочому стані! Виконайте <code>cargo run</code> і зробіть кілька запитів:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --&gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --&gt; src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `hello` (lib) generated 3 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>Успіх! Тепер у нас є пул потоків, який виконує з'єднання асинхронно. Також ніколи не буде створено більше ніж чотири потоки, тому наша система не перенавантажиться, якщо сервер отримає забагато запитів. Якщо ми робимо запит до <em>/sleep</em>, сервер буде мати можливість обслуговувати інші запити, бо їх виконувати буде інший потік.</p>
<blockquote>
<p>Примітка: якщо ви відкриєте <em>/sleep</em> в декількох вікнах браузера одночасно, вони можуть вантажитися по одному з 5-секундним інтервалом. Деякі веббраузери виконують кілька екземплярів одного запиту послідовно для потреб кешування. Це обмеження не викликане нашим вебсервером.</p>
</blockquote>
<p>Після вивчення циклу <code>while let</code> у Розділі 18, ви можете поцікавитися, чому ми не написали код потоку worker, як показано в Блоці коду 20-21.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {id} got a job; executing.&quot;);

                job();
            }
        });

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">Блок коду 20-21: альтернативна реалізація <code>Worker::new</code> за допомогою <code>while let</code></span></p>
<p>Цей код компілюється і запускається, але не дає бажаного багатопотокового результату: повільний запит усе ще змушує інші потоки чекати на обробку. Причина дещо тонка: структура <code>Mutex</code> не має публічного методу <code>unlock</code>, тому що володіння блокуванням базується на часі існування <code>MutexGuard&lt;T&gt;</code> у <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code>, повернутим методом <code>lock</code>. Під час компіляції borrow checker може гарантувати правило, що ресурс, захищений <code>Mutex</code>, не буде доступним, якщо ми не маємо блокування. Однак ця реалізація також призведе до того, що блокування буде утримуватися довше, ніж потрібно, якщо ми не пам'ятаємо про час існування <code>MutexGuard&lt;T&gt;</code>.</p>
<p>Код у Блоці коду 20-20, що робить <code>let job = receiver.lock().unwrap().recv().unwrap();</code>, працює, бо в <code>let</code> будь-які тимчасові значення, використані у правій стороні знаку рівності, негайно очищуються, коли завершується інструкція <code>let</code>. Проте, <code>while let</code> (і <code>if let</code> та <code>match</code>) не очищують тимчасові значення до кінця відповідного блоку. У Блоці коду 20-21 блокування утримується на час виклику <code>job()</code>, тобто інші worker не можуть отримувати завдання.
ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Плавне-вимикання-і-очищення"><a class="header" href="#Плавне-вимикання-і-очищення">Плавне вимикання і очищення</a></h2>
<p>Код у Блоці коду 20-20 відповідає на запити асинхронно, використовуючи пулу потоків, так, як ми й планували. Ми отримуємо деякі попередження про поля <code>workers</code>, <code>id</code>, і <code>threads</code>, які ми не використовуємо напряму, що нагадує нам ми нічого не очищуємо. Коли ми використовуємо менш елегантний метод зупинки основного потоку за допомогою <span
class="keystroke">ctrl-c</span>, решта потоків також негайно зупиняється, навіть якщо ми посередині обробки запиту.</p>
<p>Наступним ми реалізуємо трейт <code>Drop</code>, щоб викликати <code>join</code> для кожного з потоків у пулі, щоб вони могли завершити запити, над якими працюють, перед закриттям. Потім ми реалізуємо спосіб повідомити потокам, що вони мають припинити отримувати нові запити і вимкнутися. Щоб побачити цей код у дії, ми змінимо наш сервер, щоб він приймав лише два запити перед плавним вимиканням пулу потоків.</p>
<h3 id="Реалізація-трейту-drop-для-threadpool"><a class="header" href="#Реалізація-трейту-drop-для-threadpool">Реалізація трейту <code>Drop</code> для <code>ThreadPool</code></a></h3>
<p>Почнімо з реалізації <code>Drop</code> для нашого пулу потоків. Коли пул очищується, всі потоки повинні приєднатися до основного, щоб переконатися, що вони завершили роботу. Блок коду 20-22 показує першу спробу реалізації <code>Drop</code>; цей код ще не зовсім працює.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 20-22: приєднання всіх потоків, коли пул потоків виходить з області видимості</span></p>
<p>Спершу ми в циклі перебираємо всі <code>workers</code> в пулі потоків. Для цього ми використовуємо <code>&amp;mut</code>, бо <code>self</code> є мутабельним посиланням, і ми також мусимо мати можливість змінити <code>worker</code>. Для кожного worker ми виводимо повідомлення, що цей конкретний worker вимикається, а потім викликаємо <code>join</code> для потоку цього worker. Якщо виклик <code>join</code> буде невдалим, ми використовуємо <code>unwrap</code>, щоб Rust запанікував і грубо припинив роботу.</p>
<p>Ось помилка, яку ми отримуємо, коли ми компілюємо цей код:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
    --&gt; src/lib.rs:52:13
     |
52   |             worker.thread.join().unwrap();
     |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
     |             |
     |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait
     |
note: this function takes ownership of the receiver `self`, which moves `worker.thread`

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Ця помилка каже нам, що ми не можемо викликати <code>join</code>, бо ми маємо лише мутабельне позичання кожного <code>worker</code>, а <code>join</code> перебирає володіння своїм аргументом. Щоб вирішити цю проблему, ми маємо перемістити потік з екземпляра <code>Worker</code>, що володіє цим <code>thread</code>, щоб <code>join</code> міг поглинути потік. Ми робили це у Блоці коду 17-15: якщо <code>Worker</code> містить <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>, ми можемо викликати метод <code>take</code> для <code>Option</code>, щоб перемістити значення з варіанту <code>Some</code> і залишити варіант <code>None</code> на своєму місці. Іншими словами, <code>Worker</code>, який працює, матиме варіант <code>Some</code> у <code>thread</code>, і коли ми хочемо очистити <code>Worker</code>, то ми замінимо <code>Some</code> на <code>None</code>, тож <code>Worker</code> не матиме потоку для виконання.</p>
<p>Отож ми знаємо, що хочемо оновити визначення <code>Worker</code> наступним чином:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Тепер покладемося на компілятор, щоб знайти інші місця, які потрібно змінити. При перевірці цього коду ми отримуємо дві помилки:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for enum `Option` in the current scope
  --&gt; src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `Option&lt;JoinHandle&lt;()&gt;&gt;`

error[E0308]: mismatched types
  --&gt; src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^ expected enum `Option`, found struct `JoinHandle`
   |
   = note: expected enum `Option&lt;JoinHandle&lt;()&gt;&gt;`
            found struct `JoinHandle&lt;_&gt;`
help: try wrapping the expression in `Some`
   |
72 |         Worker { id, thread: Some(thread) }
   |                      +++++++++++++      +

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `hello` due to 2 previous errors
</code></pre>
<p>Розберімося з другою помилкою, що вказує, на код в кінці <code>Worker::new</code>; ми маємо обгорнути значення e <code>thread</code> у <code>Some</code>, коли ми створюємо нового <code>Worker</code>. Зробіть такі зміни, щоб виправити цю помилку:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

<span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span>        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>Перша помилка знаходиться у нашій реалізації <code>Drop</code>. Ми вже згадували раніше, що збиралися викликати <code>take</code> для значення <code>Option</code>, щоб перемістити <code>thread</code> з <code>worker</code>. Наступні зміни роблять це:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Як обговорювалося в Розділі 17, метод <code>take</code> для <code>Option</code> забирає варіант <code>Some</code> і залишає <code>None</code> на своєму місці. Ми використовуємо <code>if let</code> для деструктуризації <code>Some</code> і отримуємо потік; тоді ми викликаємо <code>join</code> для потоку. Якщо потік worker вже <code>None</code>, то ми знаємо, що цей worker уже очистив свій потік, тож в цьому випадку нічого не відбудеться.</p>
<h3 id="Подавання-сигналів-потокам-припинити-чекати-на-завдання"><a class="header" href="#Подавання-сигналів-потокам-припинити-чекати-на-завдання">Подавання сигналів потокам припинити чекати на завдання</a></h3>
<p>Після всіх змін, які ми зробили, наш код компілюється без попереджень. Однак, погана новина в тому, що цей код ще не функціонує так, як ми цього хочемо. Причина в логіці в замиканнях, що виконуються в потоках екземплярів <code>Worker</code>: наразі, ми викликаємо <code>join</code>, але це не вимикає потоки, бо їхні цикли <code>loop</code> постійно шукають завдання. Якщо ми спробуємо очистити <code>ThreadPool</code> з нашою поточною реалізацією <code>drop</code>, головний потік заблокується назавжди, чекаючи на завершення першого потоку.</p>
<p>Щоб розв'язати цю проблему нам знадобиться зміна в реалізації <code>drop</code> для <code>ThreadPool</code>, а також зміна в циклі <code>Worker</code>.</p>
<p>Спершу ми змінимо реалізацію <code>drop</code> для <code>ThreadPool</code>, щоб явно очищати <code>sender</code> перед очікуванням на завершення потоків. Блок коду 20-23 показує зміни до <code>ThreadPool</code> для явного очищення <code>sender</code>. Ми використовуємо ту ж техніку <code>Option</code> і <code>take</code>, якою вже користувалися з потоком, щоб перемістити <code>sender</code> зі <code>ThreadPool</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}
// --snip--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        // --snip--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 20-23: явне очищення <code>sender</code> перед приєднанням потоків worker</span></p>
<p>Очищення <code>sender</code> закриває канал, що позначає, що більше повідомлень не буде надіслано. Коли це стається, всі виклики до <code>recv</code>, зроблені worker в нескінченому циклі повернуть помилку. У Блоці коду 20-24 ми змінюємо цикл у <code>Worker</code> на для плавного виходу з циклу в цьому випадку, тобто потоки завершаться, коли реалізація <code>drop</code> для <code>ThreadPool</code> викличе для них <code>join</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.as_ref().unwrap().send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            if let Some(thread) = worker.thread.take() {
</span><span class="boring">                thread.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            match receiver.lock().unwrap().recv() {
                Ok(job) =&gt; {
                    println!(&quot;Worker {id} got a job; executing.&quot;);

                    job();
                }
                Err(_) =&gt; {
                    println!(&quot;Worker {id} disconnected; shutting down.&quot;);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p><span class="caption">Блок коду 20-24: явне переривання циклу, коли <code>recv</code> повертає помилку</span></p>
<p>Щоб побачити цей код в дії, змінімо <code>main</code>, щоб приймати лише два запити перед плавним вимиканням сервера, як показано в Блоці коду 20-25.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = if buffer.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if buffer.starts_with(sleep) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(
</span><span class="boring">        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">        status_line,
</span><span class="boring">        contents.len(),
</span><span class="boring">        contents
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 20-25: вимикання сервера виходом з циклу після обслуговування двох запитів</span></p>
<p>Вам би не сподобалося, якби справжній вебсервер вимикався після обслуговування лише двох запитів. Це код демонструє, що плавне вимикання і очищення працюють, як слід.</p>
<p>Метод <code>take</code>, визначений в трейті <code>Iterator</code>, обмежує ітерації максимум першими двома елементами. <code>ThreadPool</code> вийде з області видимості в кінці <code>main</code> і запуститься реалізація <code>drop</code>.</p>
<p>Запустіть сервер за допомогою <code>cargo run</code>і зробіть три запити. Третій запит призведе до помилки, і у вашому терміналі ви маєте побачити виведення, схоже на це:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>Ви можете побачити іншу послідовність worker і виведених повідомлень. Ми бачимо цих повідомлень, як працює цей код; worker 0 і 3 отримали два перші запити. Сервер припинив приймати з'єднання після другого з'єднання, і реалізація <code>Drop</code> для <code>ThreadPool</code> почала виконуватися до того, як worker 3 розпочав роботу. Очищення <code>sender</code> від'єднує всіх workers і наказує їм вимкнутися. Кожен worker виводить повідомлення при роз'єднанні, і тоді пул потоків викликає <code>join</code>, чекаючи, доки кожен worker завершиться.</p>
<p>Зверніть увагу на один цікавий аспект конкретно цього виконання: <code>ThreadPool</code> очистив <code>sender</code>, і до того, як будь-який worker отримав помилку, ми намагалися приєднати worker 0. Worker 0 ще не отримав помилку від <code>recv</code>, тому основний потік заблокувався, чекаючи на завершення worker 0. Тим часом worker 3 отримав завдання, а потім всі потоки отримали помилку. Коли worker 0 завершив роботу, основний потік зачекав на завершення роботи решти workers. У цей момент, вони всі вийшли з циклів і зупинилися.</p>
<p>Вітання! Ми завершили наш проєкт; у нас є примітивний вебсервер, який використовує пул потоків для асинхронних відповідей. Ми можемо виконати плавне вимикання нашого сервера, яке очищує потоки в пулі.</p>
<p>Ось повний код для звірки:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(
        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
        status_line,
        contents.len(),
        contents
    );

    stream.write_all(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!(&quot;Worker {id} got a job; executing.&quot;);

                    job();
                }
                Err(_) =&gt; {
                    println!(&quot;Worker {id} disconnected; shutting down.&quot;);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>Ми могли б зробити ще більше! Якщо ви хочете продовжити покращувати цей проєкт, ось деякі ідеї:</p>
<ul>
<li>Додати більше документації до <code>ThreadPool</code> та його публічних методів.</li>
<li>Додати тести для функціонала бібліотеки.</li>
<li>Замінити виклики <code>unwrap</code> надійнішою обробкою помилок.</li>
<li>Використати <code>ThreadPool</code> для виконання інших завдань, крім обслуговування вебзапитів.</li>
<li>Знайти крейт пулу потоків на <a href="https://crates.io/">crates.io</a> та реалізувати аналогічний вебсервер за допомогою цього крейта. Тоді порівняти його API і надійність з пулом потоків, реалізованим нами.</li>
</ul>
<h2 id="Підсумок-19"><a class="header" href="#Підсумок-19">Підсумок</a></h2>
<p>Хороша робота! Ви дісталися кінця книги! Ми хочемо подякувати вам за те, що приєдналися до нас у цій подорожі по Rust. Тепер ви готові реалізовувати свої власні проєкти Rust і допомагати іншим людям у їхніх проєктах. Не забувайте, що існує гостинна спільноту Растацеанців, які залюбки допоможуть вам з будь-якими викликами, з якими ви стикаєтеся у подорож по Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Додатки"><a class="header" href="#Додатки">Додатки</a></h1>
<p>Ці додатки містять довідковий матеріал, що стане в пригоді у вашій подорожі мовою Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Додаток-a-ключові-слова"><a class="header" href="#Додаток-a-ключові-слова">Додаток A: ключові слова</a></h2>
<p>Цей список містить ключові слова, зарезервовані для поточного або майбутнього використання в мові Rust. Відтак, вони не можуть використовуватися як ідентифікатори (крім сирих ідентифікаторів, як обговорюється в розділі &quot;<a href="appendix-01-keywords.html#raw-identifiers">Сирі ідентифікатори</a><!-- ignore -->). Ідентифікатори - це імена функцій, змінних, параметрів, полів структур, модулів, крейтів, констант, макросів, статичних значень, атрибутів, типів, трейтів і часів існування.</p>
<h3 id="Ключові-слова-що-використовуються"><a class="header" href="#Ключові-слова-що-використовуються">Ключові слова, що використовуються</a></h3>
<p>Далі наведено список ключових слів, що використовують зараз, з описом їхнього призначення.</p>
<ul>
<li><code>as</code> - виконати примітивне перетворення, прибрати неоднозначність трейта, що містить елемент, чи перейменувати елементи інструкції <code>use</code></li>
<li><code>async</code> -  повернути <code>Future</code> замість блокувати поточний потік</li>
<li><code>await</code> - припинити виконання, доки результат <code>Future</code> не буде готовим</li>
<li><code>break</code> - негайно вийти з циклу</li>
<li><code>const</code> - визначити константу чи константний вказівник</li>
<li><code>continue</code> - продовжити цикл з наступної ітерації</li>
<li><code>crate</code> - у шляху модуля посилається на корінь крейта</li>
<li><code>dyn</code> - динамічна диспетчеризація трейтового об'єкта</li>
<li><code>else</code> - альтернативний рукав для конструкцій керування <code>if</code> та <code>if let</code></li>
<li><code>enum</code> - визначення енума</li>
<li><code>extern</code> - зв'язати зовнішню функцію або змінну</li>
<li><code>false</code> - булевий літерал &quot;хиба&quot;</li>
<li><code>fn</code> - визначити функцію чи тип вказівника на функцію</li>
<li><code>for</code> - цикл по елементах ітератора, реалізувати трейт, чи зазначити більш значущий час існування</li>
<li><code>if</code> - виконати код залежно від умовного виразу</li>
<li><code>impl</code> - реалізувати притаманну функціональність чи трейт</li>
<li><code>in</code> - частина синтаксису циклу <code>for</code></li>
<li><code>let</code> - зв'язати змінну</li>
<li><code>loop</code> - безумовний цикл</li>
<li><code>match</code> - зіставити значення з шаблонами</li>
<li><code>mod</code> - визначити модуль</li>
<li><code>move</code> - передати замиканню володіння усіма захопленими значеннями</li>
<li><code>mut</code> - позначити мутабельність у посиланнях, вказівниках чи шаблонних зв'язуваннях</li>
<li><code>pub</code> - позначити публічну видимість у полях структур, блоках <code>impl</code> та модулях</li>
<li><code>ref</code> - зв'язати за посиланням</li>
<li><code>return</code> - повернення з функції</li>
<li><code>Self</code> - псевдонім типу для типу, який ми визначаємо чи реалізуємо</li>
<li><code>self</code> - суб'єкт методу чи поточний модуль</li>
<li><code>static</code> - глобальна змінна чи час існування, що триває весь час виконання програми</li>
<li><code>struct</code> - визначити структуру</li>
<li><code>super</code> - батьківський модуль відносно поточного</li>
<li><code>trait</code> - визначити трейт</li>
<li><code>true</code> - булевий літерал &quot;правда&quot;</li>
<li><code>type</code> - визначити псевдонім типу чи асоційований тип</li>
<li><code>union</code> - визначити <a href="../reference/items/unions.html">об'єднання</a><!-- ignore -->; є ключовим словом виключно при проголошенні об'єднання</li>
<li><code>unsafe</code> - позначає небезпечний код, функції, трейти чи реалізації</li>
<li><code>use</code> - ввести символи у область видимості</li>
<li><code>where</code> - позначає обмеження типу</li>
<li><code>while</code> - умовний цикл залежно від значення виразу</li>
</ul>
<h3 id="Ключові-слова-зарезервовані-для-використання-в-майбутньому"><a class="header" href="#Ключові-слова-зарезервовані-для-використання-в-майбутньому">Ключові слова, зарезервовані для використання в майбутньому</a></h3>
<p>Наступні ключові слова ще не мають функціональності, та є зарезервованими в Rust для можливого використання у майбутньому.</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="Сирі-ідентифікатори"><a class="header" href="#Сирі-ідентифікатори">Сирі ідентифікатори</a></h3>
<p><em>Сирі ідентифікатори</em> - це синтаксис, що дозволяє використовувати ключові слова там, де зазвичай це заборонено. Для використання сирого ідентифікатора, додайте до ключового слова префікс <code>r#</code>.</p>
<p>Наприклад <code>match</code> є ключовим словом. Якщо ви спробуєте скомпілювати цю функцію, що використовує <code>match</code> як ім'я:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>то отримаєте таку помилку:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>Ця помилка показує, що не можна використати ключове слово <code>match</code> як ідентифікатор функції. Щоб використати <code>match</code> як назву функції, вам доведеться використати синтаксис сирого ідентифікатора, ось так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>Цей код компілюється без помилок. Зверніть увагу, що префікс <code>r#</code> в імені функції є як у визначенні, так і там, де ми викликаємо цю функцію в <code>main</code>.</p>
<p>Сирі ідентифікатори дозволяють вам використовувати будь-яке слово як ідентифікатор, навіть якщо воно зарезервоване як ключове слово. Це надає нам більше свободи для вибору назв ідентифікаторів, а також дозволяє інтегруватися з програмами, написаними мовами, де ці слова не є ключовими. На додачу, сирі ідентифікатори дозволяють вам використовувати бібліотеки, написані в редакціях Rust, що відрізняються від вашого крейта. Наприклад,, <code>try</code> не було ключовим словом у редакції 2015, але стало у редакції 2018. Якщо ви залежите від бібліотеки, що написана в редакції 2015 і має функцію <code>try</code>, вам знадобиться синтаксис сирого ідентифікатора, в цьому випадку <code>r#try</code>, щоб викликати цю функцію з коду в редакції 2018. Див. <a href="appendix-05-editions.html">Додаток E</a><!-- ignore --> щоб отримати більше інформації про редакції.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Додаток-b-оператори-та-символи"><a class="header" href="#Додаток-b-оператори-та-символи">Додаток B: оператори та символи</a></h2>
<p>Цей додаток містить словник синтаксису Rust, включно з операторами та іншими символами, що вживаються самостійно або в контексті шляхів, узагальнених типів, обмежень трейтів, макросів, атрибутів, коментарів, кортежів і дужок.</p>
<h3 id="Оператори"><a class="header" href="#Оператори">Оператори</a></h3>
<p>Таблиця B-1 містить оператори Rust, приклади, як ці оператори вживаються, коротке пояснення, і чи можна перевантажити оператор. Якщо оператор можна перевантажити, то вказаний трейт, який треба використати для перевантаження.</p>
<p><span class="caption">Таблиця B-1: оператори</span></p>
<div class="table-wrapper"><table><thead><tr><th>Оператор</th><th>Приклад</th><th>Пояснення</th><th>Перевантаження?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Макрос</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Побітове чи логічне доповнення</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>Порівняння на нерівність</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Арифметична остача</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Арифметична остача з присвоєнням</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Позичання</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Тип позиченого вказівника</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Побітове І</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>Побітове І з присвоєнням</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>Логічне І зі скороченим обчисленням</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Арифметичне множення</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Арифметичне множення з присвоєнням</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>Розіменування</td><td><code>Deref</code></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Сирий вказівник</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Комбіноване обмеження типу</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Арифметичне додавання</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Арифметичне додавання з присвоєння</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Роздільник аргументів чи елементів</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Обчислення арифметичного протилежного</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Арифметичне віднімання</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Арифметичне віднімання з присвоєнням</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; тип</code>, <code>|...| -&gt; тип</code></td><td>Тип, що повертає функція чи замикання</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>Доступ до члена</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>Діапазонний літерал, не включає праву межу</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>Діапазонний літерал, включає праву межу</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>Оновлення структурного літералу</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>Шаблон зв'язування &quot;і решта&quot;</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>(Застарілий, використовуйте натомість <code>..=</code>) У шаблоні: діапазонний шаблон, включає межу</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Арифметичне ділення</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Арифметичне ділення з присвоєнням</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Обмеження</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Ініціалізатор поля структури</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Мітка циклу</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Завершення структури чи елементу</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Частина синтаксису масиву фіксованого розміру</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>Зсув ліворуч</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>Зсув ліворуч із присвоєнням</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Порівняння менше</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Порівняння менше або дорівнює</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Присвоєення/еквівалентність</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Порівняння рівність</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Частина синтаксису рукава match</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Порівняння більше</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Порівняння більше або дорівнює</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>Зсув праворуч</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>Зсув праворуч із присвоєнням</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>Зв'язування шаблона</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Побітове виключне АБО</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>Побітове виключне АБО з присвоєнням</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>Альтернативні шаблони</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>Побітове АБО</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>Побітове АБО з присвоєнням</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>Логічне АБО зі скороченим обчисленням</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Передавання помилки</td><td></td></tr>
</tbody></table>
</div>
<h3 id="Неоператорні-символи"><a class="header" href="#Неоператорні-символи">Неоператорні символи</a></h3>
<p>Наступний список містить усі символи, що не працюють як оператори; тобто, вони не поводяться як виклик функції чи методу.</p>
<p>Таблиця B-2 показує символи, що вживаються самостійно і є коректними у різних місцях.</p>
<p><span class="caption">Таблиця B-2: окремий синтаксис</span></p>
<div class="table-wrapper"><table><thead><tr><th>Символ</th><th>Пояснення</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Іменований час існування чи мітка циклу</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code> і т.д.</td><td>Числовий літерал певного типу</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>Стрічковий літерал</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code> і т.д.</td><td>Сирий стрічковий літерал, символи екранування не обробляються</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td>Байтовий стрічковий літерал; створює масив байтів замість стрічки</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code> і т.д.</td><td>Сирий байтовий стрічковий літерал, комбінація сирого і байтового стрічкових літералів</td></tr>
<tr><td><code>'...'</code></td><td>Символьний літерал</td></tr>
<tr><td><code>b'...'</code></td><td>Байтовий літерал ASCII</td></tr>
<tr><td><code>|...| expr</code></td><td>Замикання</td></tr>
<tr><td><code>!</code></td><td>Завжди порожній нижній тип для функцій, що не завершуються</td></tr>
<tr><td><code>_</code></td><td>Ігнороване зв'язування в шаблонах; також використовується для читаності цілих літералів</td></tr>
</tbody></table>
</div>
<p>Таблиця B-3 показує символи, що зустрічаються в контексті шляхів до елементу в ієрархії модулів.</p>
<p><span class="caption">Таблиця B-3: синтаксис, що стосується шляхів</span></p>
<div class="table-wrapper"><table><thead><tr><th>Символ</th><th>Пояснення</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Шлях до простору імен</td></tr>
<tr><td><code>::path</code></td><td>Шлях відносно кореня крейта (тобто явно заданий абсолютний шлях)</td></tr>
<tr><td><code>self::path</code></td><td>Шлях відносно поточного модуля (тобто явно заданий відносний шлях).</td></tr>
<tr><td><code>super::path</code></td><td>Шлях відносно батьківського для поточного модуля</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Асоційовані константи, функції та типи</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Асоційований елемент для типу, що не можна прямо назвати (наприклад <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code> і т.д..)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Уточнення неоднозначного виклику методу називанням трейту, що визначає його</td></tr>
<tr><td><code>type::method(...)</code></td><td>Уточнення неоднозначного виклику методу називанням типу, для якого він визначений</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Уточнення неоднозначного виклику методу називанням трейту і типу</td></tr>
</tbody></table>
</div>
<p>Таблиця B-4 показує символи, що зустрічаються в контексті параметрів узагальнених типів.</p>
<p><span class="caption">Таблиця B-4: узагальнення</span></p>
<div class="table-wrapper"><table><thead><tr><th>Символ</th><th>Пояснення</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Вказує параметри до узагальненого типу в типі (наприклад <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Вказує параметри до узагальненого типу, функції чи методу у виразі; часто зветься &quot;турборибою&quot; (наприклад, <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Визначення узагальненої функції</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Визначення узагальненої структури</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Визначення узагальненого енуму</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Визначення узагальненої реалізації</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Обмеження часу існування вищого рівня</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>Узагальнений тип, де один чи більше асоційованих типів мають конкретні значення (наприклад, <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
</div>
<p>Таблиця B-5 показує символи, що зустрічаються в контексті обмеження параметрів узагальненого типу обмеженнями трейта.</p>
<p><span class="caption">Таблиця B-5: Обмеження трейтів</span></p>
<div class="table-wrapper"><table><thead><tr><th>Символ</th><th>Пояснення</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>Узагальнений параметр <code>T</code> обмежений типами, що реалізують <code>U</code></td></tr>
<tr><td><code>Т: 'a</code></td><td>Узагальнений тип <code>T</code> має існувати не коротше за час існування <code>'a</code> (тобто тип не може містити посилання з часом існування, коротшим за <code>'a</code>)</td></tr>
<tr><td><code>T: 'static</code></td><td>Узагальнений тип <code>T</code> не містить позичених посилань, окрім <code>'static</code></td></tr>
<tr><td><code>'b: 'a</code></td><td>Узагальнений час існування <code>'b</code> має існувати не коротше за час існування <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>Дозволити параметру узагальненого типу бути типом з динамічним розміром</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Комбіноване обмеження типу</td></tr>
</tbody></table>
</div>
<p>Таблиця B-6 показує символи, що зустрічаються в контексті виклику чи визначення макросів і зазначення атрибутів елементу.</p>
<p><span class="caption">Таблиця B-6: макроси та атрибути</span></p>
<div class="table-wrapper"><table><thead><tr><th>Символ</th><th>Пояснення</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Зовнішній атрибут</td></tr>
<tr><td><code>#![meta]</code></td><td>Внутрішній атрибут</td></tr>
<tr><td><code>$ident</code></td><td>Підставлення в макросі</td></tr>
<tr><td><code>$ident:kind</code></td><td>Захоплення в макросі</td></tr>
<tr><td><code>$(…)…</code></td><td>Повторення в макросі</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Виклик макросу</td></tr>
</tbody></table>
</div>
<p>Таблиця B-7 показує символи для створення коментарів.</p>
<p><span class="caption">Таблиця B-7: Коментарі</span></p>
<div class="table-wrapper"><table><thead><tr><th>Символ</th><th>Пояснення</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Рядок-коментар</td></tr>
<tr><td><code>//!</code></td><td>Внутрішній документаційний коментар-рядок</td></tr>
<tr><td><code>///</code></td><td>Зовнішній документаційний коментар-рядок</td></tr>
<tr><td><code>/*...*/</code></td><td>Коментар-блок</td></tr>
<tr><td><code>/*!...*/</code></td><td>Внутрішній документаційний коментар-блок</td></tr>
<tr><td><code>/**...*/</code></td><td>Зовнішній документаційний коментар-блок</td></tr>
</tbody></table>
</div>
<p>Таблиця B-8 показує символи, що зустрічаються в контексті використання кортежів.</p>
<p><span class="caption">Таблиця B-8: кортежі</span></p>
<div class="table-wrapper"><table><thead><tr><th>Символ</th><th>Пояснення</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Порожній кортеж (також відомий як одиничний тип), і літерал, і тип</td></tr>
<tr><td><code>(expr)</code></td><td>Вираз у дужках</td></tr>
<tr><td><code>(expr,)</code></td><td>Вираз - кортеж з одного елементу</td></tr>
<tr><td><code>(type,)</code></td><td>Тип - кортеж з одного елементу</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Вираз - кортеж</td></tr>
<tr><td><code>(type, ...)</code></td><td>Тип - кортеж</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>Виклик функції; також використовується для ініціалізації кортежів-структур і кортежів-варіантів енумів</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, і т.д.</td><td>Індексація кортежа</td></tr>
</tbody></table>
</div>
<p>Таблиця B-9 показує контексти, в яких застосовуються фігурні дужки.</p>
<p><span class="caption">Таблиця B-9: Фігурні дужки</span></p>
<div class="table-wrapper"><table><thead><tr><th>Контекст</th><th>Пояснення</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Вираз-блок</td></tr>
<tr><td><code>Type {...}</code></td><td>Літерал структури</td></tr>
</tbody></table>
</div>
<p>Таблиця B-10 показує контексти, в яких застосовуються квадратні дужки.</p>
<p><span class="caption">Таблиця B-10: квадратні дужки</span></p>
<div class="table-wrapper"><table><thead><tr><th>Контекст</th><th>Пояснення</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Літерал масиву</td></tr>
<tr><td><code>[expr; len]</code></td><td>Літерал масиву, що містить <code>len</code> копій <code>expr</code></td></tr>
<tr><td><code>[type; len]</code></td><td>Тип масиву, що містить <code>len</code> екземплярів типу <code>type</code></td></tr>
<tr><td><code>expr[expr]</code></td><td>Індексація колекції. Може бути перевантаженою (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>Індексація колекції, що має виробляти слайс за допомогою <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, or <code>RangeFull</code> як індексу</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="Додаток-c-вивідні-трейти"><a class="header" href="#Додаток-c-вивідні-трейти">Додаток C: вивідні трейти</a></h2>
<p>У різних місцях книги ми обговорювали атрибут <code>derive</code>, який можна застосувати до визначення структури або енуму. Атрибут <code>derive</code> генерує код, що реалізує трейт з власною реалізацією за замовчуванням для типу, який ви позначили за допомогою синтаксичної конструкції <code>derive</code>.</p>
<p>У цьому додатку ми надаємо довідку по всіх трейтах зі стандартної бібліотеки, які ви можете застосовувати за допомогою <code>derive</code>. Кожен розділ покриває:</p>
<ul>
<li>Які оператори та методи дозволить застосування цього трейту</li>
<li>Що робить реалізація трейту, створена за допомогою <code>derive</code></li>
<li>Що реалізація трейту позначає для типу</li>
<li>Умови, за яких вам можна чи не можна реалізовувати трейт</li>
<li>Приклади операцій, що вимагають цього трейту</li>
</ul>
<p>Якщо ви хочете отримати поведінку, відмінну від наданої атрибутом <code>derive</code>, зверніться до <a href="../std/index.html">документації стандартної бібліотеки</a><!-- ignore -->
для кожного трейту, щоб дізнатися подробиці, як реалізувати їх вручну.</p>
<p>Тут наведений повний список трейтів, визначених у стандартній бібліотеці, які можуть бути реалізовані для ваших типів за допомогою <code>derive</code>. Інші трейти, визначені в стандартній бібліотеці, не мають притомної поведінки за замовчуванням, тому ви повинні реалізувати їх так, щоб вони мали сенс для досягнення вашої конкретної мети.</p>
<p>Приклад трейту, який не можна вивести, це <code>Display</code>, що обробляє форматування для кінцевих користувачів. Ви завжди маєте продумати відповідний спосіб, як показати ваш тип кінцевому користувачеві. Які частини типу має кінцевий користувач право бачити? Які частини будуть для них актуальними? Який формат даних буде для них найбільш адекватним? Компілятор Rust не може цього знати, тож не може й забезпечити відповідну поведінку за замовчуванням.</p>
<p>Список вивідних трейтів, наданий у цьому додатку, не є вичерпним: бібліотеки можуть реалізувати <code>derive</code> для своїх власних трейтів, що робить список трейтів, які ви можете використовувати з <code>derive</code>, повністю відкритим. Реалізація <code>derive</code> включає в себе використання процедурного макросу, про що розповідається в підрозділі <a href="ch19-06-macros.html#macros">&quot;Макроси&quot;</a><!-- ignore --> Розділу 19.</p>
<h3 id="debug---форматування-для-програмістів"><a class="header" href="#debug---форматування-для-програмістів"><code>Debug</code> - форматування для програмістів</a></h3>
<p>Трейт <code>Debug</code> надає зневаджувальний формат у рядках форматування, який зазначається додаванням <code>:?</code> у заповнювач <code>{}</code>.</p>
<p>Трейт <code>Debug</code> дозволяє виводити екземпляри типу для цілей зневадження, щоб ви та інші програмісти, які використовують ваш тип, могли переглянути екземпляр у певному місці виконання програми.</p>
<p>Трейт <code>Debug</code> потрібен, наприклад, при використанні макросу <code>assert_eq!</code>. Цей макрос виводить значення екземплярів, переданих йому аргументами, якщо перевірка на рівність не пройшла, щоб програмісти могли побачити, чому два екземпляри не були однаковими.</p>
<h3 id="partialeq-та-eq-для-порівняння-на-рівність"><a class="header" href="#partialeq-та-eq-для-порівняння-на-рівність"><code>PartialEq</code> та <code>Eq</code> для порівняння на рівність</a></h3>
<p>Трейт <code>PartialEq</code> дозволяє вам порівнювати екземпляри типу, щоб перевірити на рівність, і дозволяє використання операторів<code>==</code> та <code>!=</code>.</p>
<p>Виведення <code>PartialEq</code> реалізує метод <code>eq</code>. Коли <code>PartialEq</code> виведено для структури, два екземпляри рівні лише тоді, коли <em>всі</em> поля є рівними, і не рівні, якщо хоча б в одному полі розрізняються. При виведенні на енумах кожен варіант дорівнює собі і не дорівнює іншим варіантам.</p>
<p>Трейт <code>PartialEq</code> потрібен, наприклад, для макросу <code>assert_eq!</code>, який має бути в змозі порівняти два екземпляри типу на рівність.</p>
<p>Трейт <code>Eq</code> не має методів. Його мета - позначити, що кожне значення цього типу дорівнює самому собі. Трейт <code>Eq</code> може застосовуватися лише для типів, які також реалізують <code>PartialEq</code>, хоча не всі типи, що реалізують <code>PartialEq</code>, можуть реалізовувати <code>Eq</code>. Одним прикладом такого типу є числа з рухомою комою: реалізація чисел з рухомою комою позначає, що два екземпляри зі значенням не-число (<code>NaN</code>) не рівні між собою.</p>
<p>Приклад, коли <code>Eq</code> є необхідним, це ключі у <code>HashMap&lt;K, V&gt;</code>, щоб <code>HashMap&lt;K, V&gt;</code> завжди міг визначити, чи два ключі є однаковими.</p>
<h3 id="partialord-та-ord-для-порівнянь-упорядкування"><a class="header" href="#partialord-та-ord-для-порівнянь-упорядкування"><code>PartialOrd</code> та <code>Ord</code> для порівнянь упорядкування</a></h3>
<p>Трейт <code>PartialOrd</code> дозволяє порівнювати екземпляри типу з метою сортування. Для типу, що реалізує <code>PartialOrd</code>, можуть застосовуватися оператори <code>&lt;</code> <code>&gt;</code>, <code>&lt;=</code>та <code>&gt;=</code>. Ви можете застосувати трейт <code>PartialOrd</code> лише для типів, що також реалізують <code>PartialEq</code>.</p>
<p>Виведення <code>PartialOrd</code> реалізує метод <code>partial_cmp</code>, який повертає <code>Option&lt;Ordering&gt;</code>, що буде <code>None</code>, якщо вказані значення неможливо впорядкувати. Приклад значення, яке не можна впорядкувати, навіть якщо більшість значень такого типу можуть бути порівнянні, це значення не-число (<code>NaN</code>) чисел з рухомою комою. Виклик <code>partial_cmp</code> для будь-якого числа з рухомою комою і значення <code>NaN</code> поверне <code>None</code>.</p>
<p>При виведенні для структур <code>PartialOrd</code> порівнює два екземпляри, порівнюючи значення кожного поля у порядку, в якому ці поля присутні у проголошенні структури. При виведенні для енумів, варіанти енуму, проголошені раніше, вважаються меншими, ніж вказані пізніше.</p>
<p>Трейт <code>PartialOrd</code> потрібен, наприклад, методу <code>gen_range</code> з крейту <code>rand</code>, що генерує випадкові значення в інтервалі, заданому інтервальним виразом.</p>
<p>Трейт <code>Ord</code> вказує, для будь-яких двох значень анотованого типу буде існувати коректний порядок. Трейт <code>Ord</code> реалізує метод <code>cmp</code>, який повертає <code>Ordering</code>, а не <code>Option&lt;Ordering&gt;</code>, бо правильний порядок є завжди можливим. Ви можете застосувати трейт <code>Ord</code> лише для типів, які також реалізують <code>PartialOrd</code> і <code>Eq</code> (а <code>Eq</code> вимагає <code>PartialEq</code>). При виведенні на структурах і енумах <code>cmp</code> поводиться так само, як і виведена реалізація <code>partial_cmp</code> для <code>PartialOrd</code>.</p>
<p>Приклад потреби трейту <code>Ord</code> - зберігання значень у <code>BTreeSet&lt;T&gt;</code>, структурі даних, що зберігає дані на основі порядку сортування значень.</p>
<h3 id="clone-і-copy-для-дублікації-даних"><a class="header" href="#clone-і-copy-для-дублікації-даних"><code>Clone</code> і <code>Copy</code> для дублікації даних</a></h3>
<p>Трейт <code>Clone</code> дозволяє явно створити глибоку копію значення, і процес дублікації може містити виконання довільного коду і копіювання даних у купі. Дивіться підрозділ <a href="">“Як взаємодіють змінні з даними: клонування”</a><!-- ignore --> Розділу 4 для додаткової інформації про <code>Clone</code>.</p>
<p>Виведення <code>Clone</code> реалізує метод <code>clone</code>, який при реалізації для всього типу викликає <code>clone</code> для кожної частини типу. Це означає, що всі поля і значення типу мають також реалізовувати <code>Clone</code>, щоб можна було вивести <code>Clone</code>.</p>
<p>Приклад, коли потрібен <code>Clone</code>, це виклик методу <code>to_vec</code> для слайса. Слайс не володіє екземплярами типу, які він містить, але вектор, повернутий з <code>to_vec</code>, мусить володіти своїми екземплярами, тож <code>to_vec</code> викликає <code>clone</code> для кожного елемента. Тож тип, що зберігається в слайсі, має реалізовувати <code>Clone</code>.</p>
<p>Трейт <code>Copy</code> дозволяє вам дублікацію значення, копіюючи біти, збережені в стеку, без жодного довільного коду. Дивіться підрозділ <a href="">“Дані в стеку: копіювання”</a><!-- ignore --> Розділу 4 для додаткової інформації про <code>Copy</code>.</p>
<p>Трейт <code>Copy</code> не визначає жодних методів, щоб не дозволити програмістам перевантажити ці методи і порушити припущення, що додатковий код не буде виконано. Таким чином, всі програмісти можуть виходити з припущення, що копіювання значення є дуже швидким.</p>
<p>Ви можете вивести <code>Copy</code> для будь-якого типу, всі частини якого реалізують <code>Copy</code>. Тип, що реалізує <code>Copy</code>, також має реалізовувати <code>Clone</code>, <code>Copy</code> має тривіальну реалізацію <code>Clone</code>, що робить те саме, що й <code>Copy</code>.</p>
<p>Трейт <code>Copy</code> рідко коли буває потрібна; типи, що реалізовують <code>Copy</code>, мають доступні оптимізації, завдяки яким не треба викликати <code>clone</code>, що робить код більш виразним.</p>
<p>Все, що можливо з <code>Copy</code>, ви також можете досягти за допомогою <code>Clone</code>, але код може бути повільнішим і вам доведеться місцями використовувати <code>clone</code>.</p>
<h3 id="hash-для-відображення-значення-у-значення-фіксованого-розміру"><a class="header" href="#hash-для-відображення-значення-у-значення-фіксованого-розміру"><code>Hash</code> для відображення значення у значення фіксованого розміру</a></h3>
<p>Трейт <code>Hash</code> дозволяє взяти екземпляр типу довільного розміру і відобразити цей екземпляр на значення фіксованого розміру за допомогою геш-функції. Виведення <code>Hash</code> реалізовує метод <code>hash</code>. Виведена реалізація методу <code>hash</code> комбінує результати викликів <code>hash</code> для кожної частини типу, що означає, що всі поля і значення також мають реалізовувати <code>Hash</code> для виведення <code>Hash</code>.</p>
<p>Приклад, коли потрібен <code>Hash</code>, це зберігання ключів у <code>HashMap&lt;K, V&gt;</code>, щоб ефективно зберігати дані.</p>
<h3 id="default-для-значень-за-замовчуванням"><a class="header" href="#default-для-значень-за-замовчуванням"><code>Default</code> для значень за замовчуванням</a></h3>
<p>Трейт <code>Default</code> дозволяє вам створювати значення за замовчуванням для типу. Виведення <code>Default</code> реалізовує функцію <code>default</code>. Виведена реалізація функції <code>default</code> викликає функцію <code>default</code> для кожної частини типу, що означає, що всі поля або значення в типі також повинні реалізовувати <code>Default</code>, щоб можна було вивести <code>Default</code>.</p>
<p>Функція <code>Default::default</code> зазвичай використовується у поєднанні з синтаксисом оновлення структури, про який ідеться в підрозділі <a href="">&quot;Створення екземплярів з інших екземплярів за допомогою синтаксису оновлення структур&quot;</a><!-- ignore -->
Розділу 5. Ви можете виставити кілька полів конструкції, а потім встановити і використати значення за замовчуванням для решти полів за допомогою <code>..Default::default()</code>.</p>
<p>Наприклад, трейт <code>Default</code> необхідний, коли ви використовуєте метод <code>unwrap_or_default</code> для екземплярів <code>Option&lt;T&gt;</code>. Якщо <code>Option&lt;T&gt;</code> має значення <code>None</code>, метод <code>unwrap_or_default</code> поверне результат <code>Default::default</code> для типу <code>T</code>, що знаходиться в <code>Option&lt;T&gt;</code>.
ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax ch04-01-what-is-ownership.html#stack-only-data-copy ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Додаток-d---корисні-інструменти-розробки"><a class="header" href="#Додаток-d---корисні-інструменти-розробки">Додаток D - корисні інструменти розробки</a></h2>
<p>В цьому додатку ми говоримо про деякі корисні інструменти розробки, які надає проєкт Rust. Ми оглянемо автоматичне форматування, швидкі способи застосувати виправлення для попереджень, linter і інтеграцію з IDE.</p>
<h3 id="Автоматичне-форматування-за-допомогою-rustfmt"><a class="header" href="#Автоматичне-форматування-за-допомогою-rustfmt">Автоматичне форматування за допомогою <code>rustfmt</code></a></h3>
<p>Інструмент <code>rustfmt</code> переформатовує ваш код відповідно до стилю коду спільноти. Багато спільних проєктів використовують <code>rustfmt</code> для запобігання суперечкам, який стиль використовувати під час написання Rust: всі форматують свій код за допомогою цього інструменту.</p>
<p>Щоб встановити <code>rustfmt</code>, введіть наступне:</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>Ця команда дає вам <code>rustfmt</code> і <code>cargo-fmt</code>, подібно до того, як Rust дає вам <code>rustc</code> та <code>cargo</code>. Щоб відформатувати будь-який проєкт Cargo, введіть наступне:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Запуск цієї команди переформатує весь код Rust в поточному крейті. Це має змінювати лише стиль коду, а не його семантику. Для отримання додаткової інформації по <code>rustfmt</code> перегляньте <a href="https://github.com/rust-lang/rustfmt">його документацію</a>.</p>
<h3 id="Виправте-ваш-код-за-допомогою-rustfix"><a class="header" href="#Виправте-ваш-код-за-допомогою-rustfix">Виправте ваш код за допомогою <code>rustfix</code></a></h3>
<p>Інструмент rustfix включений у встановлення Rust і може автоматично виправити попередження компілятора, які мають чіткий спосіб виправити проблему, що скоріш за все те, що ви хочете. Ймовірно, ви вже бачили попередження компілятора. Наприклад, розглянемо цей код:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>Тут ми викликаємо функцію <code>do_something</code> 100 разів. але ми ніколи не використовуємо змінну <code>і</code> в тілі циклу <code>for</code>. Rust попереджає нас про це:</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 0..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>Попередження пропонує нам використати <code>_i</code> як назву змінної: підкреслення вказує на те, що не збираємося використовувати цю змінну. Ми можемо автоматично застосувати цю пропозицію, використовуючи інструмент <code>rustfix</code>, запустивши команду <code>cargo fix</code>:</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Коли ми знову подивимось на <em>src/main.rs</em>, то побачимо, що <code>cargo fix</code> змінив код:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>Змінна циклу <code>for</code> тепер називається <code>_i</code>, і попередження більше не з'являється.</p>
<p>Ви також можете використовувати команду <code>cargo fix</code> для перенесення коду між різними редакціями Rust. Про редакції розповідає Додаток E.</p>
<h3 id="Більше-lint-від-clippy"><a class="header" href="#Більше-lint-від-clippy">Більше lint від Clippy</a></h3>
<p>Clippy - це інструмент, що містить набір lint для аналізу вашого коду, щоб ви могли спіймати загальні помилки та поліпшити ваш код на Rust.</p>
<p>Щоб встановити Clippy, введіть наступне:</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>Щоб запустити lint Clippy для будь-якого проєкту Cargo, введіть наступне:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>Наприклад, ви пишете програму, що використовує наближення математичної константи, такої як Пі, як ця програма:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<p>Запуск <code>cargo clippy</code> на цьому проєкті призводить до помилки:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` on by default
  = help: consider using the constant directly
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>Ця помилка повідомляє, що Rust вже має більш точну константу <code>Пі</code> і що ваша програма буде коректнішою, якщо ви скористаєтеся цією константою. Тоді ви зміните свій код, щоб використовувати константу <code>Пі</code>. Наступний код не призводить до помилок або попереджень від Clippy:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<p>Для отримання додаткової інформації про Clippy перегляньте <a href="https://github.com/rust-lang/rust-clippy">його документацію</a>.</p>
<h3 id="Інтеграція-в-ide-за-допомогою-rust-analyzer"><a class="header" href="#Інтеграція-в-ide-за-допомогою-rust-analyzer">Інтеграція в IDE за допомогою <code>rust-analyzer</code></a></h3>
<p>Для покращення інтеграції в IDE спільнота Rust рекомендує використовувати <a href="https://rust-analyzer.github.io"><code>rust-analyzer</code></a><!-- ignore -->. Цей інструмент є набором довколокомпіляторних утиліт, що спілкуються за допомогою <a href="http://langserver.org/">Language Server Protocol</a><!--
ignore -->, що є специфікацією для IDE і мов програмування для взаємного спілкування. Різні клієнти можуть використовувати </p>
<p><code>rust-analyzer</code>, наприклад <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">the Rust analyzer plug-in for Visual Studio Code</a>.</p>
<p>Відвідайте <a href="https://rust-analyzer.github.io">домашню сторінку проєкту</a> <code>Rust-analyzer</code> на<!-- ignore -->
для інструкцій з установки, потім встановіть підтримку мовного сервера у вашому IDE. Ваше IDE набуде можливостей, таких, як автодоповнення, перехід до визначення і вбудовані помилки.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Додаток-e---видання"><a class="header" href="#Додаток-e---видання">Додаток E - видання</a></h2>
<p>У розділі 1 ви бачили, що <code>cargo new</code> додає трохи метаданих до файлу <em>Cargo.toml</em> стосовно видання (edition). Цей додаток пояснює, що це означає!</p>
<p>Мова Rust і компілятор мають шеститижневий цикл випуску, що означає, що користувачі отримують постійний потік нового функціоналу. Інші мови програмування випускають великі зміни і рідше; Rust випускає менші оновлення частіше. За певний час, усі ці маленькі зміни накопичуються. Але від випуску до випуску може бути складно озирнутися і сказати &quot;Ух, між Rust 1.10 та Rust 1.31, Rust так сильно змінився!&quot;</p>
<p>Кожні два чи три роки команда Rust випускає нове <em>видання</em> Rust. Кожне видання збирає функціонал, що утворює чіткий пакет, з повністю оновленою документацією та інструментарієм. Нові видання постачаються як частина звичайного шеститижневого процесу випусків.</p>
<p>Видання слугують різним цілям для різних людей:</p>
<ul>
<li>Для активних користувачів Rust нове видання збирає накопичені зміни у легкозрозумілий пакет.</li>
<li>Для некористувачів, нове видання подає сигнал, що сталися якісь суттєві досягнення, завдяки чому Rust, можливо, став вартим більшої уваги.</li>
<li>Для тих, хто розробляє Rust, нове видання надає точку відліку для процесу в цілому.</li>
</ul>
<p>На час написання цього, доступні три видання Rust: Rust 2015, Rust 2018 і Rust 2021. Ця книжка написана з використанням ідіом видання Rust 2021.</p>
<p>Ключ <code>edition</code> у <em>Cargo.toml</em> указує, яке видання компілятор має використати для вашого коду. Якщо ключа немає, Rust використовує <code>2015</code> як значення видання з міркувань зворотної сумісності.</p>
<p>Кожен проєкт може обрати видання, відмінне від видання 2015 за умовчанням. Видання можуть містити несумісні зміни, такі як появу нового ключового слова, що конфілктує із ідентифікаторами в коді. Однак, якщо ви не погодитеся на ці зміни, ваш код буде продовжувати компілюватися, навіть коли ви оновите версію компілятора Rust, яку ви використовуєте.</p>
<p>Всі версії компілятора Rust підтримують усі видання, що існували до випуску цього компілятора, і вони можуть зв'язувати крейти усіх підтримуваних видань. Зміни видання лише впливають на те, як компілятор початково розбирає код. Таким чином, якщо ви використовуєте Rust 2015, а одна з ваших залежностей використовує Rust 2018, ваш проєкт скомпілюється і зможе використовувати цю залежність. Зворотна ситуація, де ваш проєкт використовує Rust 2018, а залежність використовує Rust 2015, теж працює.</p>
<p>Одразу зазначимо: більшість функціонала доступно у всіх виданнях. Розробники, що використовують будь-яку редакцію Rust, продовжать бачити покращення, коли виходитимуть нові стабільні випуски. Однак у певних випадках, переважно коли додаються нові ключові слова, деякий новий функціонал може бути доступним лише в пізніших виданнях. Вам доведеться перемкнути видання, щоб мати повну змогу використовувати такий функціонал.</p>
<p>Для більш докладної інформації, <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Edition Guide</em></a> є вичерпною книжкою про видання, де перелічуються відмінності між виданнями та пояснюється, як автоматично оновити код до нової редакції за допомогою <code>cargo fix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Додаток-f-Переклади-Книги"><a class="header" href="#Додаток-f-Переклади-Книги">Додаток F: Переклади Книги</a></h2>
<p>Ресурси іншими мовами. Більшість з них не завершена; прогляньте <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">позначки стану перекладу</a>, щоб долучитися чи дати нам знати про новий переклад!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">简体中文</a></li>
<li><a href="https://github.com/rust-tw/book-tw">正體中文</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">альтернативна</a></li>
<li><a href="https://github.com/EmanueleGurini/book_it">Italiano</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/pomokhtari/rust-book-fa">Farsi</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">हिंदी</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">ไทย</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Danske</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Додаток-g---як-робиться-rust-і-щонічний-rust"><a class="header" href="#Додаток-g---як-робиться-rust-і-щонічний-rust">Додаток G - як робиться Rust і &quot;щонічний Rust&quot;</a></h2>
<p>Цей додаток розповідає про те, як робиться Rust і як це впливає на вас як на розробника на Rust.</p>
<h3 id="Стабільність-без-застою"><a class="header" href="#Стабільність-без-застою">Стабільність без застою</a></h3>
<p>Як мова, Rust <em>багато</em> піклується про стабільність вашого коду. Ми хочемо, щоб Rust був якомога надійнішим фундаментом, на якому ви зможете будувати, і якби все постійно змінювалося, це було б неможливо. У той самий час ми, якщо ми не зможемо експериментувати з новим функціоналом, то можемо пропустити важливі недоліки аж до їхнього релізу, коли ми вже не зможемо це змінити.</p>
<p>Наше розв'язання цієї проблеми - це те, що ми звемо &quot;стабільність без застою&quot;, і наш керівний принцип такий: ви ніколи не маєте боятися оновлення до нової версії стабільного Rust. Кожне оновлення має бути безболісним, але також має приносити нові можливості, менше помилок і швидший час компіляції.</p>
<h3 id="Ту-туу-Канали-оновлення-і-залізничний-розклад"><a class="header" href="#Ту-туу-Канали-оновлення-і-залізничний-розклад">Ту-туу! Канали оновлення і залізничний розклад</a></h3>
<p>Розробка Rust відбувається за <em>залізничним розкладом</em>. Тобто вся розробка робиться в гілці <code>master</code> репозиторію Rust. Релізи слідують залізничній моделі випусків програмного забезпечення (software release train model), яку використовують Cisco IOS та інші проєкти програмного забезпечення. Існують три <em>канали релізів</em> Rust:</p>
<ul>
<li>Щонічний (nightly)</li>
<li>Бета (beta)</li>
<li>Стабільний (stable)</li>
</ul>
<p>Більшість розробників Rust в переважно використовують стабільний канал, але ті, хто хоче спробувати експериментальні нові функції, можуть використовувати щонічний або бету.</p>
<p>Ось приклад того, як працює процес розробки та релізів: припустімо, що команда Rust працює над релізом Rust 1.5. Цей реліз відбувся у грудні 2015 року, але він забезпечить нам реалістичні номери версій. У Rust додається новий функціонал: новий коміт з'являється у гілці <code>master</code>. Кожної ночі виробляється нова щонічна версія Rust. Кожен день відбувається реліз, і ці релізи створюються автоматично нашою інфраструктурою релізів. Тож із плином часу наші релізи виглядають ось так, по одному за ніч:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>Кожні шість тижнів настає час підготувати новий реліз! Гілка <code>beta</code> у репозиторію Rust відгалужується від гілки <code>master</code>, що належить щонічній версії. Тепер є два релізи:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>Більшість користувачів Rust не використовують бета-релізи активно, а лише тестують на беті у своїх системах неперервної інтеграції (CI), щоб допомогти Rust знайти можливі регресії. Тим часом нові щонічні релізи з'являються кожної ночі:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Припустимо, було знайдено регресію. Добре, що ми мали якийсь час для перевірки бета-релізу перед тим, як регресія прокралася до стабільного реліз! Виправлення застосовується до <code>master</code>, тож тепер щонічна версія виправлена, а потім виправлення переноситься (backport) у <code>бета-гілку</code> і робиться реліз:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>Шість тижнів минуло після створення першої бети, настав час для стабільної версії! <code>Стабільна</code> гілка робиться з гілки <code>beta</code>:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>Ура! Rust 1.5 зроблено! Проте ми забули одну річ: оскільки минуло шість тижнів, нам також потрібна нова бета <em>наступної</em> версії Rust, 1.6. Тож після того, як <code>стабільна</code> версія відгалужується від <code>бети</code>, наступна версія <code>бети</code> знову відгалужується від <code>щонічної</code> версії:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>Це зветься &quot;залізничною моделлю&quot;, тому що кожні шість тижнів реліз &quot;залишає станцію&quot;, але все ще потрібно здійснити подорож в бета-каналі, перш ніж він прибуде як стабільна версія.</p>
<p>Релізи Rust випускаються що шість тижнів, як годинник. Якщо ви знаєте дату одного релізу Rust, то можете дізнатися дату наступного: за шість тижнів. Гарний аспект запланованих що шість тижнів релізів полягає в тому, що наступний потяг прибуде незабаром. Якщо певний функціонал пропускає якийсь певний реліз, немає потреби хвилюватися: інший відбудеться за короткий час! Це допомагає зменшити тиск, що хтось спробує протягти, можливо, недошліфований функціонал близько до строку релізу.</p>
<p>Завдяки цьому процесу, ви завжди можете перевірити наступну збірку Rust і впевнитись, що до неї легко оновитися: якщо бета реліз не працює так, як очікувалося, ви можете повідомити про це команді, і його відремонтують до наступного стабільного релізу! Аварії в бета релізі порівняно рідкісні, але <code>rustc</code> є лише програмою, і вади існують.</p>
<h3 id="Нестабільний-функціонал"><a class="header" href="#Нестабільний-функціонал">Нестабільний функціонал</a></h3>
<p>Є ще одна хитрість у цій моделі релізів: нестабільний функціонал. Rust використовує техніку, що зветься &quot;прапорці функціонала&quot;, щоб визначити, який функціонал увімкнено в даному релізі. Якщо новий функціонал перебуває в активній розробці, він опиняється в <code>master</code>, а, відтак, у щонічних релізах, але поза <em>прапорцем функціонала</em>. Якщо ви, як користувач, захочете спробувати функціонал, над яким ведеться робота, то можете це зробити, але ви маєте використовувати нічний реліз Rust і позначити свій вихідний файл відповідним прапорцем, щоб погодитися на цей функціонал.</p>
<p>Якщо ви використовуєте бета або стабільний реліз Rust, то не можете використовувати прапорці функціонала. Це ключ, що дозволяє нам отримати практичний досвід нового функціонала до того, як його оголосять стабільним назавжди. Ті, хто бажає бути на передньому краю, можуть підписатися на це, а ті, хто бажає надійного досвіду, може залишитися на стабільному релізі і знати, що їхній код не зламається. Стабільність без застою.</p>
<p>Ця книга містить інформацію лише про стабільний функціонал, оскільки в процесі функціонал все ще змінюється, і, безумовно, він буде різним у той час, коли була написана ця книжка, і коли він буде включеним до стабільних збірок. Ви можете знайти документацію про функціонал, доступний лише в щонічних релізах, онлайн.</p>
<h3 id="rustup-і-роль-щонічного-rust"><a class="header" href="#rustup-і-роль-щонічного-rust">Rustup і роль щонічного Rust</a></h3>
<p>Rustup дозволяє легко перемикатися між різними каналами релізів Rust, глобально чи для окремих проєктів. За замовчуванням буде встановлено стабільний Rust. Для встановлення, наприклад, щонічного, запустіть:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>Ви також можете побачити всі <em>ланцюжки інструментів</em> (toolchain, релізи Rust і пов’язаних компонентів), що ви встановили за допомогою <code>rustup</code>. Ось приклад на комп'ютері одного з авторів з Windows:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>Як ви можете бачити, стабільний ланцюжок інструментів є замовчуванням. Більшість користувачів Rust використовують переважно стабільний реліз. Ви можете використовувати стабільний реліз більшу частину часу, але використовувати щонічний у конкретному проєкті, якщо вам потрібен функціонал з переднього краю. Для цього, ви можете запустити <code>rustup override</code> в теці цього проєкту, щоб встановити щонічний ланцюжок інструментів для використання <code>rustup</code>, коли ви в цій теці:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Відтепер кожного разу як ви викликаєте <code>rustc</code> чи <code>cargo</code> всередині <em>~/projects/needs-nightly</em>, <code>rustup</code> переконається, що ви використовуєте щонічний Rust, а не стабільний Rust за замовчуванням. Це стає в пригоді, коли ви маєте багато проєктів Rust!</p>
<h3 id="Процес-і-команди-rfc"><a class="header" href="#Процес-і-команди-rfc">Процес і команди RFC</a></h3>
<p>То як же вам дізнатися про цей новий функціонал? Модель розробки Rust слідує процесу <em>&quot;прохання прокоментувати (RFC, Request For Comments)</em>. Якщо ви хочете покращення в Rust, то можете написати пропозицію, що зветься RFC.</p>
<p>Будь-хто може написати RFC для покращення Rust, і пропозиції розглядаються і обговорюються командою Rust, що складається з багатьох тематичних підкоманд. Повний список команд знаходиться <a href="https://www.rust-lang.org/governance">на вебсайті Rust</a> і включає команди для кожної області проєкт: дизайн мови, реалізація компілятора, Інфраструктура, документація та інші. Відповідна команда читає пропозицію і коментарі, пише деякі власні коментарі, і врешті-решт виникає консенсус - прийняти або відхилити цей функціонал.</p>
<p>Якщо функціонал буде прийнятий, то в репозиторії Rust відкривається задача, і хтось може їх виконати. Особа, що реалізує функціонал цілком може бути не тою особою, що його взагалі запропонувала! Коли реалізація готова, вона додається в гілку <code>master</code> за бар'єром функціонала, про який ми говорили в підрозділі <a href="appendix-07-nightly-rust.html#unstable-features">&quot;Нестабільний функціонал&quot;</a><!-- ignore --> .</p>
<p>За деякий час, коли розробники Rust, які використовують щонічні релізи, зможуть спробувати новий функціонал, члени команди обговорять, як функціонал працює на щонічному релізі, і вирішать, чи варто перенести його в стабільний Rust чи ні. Якщо буде ухвалено рішення просуватися, то бар'єр функціонала знімають, і функціонал тепер вважається стабільним! І він їде залізницею у новий стабільний реліз Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
