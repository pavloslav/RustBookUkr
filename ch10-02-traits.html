<!DOCTYPE HTML>
<html lang="uk" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Трейти: Визначення Спільної Поведінки - Мова програмування Rust</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Мова Програмування Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Передмова</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Вступ</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Початок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Встановлення</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Привіт, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Програмування Гри Відгадайки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Загальні Концепції Програмування</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Змінні і Мутабельність</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Типи Даних</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функції</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Коментарі</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Потік Виконання</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Розуміння Володіння</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Що Таке Володіння?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Посилання та Позичання</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Слайси</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Використання Структур для Групування Пов'язаних Даних</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Визначення та Створення Екземпляра Структури</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Приклад Програми з Використанням Структур</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис Методів</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Енуми та Зіставлення зі Шаблоном</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Визначення Енума</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкція Потоку Виконання match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконічний Потік Виконання з if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Керування Щораз Більшими Проєктами із Пакетами, Крейтами та Модулями</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакети та Крейти</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Визначення Модулів для Контролю Області Видимості та Приватності</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Шлях для Доступу до Елементів у Дереві Модулів</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введення Шляхів до Області Видимості з Ключовим Словом use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Розподіл Модулів на Різні Файли</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Звичайні Колекції</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Зберігання Списків Значень з Векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Зберігання Тексту у Кодуванні UTF-8 в Стрічках</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Зберігання Ключів з Асоційованими Значеннями у Хеш-Мапах</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обробка Помилок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Невідновлювані Помилки з panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Відновлювані Помилки з Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! чи не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Узагальнені Типи, Трейти та Часи Існування</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Узагальнені Типи Даних</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html" class="active"><strong aria-hidden="true">10.2.</strong> Трейти: Визначення Спільної Поведінки</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Перевірка Коректності Посилань із Часами Існування</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написання Автоматизованих Тестів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Як Писати Тести</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Керування Запуском Тестів</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Організація Тестів</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проєкт з Вводом/Виводом: Створення Програми з Інтерфейсом Командного Рядка</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Приймання Аргументів Командного Рядка</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Читання Файлу</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторинг для Покращення Модульності та Обробки Помилок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Розробка Функціонала Бібліотеки із Test-Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Робота зі Змінними Середовища</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Написання Повідомлень про Помилки у Помилковий Вивід замість Стандартного Виводу</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функціональні Можливості Мови: Ітератори та Замикання</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замикання: Анонімні Функції, що Захоплюють Своє Середовище</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обробка Послідовностей Елементів з Ітераторами</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Покращення Нашого Проєкту з Вводом/Виводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Порівняння Швидкодії: Цикли Проти Ітераторів</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Більше про Cargo та Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Налаштування Збірок з Release Профілями</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публікація Крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Робочі Області Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Встановлення Двійкових Файлів з cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Розширення Cargo із Користувацькими Командами</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Розумні Вказівники</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Використання Box&lt;T&gt; для Вказування на Дані в Купі</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Ставлення до Розумних Вказівників як до Звичайних Посилань з Трейтом Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Виконання Коду при Очищенні з Трейтом Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt; - Розумний Вказівник з Лічильником Посилань</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; та Шаблон Внутрішньої Мутабельності</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Цикли Посилань Можуть Спричинити Витік Пам'яті</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безстрашна Конкурентність</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Використання Потоків для Одночасного Виконання Коду</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Застосування Обміну Повідомлень для Передавання Даних між Потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Конкурентність зі Спільним Станом</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Розширювана Конкурентність із Трейтами Sync та Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Особливості Об'єктоорієнтованого Програмування в Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики Об'єктоорієнтованих Мов</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Використання Трейт-Об'єктів, які Допускають Значення Різних Типів</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реалізація Об'єктоорієнтованого Шаблону Проєктування</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблони та Зіставлення Шаблонів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Усі Місця Можливого Використання Шаблонів</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Спростовуваність: Чи Може Шаблон Бути Невідповідним</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Синтаксис Шаблонів</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Просунуті Можливості</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезпечний Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Поглиблено про Трейти</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Поглиблено про Типи</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Поглиблено про Функції та Замикання</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макроси</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Останній Проєкт: Збірка Багатопотокового Вебсервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Збірка Однопотокового Вебсервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Перетворюємо Наш Однопотоковий Сервер на Багатопотоковий</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Плавне Вимкнення та Очищення</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Додатки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Ключові Слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Оператори та Символи</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Похідні Трейти</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Корисні Інструменти Розробки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Видання</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Переклади Книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - як Розробляється Rust і "Нічний Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Мова програмування Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Трейти-Визначення-Спільної-Поведінки"><a class="header" href="#Трейти-Визначення-Спільної-Поведінки">Трейти: Визначення Спільної Поведінки</a></h2>
<p><em>Трейт</em> визначає функціональність, якою володіє визначений тип та якою він може ділитися з іншими типами. Ми можемо використовувати трейти, щоб визначати спільну поведінку абстрактним способом. Також маємо змогу застосувати <em>обмеження трейту</em>, щоб вказати, що загальний тип, може бути будь-яким типом, який реалізує певну поведінку.</p>
<blockquote>
<p>Note: Traits are similar to a feature often called <em>interfaces</em> in other languages, although with some differences.</p>
</blockquote>
<h3 id="Визначення-Трейту"><a class="header" href="#Визначення-Трейту">Визначення Трейту</a></h3>
<p>Поведінка типу визначається тими методами, які ми можемо викликати у цього типу. Різні типи розділяють однакову поведінку, якщо ми можемо викликати одні й ті самі методи цих типів. Визначення трейтів - це спосіб згрупувати сигнатури методів разом, заради того, щоб описати загальну поведінку, необхідну для досягнення певної мети.</p>
<p>For example, let’s say we have multiple structs that hold various kinds and amounts of text: a <code>NewsArticle</code> struct that holds a news story filed in a particular location and a <code>Tweet</code> that can have at most 280 characters along with metadata that indicates whether it was a new tweet, a retweet, or a reply to another tweet.</p>
<p>Ми хочемо створити бібліотечний крейт медіа агрегатору під назвою <code>aggregator</code>, який може відображати зведення даних, які збережені в екземплярах структур <code>NewsArticle</code> чи <code>Tweet</code>. Щоб це зробити, нам треба мати можливість для кожної структури зробити коротке зведення на основі даних, які маємо: для цього треба, щоб обидві структури реалізували загальну поведінку, в нашому випадку це буде виклик методу <code>summarize</code> в екземпляра об'єкту. Лістинг 10-12 ілюструє визначення публічного трейту <code>Summary</code>, який висловлює таку поведінку.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</code></pre>
<p><span class="caption">Блок коду 10-12: Визначення трейту <code>Summary</code>, що містить поведінку, надану методом <code>summarize</code></span></p>
<p>Тут ми визначаємо трейт, використовуючи ключове слово <code>trait</code>, а потім його назву, якою є <code>Summary</code> в цьому випадку. Ми також визначили цей трейт як <code>pub</code>, щоб крейти, які залежать від цього крейту, також могли використовувати цей трейт, як ми побачимо в декількох прикладах. Всередині фігурних дужок визначаються сигнатури методів, які описують поведінку типів, які реалізують цей трейт. У цьому випадку поведінка визначається тільки однією сигнатурою методу: <code>fn summarize(&amp;self) -&gt; String</code>.</p>
<p>Після сигнатури методу, замість надання реалізації у фігурних дужках, ми використовуємо крапку з комою. Кожен тип, який реалізує цей трейт, повинен надати свою власну поведінку для цього методу. Компілятор забезпечить, що будь-який тип, який містить трейт <code>Summary</code>, буде також мати й метод <code>summarize</code> визначений з точно такою сигнатурою.</p>
<p>Трейт може мати декілька методів у описі його тіла: сигнатури методів перераховуються по одній на кожному рядку та повинні закінчуватися крапкою з комою.</p>
<h3 id="Реалізація-Трейту-для-Типів"><a class="header" href="#Реалізація-Трейту-для-Типів">Реалізація Трейту для Типів</a></h3>
<p>Тепер, після того, як ми визначили бажану поведінку, використовуючи трейт <code>Summary</code>, можна реалізувати його для типів у нашому медіа агрегатору. Лістинг 10-13 показує реалізацію трейту <code>Summary</code> для структури <code>NewsArticle</code>, яка використовує для створення зведення в методі <code>summarize</code> заголовок, автора та місце публікації. Для структури <code>Tweet</code> ми визначаємо реалізацію <code>summarize</code>, використовуючи користувача та повний текст твіту, вважаючи зміст вже обмеженим 280 символами.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
</code></pre>
<p><span class="caption">Блок коду 10-13: Реалізація трейту <code>Summary</code> для структур <code>NewsArticle</code> та <code>Tweet</code></span></p>
<p>Реалізація трейту для типу аналогічна реалізації звичайних методів. Різниця в тому, що після <code>impl</code> ми пишемо ім'я трейту, який ми хочемо реалізувати, після чого використовуємо ключове слово <code>for</code>, а потім вказуємо ім'я типу, для якого ми хочемо зробити реалізацію трейту. Всередині блоку <code>impl</code> ми розташовуємо сигнатуру методу, яка визначена в трейту. Замість додавання крапки з комою в кінці, після кожної сигнатури використовуються фігурні дужки, та тіло методу заповнюється конкретною поведінкою, яку ми хочемо отримати у методів трейту для конкретного типу.</p>
<p>Тепер, коли в бібліотеці реалізований трейт <code>Summary</code> для <code>NewsArticle</code> та <code>Tweet</code>, користувачі крейту можуть викликати методи трейту для екземплярів <code>NewsArticle</code> й <code>Tweet</code>, так само як ми викликаємо звичайні методи. Єдина різниця в тому, що користувач повинен ввести в область видимості трейти, а також типи. Ось приклад як бінарний крейт може використовувати наш <code>aggregator</code>:</p>
<pre><code class="language-rust ignore">use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
}
</code></pre>
<p>Цей код надрукує: <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Інші крейти, які залежать від крейту <code>aggregator</code>, також можуть взяти <code>Summary</code> в область видимості, щоб реалізувати <code>Summary</code> для своїх власних типів. Слід зазначити одне обмеження: ми можемо реалізувати трейт для типу тільки в тому випадку, якщо хоча б один трейт чи тип є локальними для нашого крейту. Наприклад, ми можемо реалізувати стандартні бібліотечні трейти, такі як <code>Display</code> на користувальницькому типі <code>Tweet</code>, як частина функціональності нашого крейту <code>aggregator</code>, тому що тип <code>Tweet</code> є локальним для нашого крейту <code>aggregator</code>. Також ми можемо реалізувати <code>Summary</code> для <code>Vec&lt;T&gt;</code> в нашому крейті <code>aggregator</code>, оскільки трейт <code>Summary</code> є локальним для нашого крейту <code>aggregator</code>.</p>
<p>Але ми не можемо реалізувати зовнішні трейти на зовнішніх типах. Наприклад, ми не можемо реалізувати трейт <code>Display</code> для <code>Vec&lt;T&gt;</code> в нашому крейті <code>aggregator</code>, тому що <code>Display</code> та <code>Vec&lt;T&gt;</code> визначені у стандартній бібліотеці та не є локальними для нашого крейту <code>aggregator</code>. Це обмеження є частиною властивості, яка називається <em>узгодженість</em> (coherence), та, більш конкретно <em>правило сироти</em> (orphan rule), яке назвали так, тому що батьківський тип відсутній. Це правило гарантує, що чужий код не може порушити ваш код, та навпаки. Без цього правила два крейти мали б змогу реалізовувати один й той самий трейт для одного й того самого типу, і Rust не знав би, яку реалізацію використовувати.</p>
<h3 id="Реалізація-Поведінки-за-Замовчуванням"><a class="header" href="#Реалізація-Поведінки-за-Замовчуванням">Реалізація Поведінки за Замовчуванням</a></h3>
<p>Іноді корисно мати поведінку за замовчуванням для деяких чи всіх методів трейту замість того, щоб вимагати реалізації всіх методів у кожному типі, що реалізує цей трейт. Потім, коли ми реалізуємо трейт для певного типу, можна зберегти чи перевизначити поведінку кожного методу за замовчуванням вже всередині типів.</p>
<p>В Блоці коду 10-14 показано, як вказати стрічку за замовчуванням для методу <code>summarize</code> з трейту <code>Summary</code> замість визначення тільки сигнатури методу, як ми робили в Блоці коду 10-12.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 10-14: Визначення трейту <code>Summary</code> з реалізацією методу <code>summarize</code> за замовчуванням</span></p>
<p>Для використання реалізації за замовчуванням під час створення зведення в екземплярах <code>NewsArticle</code>, ми вказуємо порожній блок <code>impl</code> з <code>impl Summary for NewsArticle {}</code>.</p>
<p>Хоча ми більше не визначаємо метод <code>summarize</code> безпосередньо в <code>NewsArticle</code>, ми надали реалізацію за замовчуванням та вказали, що <code>NewsArticle</code> реалізує трейт <code>Summary</code>. В результаті ми все ще маємо змогу викликати метод <code>summarize</code> в екземпляра <code>NewsArticle</code>, наприклад таким чином:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        author: String::from(&quot;Iceburgh&quot;),
        content: String::from(
            &quot;The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.&quot;,
        ),
    };

    println!(&quot;New article available! {}&quot;, article.summarize());
<span class="boring">}
</span></code></pre>
<p>Цей код виведе в консолі <code>New article available! (Read more...)</code>.</p>
<p>Створення реалізації за замовчуванням не вимагає від нас змін чого-небудь у реалізації <code>Summary</code> для типу <code>Tweet</code> у Блоці коду 10-13. Причина полягає в тому, що синтаксис для перевизначення реалізації за замовчуванням є таким, як синтаксис для реалізації метода трейту, котрий не має реалізації за замовчуванням.</p>
<p>Реалізації за замовчуванням можуть викликати інші методи в тому ж трейті, навіть якщо ці методи не мають реалізації за замовчуванням. Таким чином, трейт може надати багато корисної функціональності, тільки вимагаючи від розробників вказувати невелику його частину. Наприклад, ми мали змогу б визначити трейт <code>Summary</code>, який має метод <code>summarize_author</code>, реалізація якого вимагається, а потім визначити метод <code>summarize</code>, який має реалізацію за замовчуванням, котра всередині викликає метод <code>summarize_author</code>:</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.username)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Щоб використовувати таку версію трейту <code>Summary</code>, потрібно тільки визначити метод <code>summarize_author</code>, під час реалізації трейту для типу:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p>Після того, як ми визначимо <code>summarize_author</code>, можемо викликати <code>summarize</code> для екземплярів структури <code>Tweet</code> і реалізація за замовчуванням методу <code>summarize</code> буде викликати визначення <code>summarize_author</code>, яке ми вже надали. Оскільки ми реалізували метод <code>summarize_author</code> трейту <code>Summary</code>, то трейт дає нам поведінку метода <code>summarize</code> без необхідності писати код.</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<p>Цей код друкує: <code>1 new tweet: (Read more from @horse_ebooks...)</code>.</p>
<p>Зверніть увагу, що неможливо викликати реалізацію за замовчуванням з перевизначеної реалізації того ж самого методу.</p>
<h3 id="Трейти-як-Параметри"><a class="header" href="#Трейти-як-Параметри">Трейти як Параметри</a></h3>
<p>Тепер, коли ви знаєте, як визначати та реалізовувати трейти, можна вивчити, як використовувати трейти, щоб визначити функції, які приймають багато різних типів. Ми будемо використовувати трейт <code>Summary</code>, який ми реалізували для типів <code>NewsArticle</code> та <code>Tweet</code> у Блоці коду 10-13, щоб визначити функцію <code>notify</code>, яка викликає метод <code>summarize</code> для свого параметра <code>item</code>, який є деяким типом, який реалізує трейт <code>Summary</code>. Для цього ми використовуємо синтаксис <code>impl Trait</code>, наприклад таким чином:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>Замість конкретного типу в параметрі <code>item</code> вказується ключове слово <code>impl</code> та ім'я трейту. Цей параметр приймає будь-який тип, який реалізує вказаний трейт. У тілі <code>notify</code> ми маємо змогу викликати будь-які методи в екземпляра <code>item</code>, які повинні бути визначені при реалізації трейту <code>Summary</code>, наприклад можна викликати метод <code>summarize</code>. Ми можемо викликати <code>notify</code> та передати в нього будь-який екземпляр <code>NewsArticle</code> чи <code>Tweet</code>. Код, який викликає цю функцію з будь-яким іншим типом, таким як <code>String</code> чи <code>i32</code>, не буде компілюватися, тому що ці типи не реалізують трейт <code>Summary</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="Синтаксис-Обмеження-Трейту"><a class="header" href="#Синтаксис-Обмеження-Трейту">Синтаксис Обмеження Трейту</a></h4>
<p>Синтаксис <code>impl Trait</code> працює для простих випадків, але насправді є синтаксичним цукром для більш довгої форми, яка називається <em>обмеження трейту</em>, це виглядає ось так:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>Ця більш довга форма еквівалентна прикладу в минулому розділі, але вона більш багатослівна. Ми розміщуємо оголошення параметра узагальненого типа з обмеженням трейту після двокрапки всередині кутових дужок.</p>
<p>Синтаксис <code>impl Trait</code> зручний та робить більш виразним код у простих випадках, в той час, як більш повний синтаксис обмеження трейту може висловити більшу складність в інших випадках. Наприклад, у нас може бути два параметри, які реалізують трейт <code>Summary</code>. Використання синтаксису <code>impl Trait</code> виглядає наступним чином:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
</code></pre>
<p>Використання <code>impl Trait</code> доцільно, якщо ми хочемо, щоб ця функція дозволяла <code>item1</code> та <code>item2</code> мати різні типи (за умовою, що обидва типи реалізують <code>Summary</code>). Якщо ми хочемо змусити обидва параметри мати один й той самий тип, ми повинні використовувати обмеження трейту, наприклад, ось так:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
</code></pre>
<p>Узагальнений тип <code>T</code> зазначений як тип параметрів <code>item1</code> та <code>item2</code> обмежує функцію таким чином, що конкретний тип значення переданого як аргумент для <code>item1</code> і <code>item2</code> має бути однаковим.</p>
<h4 id="Визначення-Кількох-Обмежень-Трейтів-із-Синтаксисом-"><a class="header" href="#Визначення-Кількох-Обмежень-Трейтів-із-Синтаксисом-">Визначення Кількох Обмежень Трейтів із Синтаксисом <code>+</code></a></h4>
<p>Також можна вказати більше одного обмеження трейту. Скажімо, ми хочемо, щоб <code>notify</code> використовував форматування відображення, а також <code>summarize</code> для <code>item</code>: ми вказуємо у визначенні <code>notify</code>, що <code>item</code> повинен реалізувати <code>Display</code> та <code>Summary</code> одночасно. Це можна зробити за допомогою синтаксису <code>+</code>:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {
</code></pre>
<p>Синтаксис <code>+</code> також валідний з обмеженням трейту для узагальнених типів:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
</code></pre>
<p>За наявності двох обмежень трейту, тіло методу <code>notify</code> може викликати <code>summarize</code> та використовувати <code>{}</code> для форматування <code>item</code> під час його друку.</p>
<h4 id="Чіткіші-Межі-Трейту-з-where"><a class="header" href="#Чіткіші-Межі-Трейту-з-where">Чіткіші Межі Трейту з <code>where</code></a></h4>
<p>Використання занадто великої кількості обмежень трейту має свої недоліки. Кожен узагальнений тип має свої межі трейту, тому функції з декількома параметрами узагальненого типу можуть містити багато інформації про обмеження між назвою функції та списком її параметрів, що ускладнює читання сигнатури. З цієї причини в Rust є альтернативний синтаксис для визначення обмежень трейту всередині блок <code>where</code> після сигнатури функції. Тому замість того, щоб писати ось так:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<p>Можна використати блок <code>where</code>, наприклад таким чином:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}
</span></code></pre>
<p>Сигнатура цієї функції менш захаращена: назва функції, список параметрів, та тип значення, що повертається, знаходяться поруч, а сигнатура не містить в собі множину обмежень трейту.</p>
<h3 id="Повернення-Значень-Типу-що-Реалізує-Певний-Трейт"><a class="header" href="#Повернення-Значень-Типу-що-Реалізує-Певний-Трейт">Повернення Значень Типу, що Реалізує Певний Трейт</a></h3>
<p>We can also use the <code>impl Trait</code> syntax in the return position to return a value of some type that implements a trait, as shown here:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    }
}
</code></pre>
<p>Використовуючи <code>impl Summary</code> для типу, що повертається, ми вказуємо, що функція <code>returns_summarizable</code> повертає деяких тип, який реалізує трейт <code>Summary</code> без позначення конкретного типу. В цьому випадку <code>returns_summarizable</code> повертає <code>Tweet</code>, але код, який викликає цю функцію, цього не знає.</p>
<p>Можливість повертати тип, який визначається тільки ознакою, яку він реалізує, є особливо корисна в контексті замикань та ітераторів, які ми розглянемо у розділі 13. Замикання та ітератори створюють типи, які відомі тільки компілятору, або типи, які дуже довго визначати. Синтаксис <code>impl Trait</code> дозволяє вам лаконічно вказати, що функція повертає деяких тип, що реалізує ознаку <code>Iterator</code>, без необхідності вказувати дуже довгий тип.</p>
<p>Проте, <code>impl Trait</code> можливо використовувати, якщо ви повертаєте тільки один тип. Наприклад, цей код, який повертає значення типу <code>NewsArticle</code> або <code>Tweet</code>, але як тип, що повертається, оголошує <code>impl Summary</code>, не буде працювати:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Penguins win the Stanley Cup Championship!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;of course, as you probably already know, people&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
</code></pre>
<p>Повертання або <code>NewsArticle</code> або <code>Tweet</code> не дозволяється через обмеження того, як реалізований синтаксис <code>impl Trait</code> в компіляторі. Ми подивимося, як написати функцію з такою поведінкою у секції <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Використання об'єктів трейтів, які дозволяють використовувати значення різних типів”</a><!--
ignore --> розділу 17.</p>
<h3 id="Використання-Обмежень-Трейту-для-Умовної-Реалізації-Методів"><a class="header" href="#Використання-Обмежень-Трейту-для-Умовної-Реалізації-Методів">Використання Обмежень Трейту для Умовної Реалізації Методів</a></h3>
<p>Використовуючи обмеження трейту з блоком <code>impl</code>, який використовує параметри узагальненого типу, можна реалізувати методи умовно, для тих типів, які реалізують вказаний трейт. Наприклад, тип <code>Pair&lt;T&gt;</code> у Блоці коду 10-15 завжди реалізує функцію <code>new</code> для повертання нового екземпляру <code>Pair&lt;T&gt;</code> (нагадаємо з секції <a href="ch05-03-method-syntax.html#defining-methods">“Визначення методів”</a><!-- ignore --> розділу 5, що <code>Self</code> це псевдонім типу для типа блоку <code>impl</code>, який в цьому випадку є <code>Pair&lt;T&gt;</code>). Але в наступному блоці <code>impl</code>, <code>Pair&lt;T&gt;</code> реалізує тільки метод <code>cmp_display</code>, якщо його внутрішній тип <code>T</code> реалізує трейт <code>PartialOrd</code>, який дозволяє порівнювати <em>і</em> трейт <code>Display</code>, який забезпечує друкування.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
</code></pre>
<p><span class="caption">Лістинг 10-15: Умовна реалізація методів в узагальнених типів в залежності від обмежень трейту</span></p>
<p>Ми також можемо умовно реалізувати трейт для будь-якого типу, який реалізує інший трейт. Реалізація трейту для будь-якого типу, що задовольняє обмеженням трейту називається <em>загальною реалізацією</em> (blanket implementations) й широко використовується в стандартній бібліотеці Rust. Наприклад, стандартна бібліотека реалізує трейт <code>ToString</code> для будь-якого типу, який реалізує трейт <code>Display</code>. Блок <code>impl</code> в стандартній бібліотеці виглядає приблизно так:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>Оскільки стандартна бібліотека має загальну реалізацію, то можна викликати метод <code>to_string</code> визначений трейтом <code>ToString</code> для будь-якого типу, який реалізує трейт <code>Display</code>. Наприклад, ми можемо перетворити цілі числа в їх відповідні <code>String</code> значення, тому що цілі числа реалізують трейт <code>Display</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>Загальні реалізації наведені в документації до трейту в розділі “Implementors”.</p>
<p>Трейти та обмеження трейтів дозволяють писати код, який використовує параметри узагальненого типу для зменшення дублювання коду, а також вказання компілятору, що ми хочемо узагальнений тип, щоб мати визначену поведінку. Потім компілятор може використовувати інформацію про обмеження трейту, щоб перевірити, що всі конкретні типи, які використовуються з нашим кодом, забезпечують правильну поведінку. У динамічно типізованих мовах програмування ми отримали б помилку під час виконання, якби викликали метод для типу, який не реалізує тип визначений методом. Але Rust перекладає ці помилки на час компіляції, тому ми повинні виправити проблеми, перш ніж наш код почне працювати. Крім того, ми не повинні писати код, який перевіряє свою поведінку під час компіляції, тому що це вже перевірено під час компіляції. Це підвищує швидкодію без необхідності відмовлятися від гнучкості узагальнених типів.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
