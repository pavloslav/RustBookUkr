<!DOCTYPE HTML>
<html lang="uk" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Помилки, що піддаються відновленню за допомогою Result - Мова програмування Rust</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Мова програмування Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Передмова</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Вступ</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Початок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Встановлення</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Привіт, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Програмування гри - відгадайки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Загальні концепції програмування</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Змінні та мутабельність</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Типи даних</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функції</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Коментарі</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управління потоком виконання</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Розуміння володіння</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Що таке володіння?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Посилання і позичання</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Тип даних слайс</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Використання структур для структурування пов'язаних даних</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Визначення і інстанціювання структур Struct</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Приклад програми, що використовує структури</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис методів</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Енуми і зіставлення з шаблоном</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Визначення енума</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкція управління match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконічний контроль виконання конструкцією if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Керування проєктами, що зростають, за допомогою пакетів, крейтів та модулів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакети та крейти</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Визначення модулів для управління областями видимості та приватністю</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Шлях для доступу до елементів у дереві модулів</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Підключення шляхів до області видимості за допомогою ключового слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Розподіл модулів на різні файли</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Звичайні колекції</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Зберігання списків значень у векторах</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Зберігання тексту у кодуванні UTF-8 у стрічках</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Зберігання ключів і пов'язаних значень у хешмапах</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обробка помилок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Невідновні Помилки із panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html" class="active"><strong aria-hidden="true">9.2.</strong> Помилки, що піддаються відновленню за допомогою Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! чи не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Узагальнені типи, трейти та лайфтайми</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Узагальнені типи даних</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейти: визначення загальної поведінки</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Перевірка коректності посилань за допомогою часів існування</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написання автоматизованих тестів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Як писати тести</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Контроль над запуском тестів</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Організація тестів</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проєкт з введенням/виведенням: створення програми командного рядка</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Приймання аргументів командного рядка</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Читання файлу</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторизація для покращення модульності та обробки помилок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Розробка Функціонала Бібліотеки із Test-Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Робота зі Змінними Середовища</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Написання Повідомлень Про Помилки в Standard Error Замість Стандартного Виводу</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функціональні можливості мови: Ітератори та Замикання</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замикання: Анонімні Функції що Захоплюють Своє Середовище</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обробка послідовностей елементів за допомогою ітераторів</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Покращуємо наш проєкт з введенням/виведенням</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Порівняння швидкодії: цикли проти ітераторів</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Більше про Cargo та Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Налаштування Збірок з Release Профілями</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публікація Крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Робочі Області Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Встановлення Двійкових Файлів з cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Розширення Cargo із Користувацькими Командами</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Розумні вказівники</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Використання Box&lt;T&gt; для вказування на значення в Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Використання розумних вказівників як звичайних посилань за допомогою трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Виконання коду при очищенні за допомогою трейту Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, розумний вказівник з лічильником посилань</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; і шаблон внутрішньої мутабельності</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Цикли посилань можуть призвести до витоку пам'яті</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Конкурентність без страху</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Використання потоків для одночасного запуску коду</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Використання обміну повідомленнями для передачі даних між потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Паралелізм із спільним станом</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Розширювана конкурентність із трейтами Sync і Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Об'єктно орієнтовані особливості Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики об'єктно орієнтованого програмування</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Використання трейтових об'єктів, які допускають значення різних типів</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реалізація патернів об'єктноорієнтованого програмування</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблони та Зіставлення Шаблонів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Усі Місця Можливого Використання Шаблонів</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Спростовуваність: Чи Може Шаблон Бути Невідповідним</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Синтаксис Шаблонів</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Просунутий функціонал</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезпечний Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Поглиблено про трейти</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Поглиблено про типи</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Поглиблено про функції та замикання</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макроси</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Останній проєкт: збірка багатопотокового вебсервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Збірка однопотокового вебсервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Перетворюємо наш однопотоковий сервер на багатопотоковий</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Плавне вимикання і очищення</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Додатки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - ключові слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - оператори та символи</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> С - вивідні трейти</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - корисні інструменти розробки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - видання</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - переклади цієї книжки</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - як робиться Rust і "щонічний Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Мова програмування Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Помилки-що-піддаються-відновленню-за-допомогою-result"><a class="header" href="#Помилки-що-піддаються-відновленню-за-допомогою-result">Помилки, що піддаються відновленню за допомогою <code>Result</code></a></h2>
<p>Більшість помилок не є достатньо серйозними, щоб вимагати повної зупинки виконання програми. Іноді, якщо функція не спрацьовує, то це можна досить просто пояснити й відреагувати певним чином. Наприклад, якщо ви намагаєтесь відкрити файл і ця операція зазнає невдачі, тому що такого файлу немає, то замість завершення процесу ви б захотіли створити такий файл.</p>
<p>Нагадаємо з підрозділу <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result">Керування потенційною невдачею за допомогою типу <code>Result</code></a><!--
ignore --> в Розділі 2, що </p>
<p><code>Result</code> визначається як енум, що має два можливих значення <code>Ok</code> та <code>Err</code>, наступним чином:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>T</code> and <code>E</code> це параметри, що відносять до узагальнених типів, які ми розглянемо більш детально у розділі 10. Все, що вам необхідно знати на даний момент, що <code>T</code> представляє тип значення, яке буде повернуто результатом успішного виконання як вміст варіанту <code>Ok</code>, а <code>E</code> представляє тип помилки, що буде повернуто як вміст варіанту <code>Err</code> у випадку невдачі. Оскільки <code>Result</code> містить ці узагальнені типи параметрів, ми можемо використовувати тип <code>Result</code> і функції, що визначені для нього у стандартній бібліотеці, для різних випадків, коли значення успішного виконання і значення невдачі, які ми хочемо повернути, можуть відрізнятися.</p>
<p>Спробуймо викликати функцію, яка повертає значення типу <code>Result</code>, оскільки ця функція може не спрацювати. В блоці коду 9-3 ми спробуємо відкрити файл.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Блок коду 9-3: Відкривання файлу</span></p>
<p>Типом, який повертає <code>File::open</code> є <code>Result&lt;T, E&gt;</code>. Узагальнений параметр <code>T</code> був визначений в реалізації <code>File::open</code>, як тип значення при успіху при обробці файлу, а саме <code>std::fs::File</code>. Тип <code>E</code>, що використовується, як значення помилки, визначений як <code>std::io::Error</code>. Цей тип значення, що повертається, означає, що виклик <code>File::open</code> може бути успішним і повернути обробник файлу, за допомогою якого ми можемо його зчитувати, або записувати. Також виклик функції може завершитися не успішно, наприклад файлу може ще не існувати, або у нас не буде дозволів на обробку цього файлу. Функція <code>File::open</code> має мати можливість сповістити нас, чи виклик був успішним чи ні, і дати нам або обробник файлу, або інформацію про помилку. Ця інформація і є безпосередньо тим, що являє собою енум <code>Result</code>.</p>
<p>У випадку, коли виклик <code>File::open</code> був успішним, значенням змінної <code>greeting_file_result</code> буде екземпляр <code>Ok</code>, що містить обробник файлу. А у випадку помилки, значенням <code>greeting_file_result</code> буде екземпляр <code>Err</code>, який містить інформацію про тим помилкової ситуації, що сталася.</p>
<p>Ми повинні розширити блок коду 9-3, щоб зрозуміти різні підходи в залежності від значення, яке повертає <code>File::open</code>. Блок коду 9-4 демонструє один із способів обробки <code>Result</code>, використовуючи базові підхід, такий як вираз співставлення зі зразком (<code>match</code>), що розглядався у розділі 6.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;Problem opening the file: {:?}&quot;, error),
    };
}
</code></pre></pre>
<p><span class="caption">Блок коду 9-4: Використання <code>match</code> виразу для обробки варіантів <code>Result</code></span></p>
<p>Звернуть увагу, що аналогічно до енума <code>Option</code>, енум <code>Result</code> і його варіанти вже введені в область видимості прелюдії, тому немає необхідності вказувати <code>Result::</code> перед варіантами <code>Ok</code> і <code>Err</code> в рукавах виразу співставлення зі зразком <code>match</code>.</p>
<p>Коли результат буде рівний <code>Ok</code>, нам необхідно повернути внутрішнє значення <code>file</code> з варіанту <code>Ok</code>, таким чином при присвоїмо значення обробника файлу змінній <code>greeting_file</code>. Після виразу <code>match</code> ми можемо використовувати обробник файлу для запису чи зчитування.</p>
<p>Другий рукав виразу <code>match</code> обробляє випадок, коли отримуємо значення <code>Err</code> результатом виконання <code>File::open</code>. В нашому прикладі ми вирішили викликати макрос <code>panic!</code>. Якщо в поточному каталозі немає файлу з іменем <em>hello.txt</em> і ми запустимо наш код, то завдяки макрокоманді <code>panic!</code> побачимо наступний вивід:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Як завжди, цей вивід розкаже нам, що саме пішло не так.</p>
<h3 id="Застосування-виразу-match-для-різних-помилок"><a class="header" href="#Застосування-виразу-match-для-різних-помилок">Застосування виразу match для різних помилок</a></h3>
<p>Код у блоці 9-4 буде завершиться панікою, незалежно від того, чому виклик <code>File::open</code> не спрацював. Однак, ми б хотіли виконати різні дії для різних причин неуспішного виконання: якщо <code>File::open</code> не відпрацьовує, оскільки файл не існує, ми б хотіли створити такий файл і повернути обробник для цього нового файлу. Якщо ж <code>File::open</code> не спрацював через будь-які інші причини, наприклад, у нас немає дозволів для відкриття файлу, ми б все ж таки хотіли викликати <code>panic!</code> таким самим чином, як це було в блоці коду 9-4. Для цього ми додамо вкладений вираз <code>match</code>, як показано у блоці коду 9-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem creating the file: {:?}&quot;, e),
            },
            other_error =&gt; {
                panic!(&quot;Problem opening the file: {:?}&quot;, other_error);
            }
        },
    };
}
</code></pre>
<p><span class="caption">Блок коду 9-5: Обробка різних типів помилок різним способом</span></p>
<p>Тип значення, який повертає <code>File::open</code> всередині варіантів <code>Err</code> є <code>io::Error</code>, який в свою чергу є структурою, що поставляється стандартною бібліотекою. Ця структура має метод <code>kind</code>, при виклику якого отримаємо <code>io::ErrorKind</code> значення. Енум <code>io::ErrorKind</code> поставляється у стандартній бібліотеці і має варіанти, які представляють різні типи помилок, що можуть бути результатом операції <code>io</code>. Варіант, який ми хочемо використати, це <code>ErrorKind::NotFound</code>. Цей варіант сигналізує нам, що файлу, який ми намагаємось відкрити, не існує. Тому ми застосовуємо вираз match у <code>greeting_file_result</code>, а також ми маємо вкладений вираз match для <code>error.kind()</code>.</p>
<p>У внутрішньому виразі match ми хочемо перевірити, чи значення, що повертає метод <code>error.kind()</code> є варіантом <code>NotFound</code> енума <code>ErrorKind</code>. Якщо ж так і є, ми пробуємо створити такий файл за допомогою методу <code>File::create</code>. Однак, оскільки метод <code>File::create</code> може також завершитися не успішно, нам треба ще один рукав всередині вкладеного виразу <code>match</code>. Якщо файл не може бути створено, то виводимо інше повідомлення про помилку. Другий рукав зовнішнього виразу <code>match</code> залишається незмінним, тому програма підіймає паніку на будь-які інші помилки за виключенням помилки відсутнього файлу.</p>
<blockquote>
<h3 id="Альтернативи-використанню-виразу-match-для-значень-типу-resultt-e"><a class="header" href="#Альтернативи-використанню-виразу-match-для-значень-типу-resultt-e">Альтернативи використанню виразу <code>match</code> для значень типу <code>Result&lt;T, E&gt;</code></a></h3>
<p>Схоже, що у нас забагато <code>match</code>! Вираз <code>match</code> дуже корисний, проте дуже примітивний. У розділі 13 ми будемо вивчати замикання, які використовуються  у комбінації з багатьма методами, які визначені для типу <code>Result&lt;T, E&gt;</code>. Ці методи можуть бути більш виразними за використання виразу <code>match</code>, коли працюємо зі значеннями <code>Result&lt;T, E&gt;</code> у своєму коді.</p>
<p>Прикладом може бути інший спосіб описати таку ж саму логіку, що показана у блоці коду 9-5, але з використанням замикань і методу <code>unwrap_or_else</code>:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem creating the file: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;Problem opening the file: {:?}&quot;, error);
        }
    });
}
</code></pre>
<p>Хоча цей код має таку ж поведінку, що і код у блоці 9-5, він не містить жодного  виразу <code>match</code> і зрозуміліший для читання. Повертайтесь до цього прикладу після того, як прочитаєте розділ 13 і познайомтесь з методом <code>unwrap_or_else</code> у документації до стандартної бібліотеки. Також багато інших методів можуть допомогти справитися з великою кількістю вкладений між собою виразів <code>match</code>, при роботі з помилками.</p>
</blockquote>
<h3 id="Короткі-форми-для-паніки-на-помилках-unwrap-і-expect"><a class="header" href="#Короткі-форми-для-паніки-на-помилках-unwrap-і-expect">Короткі форми для паніки на помилках: <code>unwrap</code> і <code>expect</code></a></h3>
<p>Використання виразу <code>match</code> працює достатньо добре, але може бути занадто багатослівним і не завжди добре передавати наші наміри. Тип <code>Result&lt;T, E&gt;</code> має багато допоміжних методів, які визначені для того, щоб здійснити більш специфічні обробки. Метод <code>unwrap</code> є скороченням імплементації виразу <code>match</code>, як це було зроблено у блоці коду 9-4. Якщо значення <code>Result</code> є варіантом <code>Ok</code>, метод <code>unwrap</code> поверне значення, як міститься всередині <code>Ok</code>. Якщо ж <code>Result</code> є варіантом <code>Err</code>, то метод <code>unwrap</code> викличе макрос <code>panic!</code> для нас. Ось приклад методу <code>unwrap</code> у дії:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>Якщо ми виконаємо код без існуючого файлу <em>hello.txt</em>, ми отримаємо повідомлення про помилку із виклику <code>panic!</code>, який здійснить метод <code>unwrap</code>:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {
code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }',
src/main.rs:4:49
</code></pre>
<p>Аналогічний метод <code>expect</code> дозволяє додатково нам вибрати повідомлення про помилку для макрокоманди <code>panic!</code>. Використання методу <code>expect</code> замість <code>unwrap</code> разом із заданням хороших повідомлень про помилку допоможе краще передати ваші наміри й спростить відстежування причин такої паніки. Синтаксис методу <code>expect</code> виглядає наступним чином:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)
        .expect(&quot;hello.txt should be included in this project&quot;);
}
</code></pre></pre>
<p>Ми використовуємо <code>expect</code> в такий самий спосіб, як і <code>unwrap</code>, щоб повернути обробник файлу або викликати макрос <code>panic!</code>. Повідомленням про помилку, що використовує метод <code>expect</code> у виклику макросу <code>panic!</code>, буде параметром, який ми передаємо у <code>expect</code>, замість стандартного повідомлення макросу <code>panic!</code>, яку використовує <code>unwrap</code>. Ось як це виглядає:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'hello.txt should be included in this project: Os {
code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }',
src/main.rs:5:10
</code></pre>
<p>Частіше програмісти на Rust віддають перевагу у своєму коді методу <code>expect</code> аніж <code>unwrap</code>, додаючи більше контексту з роз'ясненням, чому дана операція має бути завжди успішною для виконання. Таким чином, навіть якщо ваші припущення були не до кінця точними у такій ситуації, у вас буде більше інформації під час відлагодження.</p>
<h3 id="Поширення-помилок"><a class="header" href="#Поширення-помилок">Поширення помилок</a></h3>
<p>Коли ви пишите функцію, імплементація якої може викликати щось, що може не спрацювати, тоді замість обробки помилки всередині функції, ви можете повернути помилку тій частині коду, що її викликала. І тоді вже ця частина коду буде вирішувати, що робити з цією помилкою. Це називається <em>розповсюдженням</em> помилки й дає більше контролю викликаючому коду, де, можливо, є більше інформації або логіки, які диктують, як ця помилка має бути оброблено, ніж те що є доступним в контексті вашого коду функції.</p>
<p>Для прикладу блок коду 9-6 показує функцію, яка зчитає username з файлу. Якщо ж файл не існує або його неможливо прочитати, то цю функція поверне ці помилки в код, який викликає дану функцію.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open(&quot;hello.txt&quot;);

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 9-6: Функція, яка повертає помилки в код, який її викликає за допомогою виразу <code>match</code></span></p>
<p>Вказану функцію також можливо написати коротшим способом, але ми почнемо з того, що зробимо більшу частину самостійно, для того, щоб познайомитися з обробкою помилок. В кінці ми продемонструємо коротший спосіб. Давайте спочатку розглянемо тип значення, яке повертає функція: <code>Result&lt;String, io::Error&gt;</code>. Це означає, що функція повертає значення типу <code>Result&lt;T, E&gt;</code>, де узагальнений параметр <code>T</code> був підставлений конкретним типом <code>String</code>, а узагальнений тип <code>E</code> конкретним типом <code>io::Error</code>.</p>
<p>Якщо виклик функції відпрацює успішно без жодних проблем, то код, який викликає її, отримає значення типу <code>Ok</code>, яке містить <code>String</code> - тобто username, який був зчитаним функцією з файлу. Якщо ж виконання функції зіткнеться з якимось проблемами, код,який викликав її отримає значення <code>Err</code>, яке містить екземпляр <code>io::Error</code>, який, в свою чергу, містить більше інформації стосовно характеру проблем. Ми вибрали <code>io::Error</code> як тип значення, що повертається з неї, тому що вона є типом помилок обох функцій, що можуть виконатись не успішно, які ми викликаємо в тілі нашої функції: функція <code>File::open</code> і <code>read_to_string</code>.</p>
<p>Тіло функції починається з виклику методу <code>File::open</code>. Далі ми обробляємо значення <code>Result</code> за допомогою виразу <code>match</code>, схоже до того, що було у блоці коду 9-4. Якщо виклик <code>File::open</code> буде успішним, тоді обробник файлу буде міститися у змінній <code>file</code> виразу співставлення, який стане значення мутабельної змінної <code>username_file</code> і виконання функції буде продовжуватися. А у випадку значення <code>Err</code>, замість виклику <code>panic!</code>, ми використовуємо ключове слово <code>return</code> для передчасного виходу з функції з поверненням значення помилки в місце виклику нашої функції, яку отримаємо з виклику <code>File::open</code> як внутрішню змінну зіставлення <code>e</code>.</p>
<p>Якщо ми маємо обробник файлу у змінній <code>username_file</code>, тоді функція створить нове значення <code>String</code> у змінній <code>username</code> і викличе метод <code>read_to_string</code> на обробнику файлу <code>username_file</code>, щоб прочитати контент цього файлу у значення змінної <code>username</code>. Метод <code>read_to_string</code> також повертає <code>Result</code>, оскільки може виконатись не успішно, навіть виконання <code>File::open</code> було успішним до цього. Тому нам потрібно ще один вираз <code>match</code> для обробки цього <code>Result</code>: якщо <code>read_to_string</code> був успішним, то і виконання нашої функції теж успішне і повертаємо значення username з файлу, огорнутим у <code>Ok</code>. Якщо є <code>read_to_string</code> виконалось не успішно, ми просто повертаємо помилку у той самий спосіб, як і у виразі <code>match</code>, що обробляв значення виклику <code>File::open</code>. Однак нам непотрібно явно використовувати <code>return</code>, оскільки це останній вираз нашої функції.</p>
<p>Код, який викликає цей має обробити отримані або значення <code>Ok</code>, що містить username або значення <code>Err</code>, яке містить <code>io::Error</code>. Ми не повинні знати, що саме код який викликає буде робити з отриманими значеннями. Якщо він отримає значення <code>Err</code>, то може або викликати <code>panic!</code> і зупинити виконання програми, або скористатися іменем користувача по замовчуванню, або знайти його де інде. Ми не маємо достатньої інформації стосовно того, що саме код, який викликає буде робити, тому ми поширюємо всю інформацію, як і успішного виконання, так і не успішного вгору, для обробки її належним чином.</p>
<p>Цей патерн поширення помилок є дуже поширеним в Rust, тому Rust має спеціальний оператор знаку питання <code>?</code>, для роботи з цим більш зручний спосіб.</p>
<h4 id="Коротка-форма-поширення-помилок-оператором-"><a class="header" href="#Коротка-форма-поширення-помилок-оператором-">Коротка форма поширення помилок оператором <code>?</code></a></h4>
<p>Блок коду 9-7 демонстрував імплементацію функції <code>read_username_from_file</code>, яка має таку ж функціональність, як і функція в блоці коду 9-6, але дана реалізація використовувала оператор <code>?</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open(&quot;hello.txt&quot;)?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 9-7: Функція, яка повертає помилки коду, який її викликає за допомогою оператора <code>?</code></span></p>
<p>Якщо розмістити оператор <code>?</code> після значення <code>Result</code>, то він буде працювати таким самим чином, як і вираз <code>match</code>, який ми визначали для обробки значення <code>Result</code> в блоці коду 9-6. Якщо значення <code>Result</code> є <code>Ok</code>, то значення, що знаходиться всередині <code>Ok</code>, буде повернутим як результат виразу і програма продовжить виконання. Якщо ж значення є <code>Err</code>, то в цілому з функції буде повернуто <code>Err</code>, так ніби ми використали ключове слово <code>return</code> і значення помилки буде передано функції, що викликала даний код.</p>
<p>Є певна різниця між тим, що виконує вираз <code>match</code> з блоку коду 9-6 і тим, що виконує оператор <code>?</code>. Значення помилок, при яких викликається оператор <code>?</code> проходять через виклик функції <code>from</code>, яка визначена на трейті <code>From</code> стандартної бібліотеки і використовується для конвертації значень із одного типу в інший. Коли оператор <code>?</code> викликає функцію <code>from</code>, отриманий тип помилки конвертується в тим помилки, який був визначений типом, що повертається з поточної функції. Це корисно, коли функція повертає один тип помилки, який являє собою всі можливі шляхи, при яких функція може виконатись не успішно, навіть якщо її частини можуть завершуватись не успішно з різних причин.</p>
<p>Для прикладу, ми б могли змінити функцію <code>read_username_from_file</code> в блоці коду 9-7, щоб вона повертала кастомізований тип помилки визначений нами, який б називався <code>OurError</code>. Якщо ми також визначимо імплементацію <code>impl From</code> для типу <code>OurError</code> при створенні екземпляру <code>OurError</code> із <code>io::Error</code>, тоді виклик оператора <code>?</code> в тілі функції <code>read_username_from_file</code> викличе метод &lt;0&gt;from&lt;/0&gt; і здійснить конвертацію типу помилки без необхідності додавання жодного коду у нашу функцію.</p>
<p>В контексті блоку коду 9-7, оператор <code>?</code> в кінці виклику функції <code>File::open</code> поверне значення значення всередині <code>Ok</code> у змінну <code>username_file</code>. Якщо ж помилка виникне, то оператор <code>?</code> припинить виконання функції заздалегідь і поверне якесь значення <code>Err</code> коду, який її викликав. Те ж саме буде справедливим для оператора <code>?</code> в кінці виклику методу <code>read_to_string</code>.</p>
<p>Оператор <code>?</code> дозволяє уникнути надлишкового коду у функціях і робить їх імплементацію простішою. Ми можемо навіть ще більше скоротити код, об'єднуючи виклики методів в ланцюжок відразу після оператора <code>?</code>, як це показано в блоці коду 9-8.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 9-8: Ланцюжок викликів методів після оператора <code>?</code></span></p>
<p>Ми перенесли створення нового екземпляру <code>String</code> в <code>username</code> на початок функції. Замість створення змінної <code>username_file</code>, ми приєднали ланцюжком виклик <code>read_to_string</code> прямо до результату виклику <code>File::open(&quot;hello.txt&quot;)?</code>. Ми все ще маємо оператор <code>?</code> в кінці виклику <code>read_to_string</code> і все ще повертаємо значення <code>Ok</code>, яке містить <code>username</code>, якщо обидва виклики <code>File::open</code> і <code>read_to_string</code> завершаться успішно, а не повертаємо помилки. Ця функціональність знову ж таки аналогічна тій, що представлена у блоках коду 9-6 і 9-7 з однією тільки відмінністю, що такий шлях більш ергономічний для написання.</p>
<p>Блок коду 9-9 демонструє ще коротший шлях використання <code>fs::read_to_string</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 9-9: Використання методу <code>fs::read_to_string</code> замість того, щоб відкривати файл і потім виконувати його зчитування</span></p>
<p>Зчитування файлу в стрічку є досить типовою операцією, тому стандартна бібліотека надає зручнішу функцію <code>fs::read_to_string</code>, яка відкриває файл, створює новий екземпляр <code>String</code>, зчитує вміст фалу, поміщає вміст в створений екземпляр стрічки <code>String</code> і повертає його. Звичайно, використання методу <code>fs::read_to_string</code> не дає можливості пояснити всі підходи до обробки помилок, тому ми спочатку пішли більш довгим шляхом.</p>
<h4 id="Де-можна-використовувати-оператор-"><a class="header" href="#Де-можна-використовувати-оператор-">Де можна використовувати оператор <code>?</code></a></h4>
<p>Оператор <code>?</code> може бути використаним тільки у функціях, які повертають тип, який сумісний зі значення, яке він може обробити. Це тому, що оператор <code>?</code> створений для обробки раннього повернення значення з функції в такий самий спосіб, як і вираз <code>match</code>, описаний у блоці коду 9-6. Тут вираз <code>match</code> використовує значення <code>Result</code> і повертає значення <code>Err(e)</code> по рукаву раннього виходу. Типом, що повертається з функції має бути тип <code>Result</code>, що є сумісним цим <code>return</code>.</p>
<p>Давайте розглянемо в блоці коду 9-10 помилку, яку отримаємо, якщо використаємо оператор <code>?</code> у функції <code>main</code>, яка має повертати тип, що не сумісний з типом значення, яке ми використовуємо з оператором <code>?</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p><span class="caption">Блок коду 9-10: Спроба використати оператор <code>?</code> всередині функції <code>main</code>, яка не скомпілюється, оскільки має повертати несумісний тип <code>()</code></span></p>
<p>Цей код відкриває файл, тому ця операція може виконатись не успішно. Оператор <code>?</code> слідує за значенням <code>Result</code>, який повертає <code>File::open</code>, але функція <code>main</code> має повертати тип <code>()</code>, а не тип <code>Result</code>. Коли ми спробуємо скомпілювати цей код, ми отримаємо наступне повідомлення про помилку компілювання:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | / fn main() {
4 | |     let greeting_file = File::open(&quot;hello.txt&quot;)?;
  | |                                                ^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
</code></pre>
<p>Ця помилка компілювання вказує на те, що ми можемо використовувати оператор <code>?</code> тільки у функціях, які повертають <code>Result</code>, <code>Option</code>, або інший тип, який імлементує <code>FromResidual</code>.</p>
<p>Для виправлення цієї помилки ми маємо два шляхи. Перший полягає в тому, щоб змінювати тип значення, яке повертаємо для нашої функції, щоб бути сумісним по типу зі значенням, яке використовуємо з оператором <code>?</code> до того моменту, поки немає жодних інших обмежень для цього. Інший полягає в тому, щоб використовувати вираз <code>match</code> або один із методів визначених для типу <code>Result&lt;T, E&gt;</code>, щоб обробити значення <code>Result&lt;T, E&gt;</code> більш підходящим способом.</p>
<p>Помилка компілювання також говорить, що оператор <code>?</code> також можна використовувати зі значенням <code>Option&lt;T&gt;</code>. Як і з використанням <code>?</code> на <code>Result</code>, ми можемо використовувати оператор <code>?</code> на <code>Option</code> у функціях, які повертають <code>Option</code>. Поведінка оператора <code>?</code>, коли викликаємо його на <code>Option&lt;T&gt;</code> є подібною до випадку з <code>Result&lt;T, E&gt;</code>: якщо значення <code>None</code>, то це значення буде повернуто достроково з функції. Якщо ж значення <code>Some</code>, то значення всередині <code>Some</code> буде значенням результату виразу і виконання функції буде продовжуватися далі. Блок коду 9-11 є прикладом функції, що знаходить останній символ в отриманому тексті:</p>
<pre><pre class="playground"><code class="language-rust">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line(&quot;Hello, world\nHow are you today?&quot;),
</span><span class="boring">        Some('d')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;&quot;), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;\nhi&quot;), None);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок коду 9-11: Використання оператора <code>?</code> на значенні <code>Option&lt;T&gt;</code></span></p>
<p>Ця функція повертає <code>Option&lt;char&gt;</code>, тому що як є можливість, що символ може бути, так і можливість, що символу не буде. Ця функція приймає як аргумент стрічковий слайс <code>text</code> і викликає метод <code>lines</code> на ньому, який повертає ітератор над рядками у стрічці. Оскільки ця функція має отримати перший рядок, вона викликає метод <code>next</code> на ітераторі, щоб отримати перше значення з ітератора. Якщо <code>text</code> буде пустою стрічкою, то виклик <code>next</code> поверне значення <code>None</code>, для цього випадку ми використовуємо оператор <code>?</code>, щоб достроково зупинити виконання і повернути <code>None</code> з функції <code>last_char_of_first_line</code>. Якщо ж <code>text</code> не порожня стрічка, виклик <code>next</code> поверне значення <code>Some</code>, яке буде містити стрічковий слайс із першим рядком у <code>text</code>.</p>
<p>Оператор <code>?</code> вилучає цей стрічковий слайс, і ми можемо далі викликати метод <code>chars</code> на цьому зрізі, щоб отримати ітератор символів. Ми зацікавлені в останньому символі першої стрічки, тому ми викликаємо метод <code>last</code>, для останнього елементу ітератора. Це значення також <code>Option</code>, оскільки можливо, що цей перший рядок є пустою стрічкою, наприклад, якщо <code>text</code> починається з пустого рядку, але має символи на наступних рядках, як, до прикладу, у <code>&quot;\nhi&quot;</code>. Однак, якщо є останній символ у першому рядку, то він повернеться загорнутим у <code>Some</code>. Оператор <code>?</code> посередині дає нам виразний спосіб описати логіку, змушуючи нас реалізовувати тіло функції в один рядок. Якщо б ми не використовували оператор <code>?</code> на <code>Option</code>, то довелося би реалізовувати логіку з використанням більшої кількості викликів методів та виразів <code>match</code>.</p>
<p>Варто зазначити, що ми можемо використовувати оператор <code>?</code> на <code>Result</code> всередині функцій, які повертають <code>Result</code>, а також можемо використовувати на <code>Option</code> у функціях, які повертають <code>Option</code>, але ми не можемо їх змішувати і порівнювати. Оператор <code>?</code> не може автоматично конвертувати <code>Result</code> в <code>Option</code> або навпаки. В цих випадках слід використовувати методи на зразок <code>ok</code> на <code>Result</code>, або <code>ok_or</code> на <code>Option</code>, для здійснення явного конвертування.</p>
<p>Поки що всі функції <code>main</code>, які ми використовували повертали значення типу <code>()</code>. Функція <code>main</code> є спеціальною, тому що є вхідною та вихідною точкою для запуску програм і має строгі обмеження до типу значення, яке вона повертає, щоб програма поводила себе так, як очікується.</p>
<p>На щастя, <code>main</code> може також повертати значення типу <code>Result&lt;(), E&gt;</code>. Блок 9-12 містить код з блоку 9-10, але тут ми змінили тип значення, яке повертається з <code>main</code> на <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> і повернули значення <code>Ok(())</code> в кінці тіла функції. Цей код буде тепер компілюватися:</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}
</code></pre>
<p><span class="caption">Блок коду 9-12: Зміна функції <code>main</code> щоб повертати <code>Result&lt;(), E&gt;</code> і мати можливість використання оператора <code>?</code> на значеннях <code>Result</code></span></p>
<p>Тип <code>Box&lt;dyn Error&gt;</code> є <em>об'єктом типажом</em>, про який ми будемо говорити у секції <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">«Використання трейт об'єктів, які допускають значення різних типів»</a><!-- ignore --> розділу 17. На тепер ми можемо читати це, як<code>Box&lt;dyn Error&gt;</code>, що означає «будь який тип помилок». Використання оператора <code>?</code> на значенні <code>Result</code> всередині функції <code>main</code> з помилкою типу <code>Box&lt;dyn Error&gt;</code> є допустимим, оскільки допустимими є будь-які значення <code>Err</code> для дострокового повернення. Навіть якщо тіло цієї функції <code>main</code> буде повертати помилки типу <code>std::io::Error</code>, спеціалізована <code>Box&lt;dyn Error&gt;</code> сигнатура буде залишатися коректною, навіть якщо додамо більше коду в тіло функції <code>main</code>, який може повертати помилки іншого типу.</p>
<p>Коли функція <code>main</code> повертає <code>Result&lt;(), E&gt;</code>, виконання запиниться зі значенням <code>0</code>, якщо <code>main</code> поверне <code>Ok(())</code> і запиниться з ненульовим значенням, якщо <code>main</code> поверне значення <code>Err</code>. Виконувані файли, написані на C повертають цілі числа коли завершуються: програми які виконалися успішно повертають ціле число <code>0</code>, а програми що виконалися з помилкою повертають цілі числа, відмінні від <code>0</code>. Rust також повертає цілі числа з виконуваних файлів, щоб бути сумісним з такою домовленістю.</p>
<p>Функція <code>main</code> може повертати довільний тип, який імплементує <code>std::process::Termination</code> трейт<!-- ignore -->що містить функцію <code>report</code>, яка повертає <code>ExitCode</code>. Зверніться до документації стандартної бібліотеки для отримання додаткової інформації про реалізацію трейта <code>Termination</code> для ваших власних типів.</p>
<p>Тепер, коли ми обговорили деталі виклику <code>panic!</code> й використанню <code>Result</code>, повернімось до теми, яким чином визначати, що з переліченого доцільно використовувати та в яких випадках.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch09-03-to-panic-or-not-to-panic.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch09-03-to-panic-or-not-to-panic.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
