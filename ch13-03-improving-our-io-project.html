<!DOCTYPE HTML>
<html lang="uk" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Покращуємо наш проєкт з введенням/виведенням - Мова програмування Rust</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Мова програмування Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Передмова</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Вступ</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Початок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Встановлення</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Привіт, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Програмування гри - відгадайки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Загальні концепції програмування</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Змінні та мутабельність</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Типи даних</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функції</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Коментарі</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управління потоком виконання</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Розуміння володіння</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Що таке володіння?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Посилання і позичання</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Тип даних слайс</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Використання структур для структурування пов'язаних даних</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Визначення і інстанціювання структур Struct</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Приклад програми, що використовує структури</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис методів</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Енуми і зіставлення з шаблоном</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Визначення енума</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкція управління match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконічний контроль виконання конструкцією if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Керування проєктами, що зростають, за допомогою пакетів, крейтів та модулів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакети та крейти</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Визначення модулів для управління областями видимості та приватністю</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Шлях для доступу до елементів у дереві модулів</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Підключення шляхів до області видимості за допомогою ключового слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Розподіл модулів на різні файли</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Звичайні колекції</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Зберігання списків значень у векторах</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Зберігання тексту у кодуванні UTF-8 у стрічках</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Зберігання ключів і пов'язаних значень у хешмапах</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обробка помилок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Невідновні Помилки із panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Помилки, що піддаються відновленню за допомогою Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! чи не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Узагальнені типи, трейти та лайфтайми</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Узагальнені типи даних</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейти: визначення загальної поведінки</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Перевірка коректності посилань за допомогою часів існування</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написання автоматизованих тестів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Як писати тести</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Контроль над запуском тестів</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Організація тестів</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проєкт з введенням/виведенням: створення програми командного рядка</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Приймання аргументів командного рядка</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Читання файлу</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторизація для покращення модульності та обробки помилок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Розробка Функціонала Бібліотеки із Test-Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Робота зі Змінними Середовища</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Написання Повідомлень Про Помилки в Standard Error Замість Стандартного Виводу</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функціональні можливості мови: Ітератори та Замикання</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замикання: Анонімні Функції що Захоплюють Своє Середовище</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обробка послідовностей елементів за допомогою ітераторів</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html" class="active"><strong aria-hidden="true">13.3.</strong> Покращуємо наш проєкт з введенням/виведенням</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Порівняння швидкодії: цикли проти ітераторів</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Більше про Cargo та Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Налаштування Збірок з Release Профілями</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публікація Крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Робочі Області Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Встановлення Двійкових Файлів з cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Розширення Cargo із Користувацькими Командами</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Розумні вказівники</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Використання Box&lt;T&gt; для вказування на значення в Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Використання розумних вказівників як звичайних посилань за допомогою трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Виконання коду при очищенні за допомогою трейту Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, розумний вказівник з лічильником посилань</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; і шаблон внутрішньої мутабельності</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Цикли посилань можуть призвести до витоку пам'яті</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Конкурентність без страху</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Використання потоків для одночасного запуску коду</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Використання обміну повідомленнями для передачі даних між потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Паралелізм із спільним станом</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Розширювана конкурентність із трейтами Sync і Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Об'єктно орієнтовані особливості Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики об'єктно орієнтованого програмування</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Використання трейтових об'єктів, які допускають значення різних типів</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реалізація патернів об'єктноорієнтованого програмування</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблони та Зіставлення Шаблонів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Усі Місця Можливого Використання Шаблонів</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Спростовуваність: Чи Може Шаблон Бути Невідповідним</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Синтаксис Шаблонів</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Просунутий функціонал</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезпечний Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Поглиблено про трейти</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Поглиблено про типи</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Поглиблено про функції та замикання</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макроси</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Останній проєкт: збірка багатопотокового вебсервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Збірка однопотокового вебсервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Перетворюємо наш однопотоковий сервер на багатопотоковий</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Плавне вимикання і очищення</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Додатки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - ключові слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - оператори та символи</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> С - вивідні трейти</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - корисні інструменти розробки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - видання</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - переклади цієї книжки</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - як робиться Rust і "щонічний Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Мова програмування Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Покращуємо-наш-проєкт-з-введеннямвиведенням"><a class="header" href="#Покращуємо-наш-проєкт-з-введеннямвиведенням">Покращуємо наш проєкт з введенням/виведенням</a></h2>
<p>Використовуючи нові знання про ітератори, ми можемо покращити проєкт введення/виведення у Розділі 12, використовуючи ітератори, щоб зробити деякі місця в коді яснішими та виразнішими. Погляньмо, як ітератори можуть поліпшити нашу реалізацію функцій <code>Config::build</code> і <code>search</code>.</p>
<h3 id="Видалення-clone-за-допомогою-ітератора"><a class="header" href="#Видалення-clone-за-допомогою-ітератора">Видалення <code>clone</code> за допомогою ітератора</a></h3>
<p>У Блоці коду 12-6 ми додали код, що бере слайс зі значень <code>String</code> і створили екземпляр структури <code>Config</code> індексуванням слайса і клонуванням значень, дозволивши структурі <code>Config</code> володіти цими значеннями. У Блоці коду 13-17 ми відтворили реалізацію функції <code>Config::build</code> такою, як у Блоці коду 12-23:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 13-17: відтворення функції <code>Config::build</code> з Блоку коду 12-23</span></p>
<p>Тоді ми казали не хвилюватися через неефективні виклики <code>clone</code>, оскільки ми видалимо їх e майбутньому. Що ж, цей час настав!</p>
<p>Нам тут потрібен <code>clone</code>, тому що ми маємо слайс з елементами <code>String</code> у параметрі <code>args</code>, але функція <code>build</code> не володіє <code>args</code>. Щоб повернути володіння екземпляром <code>Config</code>, нам довелося клонувати значення з полів <code>query</code> та <code>file_path</code> з <code>Config</code>, щоб екземпляр <code>Config</code> міг володіти своїми значеннями.</p>
<p>За допомогою нових знань про ітератори см можемо змінити функцію <code>build</code>, щоб вона брала володіння ітератором як аргумент замість позичати слайс. Ми використаємо функціональність ітератора замість коду, що перевіряє довжину слайса і індексує конкретні місця. Це прояснить, що саме робить функція <code>Config::build</code>, бо доступ до значень забезпечуватиме ітератор.</p>
<p>Коли <code>Config::build</code> прийме володіння ітератором та припинить використовувати операції індексації, що позичають, ми зможемо перемістити значення <code>String</code> з ітератора в <code>Config</code> замість викликати <code>clone</code> і робити новий розподіл пам'яті.</p>
<h4 id="Використання-повернутого-ітератора-напряму"><a class="header" href="#Використання-повернутого-ітератора-напряму">Використання повернутого ітератора напряму</a></h4>
<p>Відкрийте файл <em>src/main.rs</em> з нашого проєкту введення/виведення, що виглядає ось так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Application error: {e}&quot;);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<p>Ми спочатку змінимо початок функції <code>main</code>, яка була в нас у Блоці коду 12-24, на коду з Блоку коду 13-18, який на цей раз використовує ітератор. Це не буде компілюватися, доки ми не оновимо також <code>Config::build</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Application error: {e}&quot;);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">Блок коду 13-18: передавання значення, повернутого <code>env::args</code>, до <code>Config::build</code></span></p>
<p>Функція <code>env::args</code> повертає ітератор! Замість того, щоб збирати значення ітератора до вектора і передавання слайс до <code>Config::build</code>, тепер ми передаємо володіння ітератором, повернутим з <code>env::args</code>, напряму до <code>Config::build</code>.</p>
<p>Далі, нам потрібно оновити визначення <code>Config::build</code>. У файлі <em>src/lib.rs</em> вашого проєкту введення/виведення змінімо сигнатуру <code>Config::build</code>, щоб вона виглядала як у Блоці коду 13-19. Це все ще не компілюється, оскільки нам потрібно оновити тіло функції.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 13-19: оновлення сигнатури <code>Config::build</code>, щоб приймала ітератор</span></p>
<p>The standard library documentation for the <code>env::args</code> function shows that the type of the iterator it returns is <code>std::env::Args</code>, and that type implements the <code>Iterator</code> trait and returns <code>String</code> values.</p>
<p>Ми оновили сигнатуру функції <code>Config::build</code>, зробивши параметр <code>args</code> узагальненого типу з обмеженням трейту <code>impl Iterator&lt;Item = String&gt;</code> замість <code>&amp;[String]</code>. Цей синтаксис <code>impl Trait</code>, який ми обговорили у підрозділі <a href="ch10-02-traits.html#traits-as-parameters">“Трейти як параметри”</a><!-- ignore --> Розділу 10, означає, що <code>args</code> може бути будь-якого типу, що реалізує тип <code>Iterator</code> і повертає елементи типу <code>String</code>.</p>
<p>Оскільки ми беремо володіння <code>args</code> і ми будемо змінювати <code>args</code>, ітеруючи крізь нього, ми можемо додати ключове слово <code>mut</code> в специфікацію параметра <code>args</code>, щоб зробити його мутабельним.</p>
<h4 id="Використання-методів-трейту-iterator-замість-індексування"><a class="header" href="#Використання-методів-трейту-iterator-замість-індексування">Використання методів трейту <code>Iterator</code> замість індексування</a></h4>
<p>Далі ми виправимо тіло <code>Config::build</code>. Оскільки <code>args</code> реалізує трейт <code>Iterator</code>, ми знаємо, що можемо викликати для нього метод <code>next</code>! Блок коду 13-20 оновлює код зі Блоку коду 12-23, використовуючи метод <code>next</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let file_path = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file path&quot;),
        };

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 13-20: зміна тіла <code>Config::build</code> з використанням методів ітератора</span></p>
<p>Згадайте, що перша стрічка в значенні, яке повертає <code>env::args</code>, є назвою програми. Ми хочемо проігнорувати його і дістатися до наступного значення, тож спершу викличемо <code>next</code> і нічого не зробимо з поверненим значенням. По-друге, ми викликаємо <code>next</code>, щоб отримати значення, ми хочемо вставити в поле <code>Config</code> <code>query</code>. Якщо <code>next</code> повертає <code>Some</code>, ми використовуємо <code>match</code>, щоб витягти значення. Якщо вона повертає <code>None</code>, це означає, що було недостатньо аргументів, і ми достроково виходимо, повертаючи значення <code>Err</code>. Те саме ми робимо і зі значенням <code>file_path</code>.</p>
<h3 id="Робимо-код-яснішим-за-допомогою-адаптерів-ітераторів"><a class="header" href="#Робимо-код-яснішим-за-допомогою-адаптерів-ітераторів">Робимо код яснішим за допомогою адаптерів ітераторів</a></h3>
<p>Ми також можемо скористатися ітераторами у функції <code>search</code> у нашому проєкті введення/виведення, який відтворений тут у Блоці коду 13-21 таким, як він був 12-19:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 13-21: реалізація функції <code>search</code> з Блоку коду 12-19</span></p>
<p>Ми можемо зробити цей код чіткішим за допомогою методів-адаптерів ітераторів. Це також дозволить нам уникнути проміжного мутабельного вектору <code>results</code>. Функціональний стиль програмування надає перевагу мінімізації кількості мутабельних станів, щоб зробити код чистішим. Видалення мутабельного стану може уможливити подальше покращення для здійснення паралельного пошуку, оскільки ми не змогли б керувати одночасним доступом до вектора <code>results</code>. Блок коду 13-22 показує ці зміни:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(
</span><span class="boring">        mut args: impl Iterator&lt;Item = String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let query = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;Didn't get a query string&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let file_path = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;Didn't get a file path&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 13-22: використання методів-адаптерів ітераторів у реалізації функції <code>search</code></span></p>
<p>Згадайте, що призначення функції <code>search</code> - повернути всі рядки в <code>contents</code>, що містять <code>query</code>. Так само як у прикладі <code>filter</code> з Блоку коду 13-16, цей код використовує адаптер <code>filter</code> для збереження тільки тих рядків, для яких <code>line.contains(query)</code> повертає <code>true</code>. Потім ми збираємо відповідні рядки у інший вектор за допомогою <code>collect</code>. Набагато простіше! Можете самі спробувати внести аналогічні зміни з використанням методів ітератора у функцію <code>search_case_insensitive</code>.</p>
<h3 id="Вибір-між-циклами-або-ітераторами"><a class="header" href="#Вибір-між-циклами-або-ітераторами">Вибір між циклами або ітераторами</a></h3>
<p>Наступне логічне питання - який стиль вам слід обрати у вашому власному коді й чому: оригінальна реалізація з Блоку коду 13-21 чи версія з ітераторами з Блоку коду 13-22. Більшість програмістів Rust вважають за краще використовувати ітераторний стиль. До нього дещо складніше призвичаїтися в перший час, але відколи ви набудете відчуття різноманітних ітераторів і що вони роблять, ітератори стають простішими для розуміння. Замість того, щоб займатися дрібними уточненнями в циклі й збирати нові вектори, код зосереджується на високорівневій меті циклу. Це дозволяє абстрагуватися від деякого банального коду, щоб легше було побачити концепції, унікальні для цього коду, такі як умови фільтрації, яку має пройти кожен елемент ітератора.</p>
<p>Але чи ці дві реалізації дійсно еквівалентні? Інтуїтивне припущення може казати, що більш низькорівневий цикл буде швидшим. Поговорімо про швидкодію.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-02-iterators.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch13-04-performance.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-02-iterators.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch13-04-performance.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
