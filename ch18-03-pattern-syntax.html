<!DOCTYPE HTML>
<html lang="uk" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>All the Pattern Syntax - Мова програмування Rust</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Початок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Встановлення</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Програмування гри - відгадайки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Загальні концепції програмування</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Змінні та мутабельність</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Типи даних</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функції</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Коментарі</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управління потоком виконання</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Розуміння володіння</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Що таке володіння?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Посилання і позичання</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Тип даних слайс</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Використання структур для структурування пов'язаних даних</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Визначення і інстанціювання структур Struct</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Приклад програми, що використовує структури</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис методів</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Енуми і зіставлення з шаблоном</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Визначення енума</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкція управління match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконічний контроль виконання конструкцією if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Керування проєктами, що зростають, за допомогою пакетів, крейтів та модулів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакети та крейти</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Визначення модулів для управління областями видимості та приватністю</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Referring to Names in Different Modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Підключення шляхів до області видимості за допомогою ключового слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Розподіл модулів на різні файли</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обробка помилок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Невідновні Помилки із panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Помилки, що піддаються відновленню за допомогою Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! чи не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Узагальнені типи, трейти та лайфтайми</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Узагальнені типи даних</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейти: визначення загальної поведінки</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Перевірка коректності посилань за допомогою часів існування</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написання автоматизованих тестів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Як писати тести</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Контроль над запуском тестів</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Організація тестів</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проєкт з введенням/виведенням: створення програми командного рядка</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Приймання аргументів командного рядка</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Читання файлу</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторизація для покращення модульності та обробки помилок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Розробка Функціонала Бібліотеки із Test-Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Робота зі Змінними Середовища</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Написання Повідомлень Про Помилки в Standard Error Замість Стандартного Виводу</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функціональні можливості мови: Ітератори та Замикання</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замикання: Анонімні Функції що Захоплюють Своє Середовище</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обробка послідовностей елементів за допомогою ітераторів</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Покращуємо наш проєкт з введенням/виведенням</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Порівняння швидкодії: цикли проти ітераторів</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Більше про Cargo та Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Налаштування Збірок з Release Профілями</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публікація Крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Робочі Області Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Розширення Cargo із Користувацькими Командами</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Розумні вказівники</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Використання Box&lt;T&gt; для вказування на значення в Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Використання розумних вказівників як звичайних посилань за допомогою трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Виконання коду при очищенні за допомогою трейту Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, розумний вказівник з лічильником посилань</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; і шаблон внутрішньої мутабельності</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Цикли посилань можуть призвести до витоку пам'яті</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Конкурентність без страху</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> What Does Object-Oriented Mean?</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблони та Зіставлення Шаблонів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns May be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Спростовуваність: Чи Може Шаблон Бути Невідповідним</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html" class="active"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Просунутий функціонал</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезпечний Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Поглиблено про трейти</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Поглиблено про типи</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Поглиблено про функції та замикання</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions & Closures</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Останній проєкт: збірка багатопотокового вебсервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Збірка однопотокового вебсервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Перетворюємо наш однопотоковий сервер на багатопотоковий</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Плавне вимикання і очищення</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Додатки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Ключові слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - оператори та символи</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Macros</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Translations</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Newest Features</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> Додаток G - як робиться Rust і "щонічний Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Мова програмування Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Синтаксис-Шаблонів"><a class="header" href="#Синтаксис-Шаблонів">Синтаксис Шаблонів</a></h2>
<p>In this section, we gather all the syntax valid in patterns and discuss why and when you might want to use each one.</p>
<h3 id="Зіставлення-з-Літералами"><a class="header" href="#Зіставлення-з-Літералами">Зіставлення з Літералами</a></h3>
<p>Як ви бачили у Розділі 6, можна зіставляти шаблони з літералами напряму. Наведемо декілька прикладів в наступному коді:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;one&quot;),
        2 =&gt; println!(&quot;two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Цей код виведе в консолі <code>one</code>, оскільки значення в <code>x</code> дорівнює 1. Цей синтаксис корисний, коли ви хочете, щоб ваш код виконував дію, якщо він отримує певне значення.</p>
<h3 id="Зіставлення-з-Найменованими-Змінними"><a class="header" href="#Зіставлення-з-Найменованими-Змінними">Зіставлення з Найменованими Змінними</a></h3>
<p>Іменовані змінні - це незаперечні шаблони, які відповідають будь-якому значенню, і ми багато разів використовували їх у книзі. Однак, існує ускладнення при використанні іменованих змінних у виразах <code>match</code>. Оскільки <code>match</code> починає нову область видимості, змінні, оголошені як частина шаблону всередині виразу <code>match</code>, будуть затінювати змінні з тією ж назвою за межами конструкції <code>match</code>, як і у випадку з усіма змінними. У Блоці Коду 18-11 оголошується змінна з назвою <code>x</code> зі значенням <code>Some(5)</code> та змінна <code>y</code> зі значенням <code>10</code>. Потім ми створюємо вираз <code>match</code> над значенням <code>x</code>. Подивіться на шаблони в рукавах match і <code>println!</code> наприкінці, і перед тим, як запускати цей код або читати далі, спробуйте з'ясувати, що виведе код в консолі.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {y}&quot;),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {y}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-11: A <code>match</code> expression with an arm that introduces a shadowed variable <code>y</code></span></p>
<p>Розглянемо, що відбувається при виконанні виразу <code>match</code>. Шаблон у першому рукаві порівняння не збігається із заданим значенням <code>x</code>, тому код продовжується.</p>
<p>Шаблон у другому рукаві порівняння вводить нову змінну з назвою <code>y</code>, яка буде відповідати будь-якому значенню всередині значення <code>Some</code>. Оскільки ми знаходимося в новій області видимості всередині виразу <code>match</code>, це нова змінна <code>y</code>, а не та <code>y</code>, яку ми оголосили на початку зі значенням 10. Ця нова прив'язка <code>y</code> буде відповідати будь-якому значенню всередині <code>Some</code>, яке ми маємо в <code>x</code>. Таким чином, ця нова <code>y</code> зв'язується з внутрішнім значенням <code>Some</code> в <code>x</code>. Це значення <code>5</code>, тому вираз для цього рукава виконується і виводить в консолі <code>Matched, y = 5</code>.</p>
<p>Якби значення <code>x</code> було б <code>None</code> замість <code>Some(5)</code>, шаблони в перших двох рукавах не збіглися б, тому значення збіглося б з підкресленням. Ми не створювали змінну <code>x</code> у шаблоні підкреслення, тому <code>x</code> у виразі - це все ще зовнішній <code>x</code>, який не був затінений. У цьому гіпотетичному випадку <code>match</code> виведе в консолі <code>Default case, x = None</code>.</p>
<p>Коли вираз <code>match</code> виконано, його область видимості закінчується, так само як і область видимості внутрішньої <code>y</code>. Останній <code>println!</code> виведе в консолі <code>at the end: x = Some(5), y = 10</code>.</p>
<p>Щоб створити вираз <code>match</code>, який порівнює значення зовнішніх <code>x</code> і <code>y</code>, замість того, щоб вводити затінену змінну, нам потрібно буде використовувати умовний запобіжник. Ми поговоримо про запобіжники пізніше в розділі <a href="#extra-conditionals-with-match-guards">&quot;Додаткові умови з запобіжниками&quot;</a><!--
ignore --> .</p>
<h3 id="Декілька-Шаблонів"><a class="header" href="#Декілька-Шаблонів">Декілька Шаблонів</a></h3>
<p>У виразах <code>match</code> ви можете зіставляти кілька шаблонів, використовуючи синтаксис <code>|</code>, який є оператором шаблону <em>or</em>. Наприклад, у наступному коді ми порівнюємо значення <code>x</code> з рукавами match, перше з яких має опцію <em>or</em>, що означає, що якщо значення <code>x</code> збігається з будь-яким зі значень у цьому рукаві, код цього рукава буде виконано:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;one or two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Цей код виведе в консоль <code>one or two</code>.</p>
<h3 id="Зіставлення-Діапазонів-Значень-з-"><a class="header" href="#Зіставлення-Діапазонів-Значень-з-">Зіставлення Діапазонів Значень з <code>..=</code></a></h3>
<p>Синтаксис <code>..=</code> дозволяє робити інклюзивне зіставлення, зіставлення з діапазоном включно з останнім його значенням. В наступному коді буде виконана гілка, шаблон якої зіставляється з будь-яким значенням заданого діапазону:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;one through five&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Якщо <code>x</code> дорівнює 1, 2, 3, 4, або 5, то буде обрана перша гілка виразу match. Цей синтаксис більш зручний для зіставлення декількох значень ніж використання оператора <code>|</code> для вираження тої самої ідеї; якщо ми використовували б <code>|</code>, нам було б потрібно вказати <code>1 | 2 | 3 | 4 | 5</code>. Вказання діапазону набагато коротше, особливо якщо ми хочемо зіставляти, скажімо, будь-яке число між 1 та 1,000!</p>
<p>The compiler checks that the range isn’t empty at compile time, and because the only types for which Rust can tell if a range is empty or not are <code>char</code> and numeric values, ranges are only allowed with numeric or <code>char</code> values.</p>
<p>Ось приклад використання діапазонів значень <code>char</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;early ASCII letter&quot;),
        'k'..='z' =&gt; println!(&quot;late ASCII letter&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Rust може визначити, що <code>'c'</code> в першому діапазоні шаблона та виведе в консоль <code>early ASCII letter</code>.</p>
<h3 id="Деструктуризація-для-Розбору-Значень-на-Частини"><a class="header" href="#Деструктуризація-для-Розбору-Значень-на-Частини">Деструктуризація для Розбору Значень на Частини</a></h3>
<p>Ми також використовуємо шаблони для деструктуризації структур, енумів та кортежів для використання різних частин їх значень. Розглянемо покроково кожне значення.</p>
<h4 id="Деструктуризація-Структур"><a class="header" href="#Деструктуризація-Структур">Деструктуризація Структур</a></h4>
<p>Listing 18-12 shows a <code>Point</code> struct with two fields, <code>x</code> and <code>y</code>, that we can break apart using a pattern with a <code>let</code> statement.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">Listing 18-12: Destructuring a struct’s fields into separate variables</span></p>
<p>В цьому коді створюються змінні <code>a</code> та <code>b</code>, які відповідають значенням полів <code>x</code> та <code>y</code> структури <code>p</code>. Цей приклад показує, що назви змінних у шаблоні не обов'язково повинні збігатися з назвами полів структури. Однак, зазвичай назви змінних збігаються з назвами полів, щоб полегшити запам'ятовування того, які змінні походять з яких полів. Через таке поширене використання, а також через те, що запис <code>let Point { x: x, y: y } = p;</code> містить багато повторень, Rust має скорочення для шаблонів, які відповідають полям struct: вам потрібно лише перерахувати назву поля struct, і змінні, створені на основі шаблону, матимуть ті ж самі назви. Блок Коду 18-13 працює так само як і Блок Коду 18-12, але змінні, що створюються в шаблоні <code>let</code>, є <code>x</code> і <code>y</code> замість <code>a</code> і <code>b</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-13: Destructuring struct fields using struct field shorthand</span></p>
<p>Цей код створить змінні <code>x</code> та <code>y</code>, які відповідають полям <code>x</code> та<code>y</code> змінної <code>p</code>. В результаті змінні <code>x</code> та <code>y</code> містять значення зі структури <code>p</code>.</p>
<p>Ми також можемо деструктурувати за допомогою буквених значень як частини шаблону struct замість того, щоб створювати змінні для всіх полів. Це дозволяє нам перевіряти деякі з полів на наявність певних значень, створюючи змінні для деструктуризації інших полів.</p>
<p>In Listing 18-14, we have a <code>match</code> expression that separates <code>Point</code> values into three cases: points that lie directly on the <code>x</code> axis (which is true when <code>y = 0</code>), on the <code>y</code> axis (<code>x = 0</code>), or neither.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-14: Destructuring and matching literal values in one pattern</span></p>
<p>Перший рукав буде відповідати будь-якій точці, що лежить на осі <code>x</code>, вказуючи, що поле <code>y</code> збігається, якщо його значення збігається з <code>0</code>. Шаблон все ще створює змінну <code>x</code>, яку ми можемо використовувати в коді для цього рукава.</p>
<p>Аналогічно, другий рукав зіставляє будь-яку точку на осі <code>y</code>, вказуючи, що поле <code>x</code> збігається, якщо його значення дорівнює <code>0</code>, і створює змінну <code>y</code> для значення поля <code>y</code>. Третій рукав не визначає ніяких літералів, тому воно відповідає будь-якій іншій <code>Point</code> і створює змінні для полів <code>x</code> і <code>y</code>.</p>
<p>In this example, the value <code>p</code> matches the second arm by virtue of <code>x</code> containing a 0, so this code will print <code>On the y axis at 7</code>.</p>
<p>Remember that a <code>match</code> expression stops checking arms once it has found the first matching pattern, so even though <code>Point { x: 0, y: 0}</code> is on the <code>x</code> axis and the <code>y</code> axis, this code would only print <code>On the x axis at 0</code>.</p>
<h4 id="Деструктуризація-Енумів"><a class="header" href="#Деструктуризація-Енумів">Деструктуризація Енумів</a></h4>
<p>У цій книзі ми вже деструктурували енуми (наприклад, в Блоці Коду 6-5 Розділу 6), але ми ще окремо не обговорювали, що шаблон деструктурування енума повинен відповідати тому, як визначаються збережені в енумі дані. Як приклад, у Блоці Коду 18-15 ми використовуємо енум <code>Message</code> з Блоку Коду 6-2 і пишемо <code>match</code> з шаблонами, які деструктуруватимуть кожне внутрішнє значення.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x, y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; println!(
            &quot;Change the color to red {}, green {}, and blue {}&quot;,
            r, g, b
        ),
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-15: Destructuring enum variants that hold different kinds of values</span></p>
<p>Цей код виведе в консолі <code>Change the color to red 0, green 160, and blue 255</code>. Спробуйте змінити значення <code>msg</code>, щоб побачити виконання коду з інших рукавів.</p>
<p>Для варіантів енуму без даних, таких як <code>Message::Quit</code>, ми не можемо деструктурувати значення далі. Ми тільки можемо зіставити буквальне значення <code>Message::Quit</code>, і жодних змінних у цьому шаблоні немає.</p>
<p>Для структуро-подібних варіантів енуму, таких як <code>Message::Move</code>, ми можемо використовувати шаблон схожий з тим, що ми вказували для зіставлення структур. Після назви варіанту ми ставимо фігурні дужки, а потім перелічуємо поля зі змінними, щоб розбити все на частини, які будуть використані в коді для цього рукава. Тут ми використовуємо скорочену форму, як ми це робили в Блоці Коду 18-13.</p>
<p>Шаблони кортежо-подібних варіантів енума, таких як <code>Message::Write</code>, що містить кортеж з одним елементом, і <code>Message::ChangeColor</code>, що містить кортеж з трьома елементами подібні до шаблону, який ми вказуємо для зіставлення кортежів. Кількість змінних у шаблоні повинна відповідати кількості елементів у варіанті, який ми порівнюємо.</p>
<h4 id="Деструктуризація-Вкладених-Структур-та-Енумів"><a class="header" href="#Деструктуризація-Вкладених-Структур-та-Енумів">Деструктуризація Вкладених Структур та Енумів</a></h4>
<p>Дотепер всі наші приклади стосувалися зіставлення структур або енумів глибиною в один рівень, але зіставлення може працювати і на вкладених елементах! Наприклад, ми можемо переробити код у Блоці Коду 18-15 для додавання підтримки RGB та HSV кольорів у повідомленні <code>ChangeColor</code>, як показано у Блоці Коду 18-16.</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; println!(
            &quot;Change the color to red {}, green {}, and blue {}&quot;,
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; println!(
            &quot;Change the color to hue {}, saturation {}, and value {}&quot;,
            h, s, v
        ),
        _ =&gt; (),
    }
}
</code></pre></pre>
<p><span class="caption">Блок Коду 18-16: Зіставлення з вкладеними енумами</span></p>
<p>Шаблон першого рукава у виразі <code>match</code> відповідає варіанту енуму <code>Message::ChangeColor</code>, який містить варіант <code>Color::Rgb</code>; потім шаблон зв'язується з трьома внутрішніми значеннями <code>i32</code>. Шаблон другого рукава також відповідає варіанту енуму <code>Message::ChangeColor</code>, але внутрішній енум замість цього збігається з <code>Color::Hsv</code>. Ми можемо вказувати такі складні умови в одному виразі <code>match</code>, навіть якщо залучені два енуми.</p>
<h4 id="Деструктуризація-Структур-та-Кортежів"><a class="header" href="#Деструктуризація-Структур-та-Кортежів">Деструктуризація Структур та Кортежів</a></h4>
<p>Ми можемо змішувати, зіставляти та вкладати деструктуризуючі шаблони і складнішими способами. В наступному прикладі показано складна деструктуризація, де ми вкладаємо структури та кортежі в кортеж та деструктуризуємо все примітивні значення:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<p>This code lets us break complex types into their component parts so we can use the values we’re interested in separately.</p>
<p>Destructuring with patterns is a convenient way to use pieces of values, such as the value from each field in a struct, separately from each other.</p>
<h3 id="Ігнорування-Значень-Шаблона"><a class="header" href="#Ігнорування-Значень-Шаблона">Ігнорування Значень Шаблона</a></h3>
<p>You’ve seen that it’s sometimes useful to ignore values in a pattern, such as in the last arm of a <code>match</code>, to get a catchall that doesn’t actually do anything but does account for all remaining possible values. There are a few ways to ignore entire values or parts of values in a pattern: using the <code>_</code> pattern (which you’ve seen), using the <code>_</code> pattern within another pattern, using a name that starts with an underscore, or using <code>..</code> to ignore remaining parts of a value. Розглянемо, як і навіщо використовувати кожен з цих шаблонів.</p>
<h4 id="Ігнорування-цілого-значення-з-_-_"><a class="header" href="#Ігнорування-цілого-значення-з-_-_">Ігнорування цілого значення з _ <code>_</code></a></h4>
<p>Ми використали символ підкреслення як шаблон підстановки, який буде відповідати будь-якому значенню, але не прив'язуватиметься до нього. This is especially useful as the last arm in a <code>match</code> expression, but we can also use it in any pattern, including function parameters, as shown in Listing 18-17.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<p><span class="caption">Блок Коду 18-17: Використання <code>_</code> в сигнатурі функції</span></p>
<p>This code will completely ignore the value <code>3</code> passed as the first argument, and will print <code>This code only uses the y parameter: 4</code>.</p>
<p>In most cases when you no longer need a particular function parameter, you would change the signature so it doesn’t include the unused parameter. Ignoring a function parameter can be especially useful in cases when, for example, you're implementing a trait when you need a certain type signature but the function body in your implementation doesn’t need one of the parameters. You then avoid getting a compiler warning about unused function parameters, as you would if you used a name instead.</p>
<h4 id="ignoring-parts-of-a-value-with-a-nested-_"><a class="header" href="#ignoring-parts-of-a-value-with-a-nested-_">Ignoring Parts of a Value with a Nested <code>_</code></a></h4>
<p>We can also use <code>_</code> inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. Listing 18-18 shows code responsible for managing a setting’s value. The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;Can't overwrite an existing customized value&quot;);
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!(&quot;setting is {:?}&quot;, setting_value);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-18: Using an underscore within patterns that match <code>Some</code> variants when we don’t need to use the value inside the <code>Some</code></span></p>
<p>This code will print <code>Can't overwrite an existing customized value</code> and then <code>setting is Some(5)</code>. In the first match arm, we don’t need to match on or use the values inside either <code>Some</code> variant, but we do need to test for the case when <code>setting_value</code> and <code>new_setting_value</code> are the <code>Some</code> variant. In that case, we print the reason for not changing <code>setting_value</code>, and it doesn’t get changed.</p>
<p>In all other cases (if either <code>setting_value</code> or <code>new_setting_value</code> are <code>None</code>) expressed by the <code>_</code> pattern in the second arm, we want to allow <code>new_setting_value</code> to become <code>setting_value</code>.</p>
<p>We can also use underscores in multiple places within one pattern to ignore particular values. Listing 18-19 shows an example of ignoring the second and fourth values in a tuple of five items.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!(&quot;Some numbers: {first}, {third}, {fifth}&quot;)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок Коду 18-19: Ігнорування кількох частин кортежу</span></p>
<p>This code will print <code>Some numbers: 2, 8, 32</code>, and the values 4 and 16 will be ignored.</p>
<h4 id="ignoring-an-unused-variable-by-starting-its-name-with-_"><a class="header" href="#ignoring-an-unused-variable-by-starting-its-name-with-_">Ignoring an Unused Variable by Starting Its Name with <code>_</code></a></h4>
<p>If you create a variable but don’t use it anywhere, Rust will usually issue a warning because an unused variable could be a bug. However, sometimes it’s useful to be able to create a variable you won’t use yet, such as when you’re prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 18-20, we create two unused variables, but when we compile this code, we should only get a warning about one of them.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><span class="caption">Listing 18-20: Starting a variable name with an underscore to avoid getting unused variable warnings</span></p>
<p>Here we get a warning about not using the variable <code>y</code>, but we don’t get a warning about not using <code>_x</code>.</p>
<p>Note that there is a subtle difference between using only <code>_</code> and using a name that starts with an underscore. The syntax <code>_x</code> still binds the value to the variable, whereas <code>_</code> doesn’t bind at all. To show a case where this distinction matters, Listing 18-21 will provide us with an error.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    if let Some(_s) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 18-21: An unused variable starting with an underscore still binds the value, which might take ownership of the value</span></p>
<p>We’ll receive an error because the <code>s</code> value will still be moved into <code>_s</code>, which prevents us from using <code>s</code> again. However, using the underscore by itself doesn’t ever bind to the value. Listing 18-22 will compile without any errors because <code>s</code> doesn’t get moved into <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    if let Some(_) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-22: Using an underscore does not bind the value</span></p>
<p>Цей код працює, оскільки ми ніколи та ні до чого не прив'язували <code>s</code>; воно не зміщене.</p>
<h4 id="Ігнорування-Інших-Частин-Значення-з-"><a class="header" href="#Ігнорування-Інших-Частин-Значення-з-">Ігнорування Інших Частин Значення з <code>..</code></a></h4>
<p>With values that have many parts, we can use the <code>..</code> syntax to use specific parts and ignore the rest, avoiding the need to list underscores for each ignored value. The <code>..</code> pattern ignores any parts of a value that we haven’t explicitly matched in the rest of the pattern. In Listing 18-23, we have a <code>Point</code> struct that holds a coordinate in three-dimensional space. In the <code>match</code> expression, we want to operate only on the <code>x</code> coordinate and ignore the values in the <code>y</code> and <code>z</code> fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-23: Ignoring all fields of a <code>Point</code> except for <code>x</code> by using <code>..</code></span></p>
<p>We list the <code>x</code> value and then just include the <code>..</code> pattern. This is quicker than having to list <code>y: _</code> and <code>z: _</code>, particularly when we’re working with structs that have lots of fields in situations where only one or two fields are relevant.</p>
<p>The syntax <code>..</code> will expand to as many values as it needs to be. Listing 18-24 shows how to use <code>..</code> with a tuple.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {first}, {last}&quot;);
        }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-24: Matching only the first and last values in a tuple and ignoring all other values</span></p>
<p>In this code, the first and last value are matched with <code>first</code> and <code>last</code>. <code>..</code> буде зіставлятися та ігнорувати зі всім посередині.</p>
<p>However, using <code>..</code> must be unambiguous. If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error. Listing 18-25 shows an example of using <code>..</code> ambiguously, so it will not compile.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre>
<p><span class="caption">Listing 18-25: An attempt to use <code>..</code> in an ambiguous way</span></p>
<p>Якщо ми скомпілюємо цей приклад, ми отримаємо цю помилку:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` due to previous error
</code></pre>
<p>It’s impossible for Rust to determine how many values in the tuple to ignore before matching a value with <code>second</code> and then how many further values to ignore thereafter. This code could mean that we want to ignore <code>2</code>, bind <code>second</code> to <code>4</code>, and then ignore <code>8</code>, <code>16</code>, and <code>32</code>; or that we want to ignore <code>2</code> and <code>4</code>, bind <code>second</code> to <code>8</code>, and then ignore <code>16</code> and <code>32</code>; and so forth. The variable name <code>second</code> doesn’t mean anything special to Rust, so we get a compiler error because using <code>..</code> in two places like this is ambiguous.</p>
<h3 id="Додаткові-Умови-з-Запобіжниками-Зіставлення"><a class="header" href="#Додаткові-Умови-з-Запобіжниками-Зіставлення">Додаткові Умови з Запобіжниками Зіставлення</a></h3>
<p>A <em>match guard</em> is an additional <code>if</code> condition, specified after the pattern in a <code>match</code> arm, that must also match for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows.</p>
<p>The condition can use variables created in the pattern. Listing 18-26 shows a <code>match</code> where the first arm has the pattern <code>Some(x)</code> and also has a match guard of <code>if x % 2 == 0</code> (which will be true if the number is even).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!(&quot;The number {} is even&quot;, x),
        Some(x) =&gt; println!(&quot;The number {} is odd&quot;, x),
        None =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Блок Коду 18-26: Додавання запобіжника зіставлення до шаблона</span></p>
<p>Цей приклад виведе в консолі <code>The number 4 is even</code>. When <code>num</code> is compared to the pattern in the first arm, it matches, because <code>Some(4)</code> matches <code>Some(x)</code>. Then the match guard checks whether the remainder of dividing <code>x</code> by 2 is equal to 0, and because it is, the first arm is selected.</p>
<p>If <code>num</code> had been <code>Some(5)</code> instead, the match guard in the first arm would have been false because the remainder of 5 divided by 2 is 1, which is not equal to 0. Rust would then go to the second arm, which would match because the second arm doesn’t have a match guard and therefore matches any <code>Some</code> variant.</p>
<p>There is no way to express the <code>if x % 2 == 0</code> condition within a pattern, so the match guard gives us the ability to express this logic. The downside of this additional expressiveness is that the compiler doesn't try to check for exhaustiveness when match guard expressions are involved.</p>
<p>In Listing 18-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that we created a new variable inside the pattern in the <code>match</code> expression instead of using the variable outside the <code>match</code>. That new variable meant we couldn’t test against the value of the outer variable. Listing 18-27 shows how we can use a match guard to fix this problem.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {n}&quot;),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {y}&quot;, x);
}
</code></pre></pre>
<p><span class="caption">Listing 18-27: Using a match guard to test for equality with an outer variable</span></p>
<p>Цей код виведе в консолі <code>Default case, x = Some(5)</code>. The pattern in the second match arm doesn’t introduce a new variable <code>y</code> that would shadow the outer <code>y</code>, meaning we can use the outer <code>y</code> in the match guard. Instead of specifying the pattern as <code>Some(y)</code>, which would have shadowed the outer <code>y</code>, we specify <code>Some(n)</code>. This creates a new variable <code>n</code> that doesn’t shadow anything because there is no <code>n</code> variable outside the <code>match</code>.</p>
<p>Запобіжник зіставлення <code>if n == y</code> не є шаблоном і тому не вводить нових змінних. This <code>y</code> <em>is</em> the outer <code>y</code> rather than a new shadowed <code>y</code>, and we can look for a value that has the same value as the outer <code>y</code> by comparing <code>n</code> to <code>y</code>.</p>
<p>You can also use the <em>or</em> operator <code>|</code> in a match guard to specify multiple patterns; the match guard condition will apply to all the patterns. Listing 18-28 shows the precedence when combining a pattern that uses <code>|</code> with a match guard. The important part of this example is that the <code>if y</code> match guard applies to <code>4</code>, <code>5</code>, <em>and</em> <code>6</code>, even though it might look like <code>if y</code> only applies to <code>6</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-28: Combining multiple patterns with a match guard</span></p>
<p>The match condition states that the arm only matches if the value of <code>x</code> is equal to <code>4</code>, <code>5</code>, or <code>6</code> <em>and</em> if <code>y</code> is <code>true</code>. When this code runs, the pattern of the first arm matches because <code>x</code> is <code>4</code>, but the match guard <code>if y</code> is false, so the first arm is not chosen. The code moves on to the second arm, which does match, and this program prints <code>no</code>. The reason is that the <code>if</code> condition applies to the whole pattern <code>4 | 5 | 6</code>, not only to the last value <code>6</code>. In other words, the precedence of a match guard in relation to a pattern behaves like this:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>замість:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>After running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the <code>|</code> operator, the arm would have matched and the program would have printed <code>yes</code>.</p>
<h3 id="-bindings"><a class="header" href="#-bindings"><code>@</code> Bindings</a></h3>
<p>The <em>at</em> operator <code>@</code> lets us create a variable that holds a value at the same time as we’re testing that value for a pattern match. In Listing 18-29, we want to test that a <code>Message::Hello</code> <code>id</code> field is within the range <code>3..=7</code>. We also want to bind the value to the variable <code>id_variable</code> so we can use it in the code associated with the arm. We could name this variable <code>id</code>, the same as the field, but for this example we’ll use a different name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;Found an id in range: {}&quot;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;Found an id in another range&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;Found some other id: {}&quot;, id),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-29: Using <code>@</code> to bind to a value in a pattern while also testing it</span></p>
<p>Цей приклад виведе в консолі <code>Found an id in range: 5</code>. By specifying <code>id_variable @</code> before the range <code>3..=7</code>, we’re capturing whatever value matched the range while also testing that the value matched the range pattern.</p>
<p>In the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn’t have a variable that contains the actual value of the <code>id</code> field. The <code>id</code> field’s value could have been 10, 11, or 12, but the code that goes with that pattern doesn’t know which it is. The pattern code isn’t able to use the value from the <code>id</code> field, because we haven’t saved the <code>id</code> value in a variable.</p>
<p>In the last arm, where we’ve specified a variable without a range, we do have the value available to use in the arm’s code in a variable named <code>id</code>. The reason is that we’ve used the struct field shorthand syntax. But we haven’t applied any test to the value in the <code>id</code> field in this arm, as we did with the first two arms: any value would match this pattern.</p>
<p>Using <code>@</code> lets us test a value and save it in a variable within one pattern.</p>
<h2 id="Підсумок"><a class="header" href="#Підсумок">Підсумок</a></h2>
<p>Шаблони в Rust дуже корисні для визначення різниці між різновидами даних. When used in <code>match</code> expressions, Rust ensures your patterns cover every possible value, or your program won’t compile. Patterns in <code>let</code> statements and function parameters make those constructs more useful, enabling the destructuring of values into smaller parts at the same time as assigning to variables. We can create simple or complex patterns to suit our needs.</p>
<p>Next, for the penultimate chapter of the book, we’ll look at some advanced aspects of a variety of Rust’s features.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch18-02-refutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch19-00-advanced-features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch18-02-refutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch19-00-advanced-features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
