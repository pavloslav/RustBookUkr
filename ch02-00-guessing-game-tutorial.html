<!DOCTYPE HTML>
<html lang="uk" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Програмування Гри Відгадайки - Мова програмування Rust</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Мова Програмування Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Передмова</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Вступ</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Початок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Встановлення</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Привіт, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html" class="active"><strong aria-hidden="true">2.</strong> Програмування Гри Відгадайки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Загальні Концепції Програмування</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Змінні і Мутабельність</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Типи Даних</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функції</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Коментарі</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Потік Виконання</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Розуміння Володіння</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Що Таке Володіння?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Посилання та Позичання</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Слайси</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Використання Структур для Групування Пов'язаних Даних</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Визначення та Створення Екземпляра Структури</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Приклад Програми з Використанням Структур</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис Методів</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Енуми та Зіставлення зі Шаблоном</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Визначення Енума</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкція Потоку Виконання match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконічний Потік Виконання з if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Керування Щораз Більшими Проєктами із Пакетами, Крейтами та Модулями</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакети та Крейти</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Визначення Модулів для Контролю Області Видимості та Приватності</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Шлях для Доступу до Елементів у Дереві Модулів</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введення Шляхів до Області Видимості з Ключовим Словом use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Розподіл Модулів на Різні Файли</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Звичайні Колекції</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Зберігання Списків Значень з Векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Зберігання Тексту у Кодуванні UTF-8 в Стрічках</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Зберігання Ключів з Асоційованими Значеннями у Хеш-Мапах</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обробка Помилок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Невідновлювані Помилки з panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Відновлювані Помилки з Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! чи не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Узагальнені Типи, Трейти та Часи Існування</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Узагальнені Типи Даних</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейти: Визначення Спільної Поведінки</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Перевірка Коректності Посилань із Часами Існування</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написання Автоматизованих Тестів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Як Писати Тести</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Керування Запуском Тестів</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Організація Тестів</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проєкт з Вводом/Виводом: Створення Програми з Інтерфейсом Командного Рядка</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Приймання Аргументів Командного Рядка</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Читання Файлу</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторинг для Покращення Модульності та Обробки Помилок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Розробка Функціонала Бібліотеки із Test-Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Робота зі Змінними Середовища</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Написання Повідомлень про Помилки у Помилковий Вивід замість Стандартного Виводу</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функціональні Можливості Мови: Ітератори та Замикання</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замикання: Анонімні Функції, що Захоплюють Своє Середовище</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обробка Послідовностей Елементів з Ітераторами</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Покращення Нашого Проєкту з Вводом/Виводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Порівняння Швидкодії: Цикли Проти Ітераторів</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Більше про Cargo та Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Налаштування Збірок з Release Профілями</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публікація Крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Робочі Області Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Встановлення Двійкових Файлів з cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Розширення Cargo із Користувацькими Командами</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Розумні Вказівники</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Використання Box&lt;T&gt; для Вказування на Дані в Купі</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Ставлення до Розумних Вказівників як до Звичайних Посилань з Трейтом Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Виконання Коду при Очищенні з Трейтом Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt; - Розумний Вказівник з Лічильником Посилань</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; та Шаблон Внутрішньої Мутабельності</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Цикли Посилань Можуть Спричинити Витік Пам'яті</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безстрашна Конкурентність</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Використання Потоків для Одночасного Виконання Коду</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Застосування Обміну Повідомлень для Передавання Даних між Потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Конкурентність зі Спільним Станом</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Розширювана Конкурентність із Трейтами Sync та Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Особливості Об'єктоорієнтованого Програмування в Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики Об'єктоорієнтованих Мов</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Використання Трейт-Об'єктів, які Допускають Значення Різних Типів</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реалізація Об'єктоорієнтованого Шаблону Проєктування</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблони та Зіставлення Шаблонів</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Усі Місця Можливого Використання Шаблонів</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Спростовуваність: Чи Може Шаблон Бути Невідповідним</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Синтаксис Шаблонів</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Просунуті Можливості</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезпечний Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Поглиблено про Трейти</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Поглиблено про Типи</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Поглиблено про Функції та Замикання</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макроси</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Останній Проєкт: Збірка Багатопотокового Вебсервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Збірка Однопотокового Вебсервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Перетворюємо Наш Однопотоковий Сервер на Багатопотоковий</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Плавне Вимкнення та Очищення</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Додатки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Ключові Слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Оператори та Символи</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Похідні Трейти</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Корисні Інструменти Розробки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Видання</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Переклади Книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - як Розробляється Rust і "Нічний Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Мова програмування Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Програмування-Гри-Відгадайки"><a class="header" href="#Програмування-Гри-Відгадайки">Програмування Гри Відгадайки</a></h1>
<p>Розпочнемо вивчення Rust зі спільної розробки проєкту! Цей розділ ознайомить вас із кількома поширеними концепціями Rust, демонструючи як вони використовуються у реальній програмі. Ви дізнаєтеся про <code>let</code>, <code>match</code>, методи, асоційовані функції, використання зовнішніх крейтів і навіть більше! Наступні розділи розкриють ці концепції детальніше. У цьому розділі ви лише займатиметеся основами.</p>
<p>Ми розв'язуватимемо класичну задачу для програмістів-початківців: гру &quot;відгадай число&quot;. Умови такі: програма генерує випадкове ціле число між 1 та 100. Потім пропонує гравцю ввести спробу відгадати. Після введення спроби вона скаже, чи число більше або менше за загадане. Якщо відгадано правильно, гра виведе привітання і припинить роботу.</p>
<h2 id="Початок-Нового-Проєкту"><a class="header" href="#Початок-Нового-Проєкту">Початок Нового Проєкту</a></h2>
<p>Щоб розпочати новий проєкт, перейдіть до теки <em>projects</em>, яку ви створили у Розділі 1, і створіть новий проєкт за допомогою Cargo, ось так:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>Перша команда, <code>cargo new</code>, приймає першим параметром ім'я проєкту (<code>guessing_game</code>). Друга команда переходить до теки нового проєкту.</p>
<p>Перегляньмо щойно створений файл <em>Cargo.toml</em>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>Як ви вже бачили у Розділі 1, <code>cargo new</code> створює програму &quot;Hello, world!&quot;. Подивімося, що міститься у файлі <em>src/main.rs</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Скомпілюймо цю програму “Hello, world!” і запустимо її за один крок за допомогою команди <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>Команда <code>run</code> стає в пригоді, коли треба швидко розвивати проєкт, і ця гра є якраз таким проєктом: ми хочемо швидко тестувати кожну ітерацію перед тим, як переходити до наступної.</p>
<p>Відкрийте файл <em>src/main.rs</em>. Увесь код ми писатимемо у цьому файлі.</p>
<h2 id="Обробляємо-Здогадку"><a class="header" href="#Обробляємо-Здогадку">Обробляємо Здогадку</a></h2>
<p>Перша частина програми буде просити у користувача ввести здогадку, обробляти те, що він увів, і перевіряти, чи ввів він дані у потрібній формі. Для початку, дозволимо користувачеві ввести здогадку. Введіть код з Блоку коду 2-1 до <em>src/main.rs</em>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {guess}&quot;);
}
</code></pre>
<p><span class="caption">Блок коду 2-1: Код, що отримує здогадку у користувача і виводить її</span></p>
<p>Цей код містить багато інформації, тому розбиратимемо його рядок за рядком. Щоб отримати, що ввів користувач, і вивести результат, нам треба ввести бібліотеку введення/виведення <code>io</code> в область видимості. Бібліотека <code>io</code> входить до стандартної бібліотеки, що зветься <code>std</code>:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>За замовчуванням Rust має набір елементів, визначених у стандартній бібліотеці, що їх він вводить до області видимості будь-якої програми. Цей набір зветься <em>прелюдією</em>, і ви можете побачити все, що в ній міститься, <a href="../std/prelude/index.html">в документації стандартної бібліотеки</a>.</p>
<p>Якщо типу, який ви хочете використати, нема у прелюдії, вам доведеться явно вносити цей тип у область видимості за допомогою інструкції <code>use</code>. Використання бібліотеки <code>std::io</code> надає вам ряд корисних особливостей, включно з можливістю користувацького вводу.</p>
<p>Як ви вже бачили у Розділі 1, функція <code>main</code> є точкою входу у програму:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Синтаксична конструкція <code>fn</code> проголошує нову функцію, <code>()</code> показує, що вона не має параметрів, і фігурна дужка <code>{</code> починає тіло функції.</p>
<p>Як ви вже дізналися з того ж Розділу 1, <code>println!</code> - це макрос, що виводить стрічку на екран:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Цей код виводить повідомлення, що це за гра і запитує введення у користувача.</p>
<h3 id="Зберігання-Значень-в-Змінних"><a class="header" href="#Зберігання-Значень-в-Змінних">Зберігання Значень в Змінних</a></h3>
<p>Тепер створімо <em>змінну</em> для зберігання того, що користувач увів, ось так:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Тепер програма стає цікавішою! В цьому коротенькому рядку відбувається багато всього. Ми використовуємо інструкцію <code>let</code>, щоб створити змінну. Ось інший приклад:</p>
<pre><code class="language-rust ignore">let apples = 5;
</code></pre>
<p>Цей рядок створює нову змінну з назвою <code>apples</code> і зв'язує її зі значенням 5. У Rust змінні є немутабельними за замовчанням, тобто щойно ми надамо змінній значення, воно не зміниться. Детально ця концепція обговорюється в підрозділі <a href="ch03-01-variables-and-mutability.html#variables-and-mutability">&quot;Змінні та мутабельність&quot;</a><!-- ignore -->
Розділу 3. Щоб зробити змінну мутабельною, слід додати <code>mut</code> перед її іменем:</p>
<pre><code class="language-rust ignore">let apples = 5; // немутабельна
let mut bananas = 5; // мутабельна
</code></pre>
<blockquote>
<p>Примітка: синтаксична конструкція <code>//</code> починає коментар, що продовжується до кінця рядка. Rust ігнорує весь вміст коментаря. Про коментарі детальніше йдеться в <a href="ch03-04-comments.html">Розділі 3</a><!-- ignore -->.</p>
</blockquote>
<p>Повернімося до нашої ігрової програми - відгадайки. Тепер ви знаєте, що <code>let  mut guess</code> створить мутабельну змінну на ім'я <code>guess</code>. Знак рівності (<code>=</code>) каже Rust, що тепер ми хочемо зв'язати щось зі змінною. З правого боку знаку рівності знаходиться значення, з яким зв'язується <code>guess</code>, а саме результат виклику <code>String::new</code>, функції, що повертає новий екземпляр стрічки <code>String</code>. <a href="../std/string/struct.String.html"><code>String</code></a><!-- ignore --> <code>String</code> - це тип стрічки, що надається стандартною бібліотекою; це кодовані в UTF-8 шматки тексту, які можна нарощувати.</p>
<p>Синаксична конструкція <code>::</code> в рядку <code>::new`</code>позначає, що <code>new</code> - це асоційована функція типу <code>String</code>. <em>Асоційована функція</em> є реалізованою для типу, в цьому випадку <code>String</code>. Ця функція <code>new</code> створює нову, порожню <code>String</code>. Функція <code>new</code> зустрінеться вам у багатьох типах, оскільки це звичайна назва функції, що створює нове значення певного виду.</p>
<p>В цілому: рядок <code>let mut guess = String::new();</code> створив мутабельну змінну, що зараз зв'язана з новим, порожнім екземпляром <code>String</code>. Уф!</p>
<h3 id="Отримання-Вхідних-Даних-від-Користувача"><a class="header" href="#Отримання-Вхідних-Даних-від-Користувача">Отримання Вхідних Даних від Користувача</a></h3>
<p>Згадаймо, що ми додали функціональність введення/виведення зі стандартної бібліотеки за допомогою <code>use std::io;</code> у першому рядку програми. Тепер викличмо функцію <code>stdin</code> з модуля <code>io</code>, що дозволить обробляти те, що вводить користувач:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Якби ми не імпортували бібліотеку <code>io</code> за допомогою <code>use std::io</code> на початку програми, ми могли б використати цю функцію, написавши цей виклик як <code>std::io::stdin</code>. Функциія <code>stdin</code> повертає екземпляр <a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->; цей тип являє собою дескриптор (handle) стандартного потоку введення термінала.</p>
<p>Далі рядок <code>.read_line(&amp;mut guess)</code> викликає метод <a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!--
ignore --> дескриптора стандартного введення, щоб отримати, що ввів користувач. Ми також передаємо </p>
<p><code>&amp;mut guess</code> аргументом до <code>read_line</code>, щоб повідомити йому, до якої стрічки зберегти введення користувача. Повне завдання <code>read_line</code> - взяти те, що користувач набрав у стандартний потік введення і додати до стрічки (не перезаписавши її вміст), тому ми передаємо стрічку як аргумент. Стрічка-аргумент має бути мутабельною, щоб метод міг змінити її вміст.</p>
<p><code>&amp;</code> позначає, що цей аргумент - <em>посилання</em>, що дає вам можливість надати кільком частинам вашого коду доступ до одного фрагменту даних без кількаразового копіювання цих даних у пам'яті. Посилання - складна тема, але одна з основних переваг Rust полягає в безпеці та легкості використання посилань. Для завершення цієї програми вам не знадобляться особливо детальні знання про посилання. Поки що все, що вам треба знати - що посилання, як і зміні, типово є немутабельними. Тому необхідно писати<code>&amp;mut guess</code>, а не просто<code>&amp;guess</code>, щоб зробити його мутабельним. (Розділ 4 пояснить посилання ретельніше.)</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="Обробка-Потенційної-Невдачі-з-result"><a class="header" href="#Обробка-Потенційної-Невдачі-з-result">Обробка Потенційної Невдачі з <code>Result</code></a></h3>
<p>Ми ще не закінчили розбиратися із цим рядком коду. Хоча ми обговорюємо третій рядок тексту, це все ще частина єдиного логічного рядка коду. Наступна частина - це ось цей метод:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect(&quot;Failed to read line&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Ми могли б написати цей код ось так:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
</code></pre>
<p>Однак один довгий рядок важко читати, тому краще його розділити. Коли ви викликаєте метод за допомогою синтаксичної конструкції <code>.method_name()</code> часто має сенс розпочати новий рядок і додати відступи, щоб розділити довгі рядки. Тепер розглянемо, що цей рядок робить.</p>
<p>Як уже було сказано, <code>read_line</code> додає те, що ввів користувач, у стрічку, яку ми передали як аргумент, але також повертає значення <code>Result</code>. <a href="../std/result/enum.Result.html"><code>Result</code></a><!--
ignore --> Тип <code>Result</code> - це </p>
<p><a href="ch06-00-enums.html"><em>перелік (enumeration)</em></a><!-- ignore -->, який часто звуть просто <em>енум</em>, і цей тип може перебувати в одному з кількох можливих станів. Кожен такий стан зветься <em>варіантом</em>.</p>
<p><a href="ch06-00-enums.html">Розділ 6</a><!-- ignore --> розповість про енуми детальніше. Призначення типів <code>Result</code> - представлення інформації для обробки помилок.</p>
<p><code>Result</code> має варіанти <code>Ok</code> та <code>Err</code>. Варіант <code>Ok</code> показує, що операція була вдалою, і всередині варіанту <code>Ok</code> знаходиться успішно згенероване значення. Варіант <code>Err</code> позначає невдачу, і містить інформацію, як і чому операція була невдалою.</p>
<p>Значення типу <code>Result</code>, як і значення будь-якого іншого типу, мають визначені для них методи. Екземпляр <code>Result</code> має доступний для виклику <a href="../std/result/enum.Result.html#method.expect">метод <code>expect</code></a><!-- ignore -->
. Якщо цей екземпляр <code>Result</code> має значення <code>Err</code>, то <code>expect</code> викличе аварійне завершення програми та виведе повідомлення, яке ви передали до <code>expect</code> параметром. Якщо метод <code>read_line</code> поверне <code>Err</code>, це, швидше за все, станеться внаслідок помилки, яка станеться в операційній системі. Якщо цей екземпляр <code>Result</code> має значення <code>Ok</code>, <code>expect</code> візьме повернуте значення, яке знаходиться в <code>Ok</code>, і поверне тільки це значення, щоб ним можна було скористатися. В цьому випадку це значення - кількість байтів, введених користувачем до стандартного потоку.</p>
<p>Якщо ви не викличете <code>expect</code>, програма скомпілюється, проте ви отримаєте попередження:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `guessing_game` (bin &quot;guessing_game&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust попереджає, що ви не використали значення <code>Result</code>, повернуте з <code>read_line</code>, що означає, що програма не обробляє можливу помилку.</p>
<p>Правильний спосіб пригнітити попередження - власне, обробити помилку, але оскільки ми в цьому випадку просто хочемо, щоб програма аварійно завершилася, якщо виникне проблема, то можемо скористатися <code>expect</code>. Ви дізнаєтеся про те, як відновити роботу програми при помилці, у <a href="ch09-02-recoverable-errors-with-result.html">Розділі 9</a><!-- ignore -->.</p>
<h3 id="Виведення-Значень-в-Консолі-із-Заповнювачами-println"><a class="header" href="#Виведення-Значень-в-Консолі-із-Заповнювачами-println">Виведення Значень в Консолі із Заповнювачами <code>println!</code></a></h3>
<p>Якщо не враховувати завершувальної фігурної дужки, лишився лише один рядок, який ми ще не обговорили:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>    println!(&quot;You guessed: {guess}&quot;);
<span class="boring">}
</span></code></pre>
<p>Цей рядок виводить стрічку, в якій ми зберегли те, що ввів користувач. Фігурні дужки <code>{}</code> - це заповнювач: можна уявити, що <code>{}</code> - клешні маленького краба, що тримає значення на місці. При виведенні значення змінної, назву змінної можна розмістити у фігурних дужках. При виведенні результату обчислення виразу розмістіть порожні фігурні дужки у форматній стрічці, а потім додайте за форматною стрічкою список, розділений комами, виразів, які треба вивести у кожному порожньому заповнювачі з фігурних дужок у тому самому порядку. Виведення змінної і результату обчислення виразу в одному виклику <code>println!</code> виглядатиме так:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {x} and y + 2 = {}&quot;, y + 2);
<span class="boring">}
</span></code></pre></pre>
<p>Цей код виведе <code>x = 5 and y + 2 = 12</code>.</p>
<h3 id="Тестування-Першої-Частини"><a class="header" href="#Тестування-Першої-Частини">Тестування Першої Частини</a></h3>
<p>Протестуймо першу частину гри &quot;відгадай число&quot;. Запустіть її за допомогою <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>На цей момент перша частина гри завершена: ми отримуємо дані з клавіатури та виводимо їх.</p>
<h2 id="Генерація-Таємного-Числа"><a class="header" href="#Генерація-Таємного-Числа">Генерація Таємного Числа</a></h2>
<p>Тепер нам треба згенерувати таємне число, яке користувач пробуватиме відгадати. Таємне число має бути різним кожного разу, щоб у гру було цікаво грати більше одного разу. Використаймо випадкове число від 1 до 100, щоб гра була не надто складною. Rust поки що не має функціональності для генерації випадкових чисел у стандартній бібліотеці; натомість команда Rust надає <a href="https://crates.io/crates/rand">крейт <code>rand</code></a> з таким функціоналом.</p>
<h3 id="Використання-Крейта-для-Отримання-Додаткової-Функціональності"><a class="header" href="#Використання-Крейта-для-Отримання-Додаткової-Функціональності">Використання Крейта для Отримання Додаткової Функціональності</a></h3>
<p>Пам'ятайте, що крейт є набором файлів вихідного коду Rust. Проєкт, що ми збираємо - це <em>двійковий крейт</em>, який є виконуваним. Крейт <code>rand</code> - це <em>бібліотечний крейт</em>, і він містить код, призначений для використання в інших програмах, та не може бути запущеним самостійно.</p>
<p>Використання зовнішніх крейтів - найсильніший бік Cargo. Перед тим, як писати код, що використовує <code>rand</code>, ми маємо змінити файл <em>Cargo.toml</em>, додавши туди крейт <code>rand</code> як залежність. Відкрийте цей файл і додайте такий рядок унизу, під заголовком секції <code>[dependencies]</code>, яку для вас створив Cargo. Переконайтеся, що зазначили <code>rand</code> точно так, як тут, із цим номером версії, інакше приклади коду з цього розділу можуть не запрацювати:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.5&quot;
</code></pre>
<p>У файлі <em>Cargo.toml</em> все, що йде після заголовку секції, належить до цієї секції - до початку нової секції. У секції <code>[dependencies]</code> ви повідомляєте Cargo, від яких зовнішніх крейтів залежить ваш проєкт і які версії цих крейтів вам потрібні. У цьому випадку, ми зазначаємо крейт <code>rand</code> із семантичним версіюванням <code>0.8.5</code>. Cargo розуміє <a href="http://semver.org">Семантичне версіювання</a><!-- ignore --> (яке іноді звуть <em>SemVer</em>), що є стандартом для запису номерів версій. Запис <code>0.8.5</code> насправді є скороченням для <code>^0.8.5</code>, що означає будь-яку версію, не меншу за 0.8.5, але меншу за 0.9.0.</p>
<p>Cargo вважає ці версії з сумісними з публічним API з версією 0.8.5, і ця специфікація гарантує, що ви отримаєте останній патч реліз, який все ще буде скомпільований з кодом у цьому розділі. У версій 0.9.0 і більших не гарантується збереження API, яке використовується подальшими прикладами.</p>
<p>Тепер, не змінюючи коду, побудуємо проєкт, як показано в Блоці коду 2-2.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">Блок коду 2-2: Вивід команди <code>cargo build</code> після додавання крейту rand як залежності</span></p>
<p>Ви можете бачити інші номери версій (але всі вони будуть сумісні з кодом, завдяки SemVer!) і різні рядки (залежно від операційної системи), і рядки можуть бути в іншому порядку.</p>
<p>Тепер, коли ми маємо зовнішню залежність, Cargo витягає останні версії всього, що нам треба, з <em>реєстру</em>, тобто копії даних з <a href="https://crates.io/">Crates.io</a>. На crates.io в екосистемі Rust люди викладають свої проєкти Rust з відкритим кодом, щоб ними могли скористатися інші.</p>
<p>Після оновлення реєстру Cargo перевіряє секцію <code>[dependencies]</code> і завантажує крейти, вказані там, але яких у вас бракує. В цьому випадку, хоча ми вказали тільки залежність від <code>rand</code>, Cargo також завантажив інші крейти, від яких залежить робота <code>rand</code>. Після завантаження крейтів Rust їх компілює, а потім компілює проєкт із доступними залежностями.</p>
<p>Якщо ви знову запустите <code>cargo build</code>, не зробивши жодних змін, ви не отримаєте жодної відповіді окрім рядка <code>Finished</code>. Cargo знає, що він вже завантажив і скомпілював залежності, а ви не змінили нічого, що б їх стосувалося, у файлі <em>Cargo.toml</em>. Cargo також знає, що ви не змінили нічого у коді, тому він не буде його перекомпільовувати. Оскільки роботи у Cargo немає, він просто завершується.</p>
<p>Якщо ви відкриєте файл <em>src/main.rs</em>, зробите тривіальну зміну, збережете і знову зберете, то побачите тільки два рядки виводу:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Ці рядки показують, що Cargo оновив збірку тільки вашою дрібною правкою до файлу <em>src/main.rs</em>. Залежності не змінилися, і Cargo знає, що може заново використати те, що він вже завантажив і скомпілював.</p>
<h4 id="Забезпечення-Відтворюваності-Збірок-із-Файлом-cargolock"><a class="header" href="#Забезпечення-Відтворюваності-Збірок-із-Файлом-cargolock">Забезпечення Відтворюваності Збірок із Файлом <em>Cargo.lock</em></a></h4>
<p>Cargo має механізм, що гарантує однаковість збірки того самого артефакту кожного разу, коли ви чи хтось інший збирає ваш код: Cargo використає тільки ті версії залежностей, які ви зазначили, доки ви не вкажете інші. Наприклад, якщо наступного тижня вийде <code>rand</code> версії <code>0.8.6</code>, що міститиме важливе виправлення помилки, але також міститиме регресію, що зламає ваш код. Щоб упоратися з цим, при першому запуску <code>cargo build</code> Rust створює файл <em>Cargo.lock</em>, що відтепер розміщується у теці <em>guessing_game</em>.</p>
<p>Коли ви збираєте проєкт вперше, Cargo визначає всі версії залежностей, що відповідають критерію, і записує їх до файлу <em>Cargo.lock</em>. Коли ви пізніше збиратимете проєкт, Cargo побачить, що файл <em>Cargo.lock</em> існує, і використає версії, зазначені там, а не буде наново робити всю роботу з визначення версій. Це дозволяє автоматично робити відтворювану збірку. Іншими словами, ваш проєкт залишиться на версії 0.8.5, доки ви самі не захочете оновити її, завдяки файлу <em>Cargo.lock</em>. Оскільки файл <em>Cargo.lock</em> важливий для відтворюваної збірки, він часто додається до контролю початкового коду разом із рештою коду в проєкті.</p>
<h4 id="Оновлення-Крейта-для-Отримання-Нової-Версії"><a class="header" href="#Оновлення-Крейта-для-Отримання-Нової-Версії">Оновлення Крейта для Отримання Нової Версії</a></h4>
<p>Коли ж ви <em>хочете</em> оновити крейт, Cargo надає іншу команду, <code>update</code>, яка ігнорує файл <em>Cargo.lock</em> і визначає всі останні версії, що відповідають специфікаціям у <em>Cargo.toml</em>. Cargo запише ці версії до файлу <em>Cargo.lock</em>. Але за замовчанням Cargo шукатиме тільки версії, більші за 0.8.5 і менші 0.9.0. Якщо крейт <code>rand</code> вийшов у двох нових версіях, 0.8.6 та 0.9.0, то запустивши <code>cargo update</code> ви побачите таке:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo проігнорує реліз 0.9.0. Тут також можна звернути увагу на зміну у файлі <em>Cargo.lock</em> - версія крейта <code>rand</code>, яку ви використовуєте, тепер 0.8.6. Якщо вам потрібен <code>rand</code> версії 0.9.0 чи будь-якої версії у гілці 0.9.<em>x</em>, вам доведеться оновити файл <em>Cargo.toml</em>, щоб він мав такий вигляд:</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.9.0&quot;
</code></pre>
<p>Наступного разу, коли ви запустите <code>cargo build</code>, Cargo оновить реєстр доступних крейтів і заново перечитає вимоги до <code>rand</code> відповідно до вказаної вами нової версії.</p>
<p>Можна ще багато розповісти про <a href="http://doc.crates.io">Cargo</a><!-- ignore --> і <a href="http://doc.crates.io/crates-io.html">його екосистему</a><!-- ignore -->, яка обговорюється у Розділі 14, але поки що цього знати достатньо. Cargo робить використання бібліотек дуже простим, що дозволяє растацеанцям писати менші проєкти, зібрані з кількох пакетів.</p>
<h3 id="Генерація-Випадкового-Числа"><a class="header" href="#Генерація-Випадкового-Числа">Генерація Випадкового Числа</a></h3>
<p>Використаймо <code>rand</code> для генерації числа, що треба відгадати. Наступний крок - оновити <em>src/main.rs</em>, як показано в Блоці коду 2-3.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!(&quot;The secret number is: {secret_number}&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {guess}&quot;);
}
</code></pre>
<p><span class="caption">Блок коду 2-3: Додаємо код, необхідний для генерації випадкового числа</span></p>
<p>Спершу ми додаємо рядок <code>use rand::Rng</code>. Трейт <code>Rng</code> визначає методи, які реалізує генератор випадкових чисел, і цей трейт має бути в області видимості, щоб ми могли скористатися цими методами. Розділ 10 розповість про трейти детальніше.</p>
<p>Далі ми додаємо всередині ще два рядки. У першому рядку ми викликаємо функцію <code>rand::thread_rng</code>, що дає нам генератор випадкових чисел, яким ми користуватимемся: він прив'язаний до потоку виконання, а його початкове значення задане операційною системою. Потім ми викликаємо метод генератора випадкових чисел <code>gen_range</code>. Цей метод визначається трейтом <code>Rng</code>, який ми внесли до області видимості інструкцією <code> use range::Rng</code>. Метод <code>gen_range</code> приймає параметрами два числа і генерує випадкове число в діапазоні між ними. Вираз для діапазону, що ми його тут застосували, має форму <code>початок..=кінець</code> і включає нижню і верхню межі, тому треба вказувати <code>1..=100</code>, щоб отримати число між 1 та 100.</p>
<blockquote>
<p>Примітка: Ви, звісно, не можете одразу знати, які трейти використати і які методи та функції викликати з крейта, тому кожен крейт має документацію з інструкцією до використання. Ще одна корисна можливість Cargo полягає в тому, що команда <code>cargo doc --open</code> збере на вашому комп'ютері документацію, надану всіма залежностями, і відкриє її у вашому переглядачі. Якщо вам цікавий інший функціонал, скажімо, крейту <code>rand</code>, запустіть <code>cargo doc --open</code> і клацніть <code>rand</code> на боковій панелі ліворуч.</p>
</blockquote>
<p>Другий рядок, який ми додали до коду, виводить таємне число. Це корисно, поки ми розробляємо програму, щоб можна було перевірити її роботу, але ми видалимо його у фінальній версії. Буде не дуже цікаво, якщо програма виводитиме відповідь одразу по запуску!</p>
<p>Спробуємо запустити програму кілька разів:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>Ви маєте побачити різні випадкові числа, і вони мають бути між 1 та 100. Чудова робота!</p>
<h2 id="Порівняння-Здогадки-з-Таємним-Числом"><a class="header" href="#Порівняння-Здогадки-з-Таємним-Числом">Порівняння Здогадки з Таємним Числом</a></h2>
<p>Тепер, коли ми маємо введене користувачем і випадкове числа, ми можемо їх порівняти. Цей крок показано в Блоці коду 2-4. Зверніть увагу, що цей код ще не компілюється, як ми зараз пояснимо.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span>
    println!(&quot;You guessed: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p><span class="caption">Блок коду 2-4: Різні дії в залежності від порівняння двох чисел</span></p>
<p>Спершу ми додали ще одну інструкцію <code>use</code>, яка вводить тип <code>std::cmp::Ordering</code> зі стандартної бібліотеки в область видимості. Тип <code>Ordering</code> (&quot;впорядкування&quot;) - це ще один енум, що має варіанти: <code>Less</code> (&quot;менше&quot;), <code>Greater</code> (&quot;більше&quot;), and <code>Equal</code> (&quot;дорівнює&quot;). Це три можливі результати порівняння двох значень.</p>
<p>Потім ми додали в кінець коду п'ять нових рядків, в яких використали тип <code>Ordering</code>. Метод <code>cmp</code> порівнює два значення і може бути викликаний для всього, що можна порівнювати. Він приймає параметром посилання на те, що ви хочете порівнювати; тут він порівнює <code>guess</code> із <code>secret_number</code>. Потім він повертає варіант енуму <code>Ordering</code>, який ми внесли у область видимості за допомогою інструкції <code>use</code>. Ми скористалися виразом <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> , щоб визначити, що робити далі залежно від варіанту <code>Ordering</code>, що його повернув виклик <code>cmp</code> зі значеннями <code>guess</code> та <code>secret_number</code>.</p>
<p>Вираз <code>match</code> складається з <em>рукавів</em>. Рукав складається зі <em>шаблона</em> (&lt;0&gt;pattern&lt;/0&gt;) для порівняння та коду, який буде виконано, якщо значення, передане виразу <code>match</code>, відповідає шаблону цього рукава. Rust бере значення, передане <code>match</code>, і по черзі перевіряє шаблони рукавів. Шаблони та конструкція <code>match</code> - потужні засоби Rust, які дозволяють вам виражати різноманітні ситуації, які можуть трапитися вам при програмуванні, і допомагають переконатися, що ви обробили їх усіх. Детально ці можливості будуть розглянуті в Розділах 6 і 18, відповідно.</p>
<p>Розберімо крок за кроком цей приклад з виразом <code>match</code>. Нехай користувач увів 50, а випадково згенероване цього разу таємне число -
38.</p>
<p>Коли код порівнює 50 і 38, метод <code>cmp</code> поверне <code>Ordering::Greater</code>, бо 50 більше за 38. Вираз <code>match</code> отримує значення <code>Ordering::Greater</code> і починає перевіряти шаблони кожного рукава. Він перевіряє шаблон першого рукава, <code>Ordering::Less</code>, і бачить, що значення <code>Ordering::Greater</code> не відповідає <code>Ordering::Less</code>, тому пропускає рукав і переходить до наступного рукава. Шаблон наступного рукава, <code>Ordering::Greater</code>, <em>відповідає</em> <code>Ordering::Greater</code>! Код цього рукава буде виконано і виведе на екран <code>Too big!</code>. Вираз <code>match</code> завершується після першого вдалого порівняння, тому останній рукав в цьому випадку не буде перевірено.</p>
<p>Але Блок коду 2-4 все ще не компілюється. Спробуймо його скомпілювати:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                 --- ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |                 |
   |                 arguments to this function are incorrect
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`
note: associated function defined here

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` due to previous error
</code></pre>
<p>Суть цієї помилки в тому, що тут є <em>невідповідні типи</em>. Rust має сильну, статичну систему типів. Разом із тим, він має систему виведення типів. Коли ми писали <code>let mut guess = String::new()</code>, Rust зміг вивести, що <code>guess</code> має бути типу <code>String</code> і не просив нас написати тип. <code>secret_number</code>, з іншого боку, числового типу. Кілька числових типів Rust можуть мати значення між 1 та 100: <code>i32</code>, знакове 32-бітне число; <code>u32</code>, беззнакове 32-бітне число; <code>i64</code>, знакове 64-бітне число і кілька інших. Як не вказати іншого, Rust за замовчанням обере <code>i32</code>, і це й буде типом <code>secret_number</code>, якщо ви не додасте інформацію про тип деінде, щоб змусити Rust вивести інший числовий тип. Причина ж цієї помилки полягає в тому, що Rust не може порівнювати стрічку і числовий тип.</p>
<p>Зрештою, ми хочемо перетворити стрічку <code>String</code>, яку програма прочитала з клавіатури, в числовий тип, щоб можна було порівняти його як число зі таємним числом. Це можна зробити, додавши ще один рядок до функції <code>main</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
<span class="boring">}
</span></code></pre>
<p>Ось цей рядок:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</code></pre>
<p>Ми створили змінну з назвою <code>guess</code>. Але чекайте, в програмі вже ніби існує змінна з назвою <code>guess</code>? Так, але Rust дозволяє затінити попереднє значення <code>guess</code> новим. <em>Затінення</em> дозволяє нам наново використати ім'я змінної <code>guess</code>, щоб не довелося створювати дві окремі змінні на кшталт <code>guess_str</code> і <code>guess</code>. Про це детальніше піде у <a href="ch03-01-variables-and-mutability.html#shadowing">Розділі 3</a><!-- ignore -->Розділ 3 детальніше розповідає про затінення, а поки що знайте, що ця особливість часто використовується, коли нам треба перетворити значення з одного типу в інший.</p>
<p>Ми зв'язали нову змінну з виразом <code>guess.trim().parse()</code>. <code>guess</code> у цьому виразі стосується першої змінної <code>guess</code>, у якій міститься стрічка, введена користувачем. Метод <code>trim</code>, застосований до екземпляра <code>String</code>, видалить всі пробільні символи на початку і в кінці, що треба зробити, аби порівняти стрічку з <code>u32</code>, який містить виключно числові дані. Користувач має натиснути на <span class="keystroke">enter</span>, щоб спрацював метод <code>read_line</code> і данні були введені, але це додає символ нового рядка до стрічки. Наприклад, якщо користувач набере <span class="keystroke">5</span> і натисне <span
class="keystroke">enter</span>, <code>guess</code> буде виглядати як <code>5\n</code>. <code>\n</code> позначає символ нового рядка. (У Windows натискання <span
class="keystroke">enter</span> створює символи повернення каретки та нового рядка, <code>\r\n</code>.) Метод <code>trim</code> видалить <code>\n</code> чи <code>\r\n</code>, і залишиться просто <code>5</code>.</p>
<p><a href="../std/primitive.str.html#method.parse">Метод <code>parse</code> для стрічок</a><!-- ignore --> перетворює стрічку на інший тип. Тут ми застосовуємо його для перетворення стрічки в число. Ми маємо повідомити Rust, який саме числовий тип нам потрібен, за допомогою <code>let guess: u32</code>. Двокрапка (<code>:</code>) після <code>guess</code> каже Rust, що ми анотуємо тип змінної. У Rust є кілька вбудованих числових типів; <code>u32</code>, що ви бачите тут є беззнаковим 32-бітним цілим. Це непоганий вибір для невеликих додатних чисел. Ви дізнаєтесь про інші типи у <a href="ch03-02-data-types.html#integer-types">Розділі 3</a><!-- ignore -->.</p>
<p>На додачу, саме анотація <code>u32</code> в цьому прикладі та порівняння із <code>secret_number</code> означає, що Rust виведе, що <code>secret_number</code> теж має бути <code>u32</code>. І тепер порівнюватимуться два значення одного типу!</p>
<p>Метод <code>parse</code> буде працювати тільки з символами, які можна логічно перетворити на числа, і тому легко може викликати помилки. Якщо, наприклад, стрічка містить <code>A👍%</code>, її неможливо буде перетворити на число. Оскільки метод <code>parse</code> може завершитися невдачею, він повертає <code>Result</code>, майже так само, як і метод <code>read_line</code> (про який ми вже говорили раніше в підрозділі <a href="#handling-potential-failure-with-result">&quot;Керування потенційною невдачею за допомогою <code>Result</code>&quot;</a><!-- ignore-->). Ми обробимо цей <code>Result</code> так само - за допомогою методу <code>expect</code>. Якщо <code>parse</code> поверне варіант <code>Result</code> <code>Err</code>, бо він не зміг створити число зі стрічки, виклик <code>expect</code> аварійно припинить гру і виведе повідомлення, яке ми йому надали. Якщо <code>parse</code> вдало створив число зі стрічки, він поверне варіант <code>Result</code> <code>Ok</code>, а <code>expect</code> поверне потрібне нам число зі значення <code>Ok</code>.</p>
<p>А тепер запустімо програму:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Чудово! Хоча ми й додали пробіли перед здогадкою, програма все одно зрозуміла, що користувач увів 76. Запустіть програму кілька разів, щоб перевірити різну поведінку на різних введених даних: введіть таємне число, більше за нього і менше.</p>
<p>Гра тепер майже працює, але користувачеві надається тільки одна можливість вгадати. Змінімо це, додавши цикл!</p>
<h2 id="Введення-Декількох-Здогадок-із-Циклами"><a class="header" href="#Введення-Декількох-Здогадок-із-Циклами">Введення Декількох Здогадок із Циклами</a></h2>
<p>Ключове слово <code>loop</code> створює нескінчений цикл. Ми додамо цикл, щоб дати користувачам більше можливостей відгадати число:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --snip--

    println!(&quot;The secret number is: {secret_number}&quot;);

    loop {
        println!(&quot;Please input your guess.&quot;);

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<p>Як ви можете бачити, ми перенесли в цикл усе від запрошення ввести здогадку і до кінця. Обов'язково додайте в ці рядки відступи у чотири пробілами та знову запустіть програму. Програма запрошує ввести нову здогадку до нескінченості, що, власне, є новою проблемою. Не схоже, що користувач може вийти!</p>
<p>Користувач завжди може перервати програму, натиснувши клавіатурне скорочення <span class="keystroke">ctrl-c</span>. Але є інший спосіб втекти від цього ненажерного чудовиська - згаданий при обговоренні <code>parse</code> у підрозділі <a href="#comparing-the-guess-to-the-secret-number">&quot;Порівняння здогадки з таємним числом”</a><!--
ignore -->: якщо користувач введе щось, крім числа, програма аварійно завершиться. Ми можемо скористатися з цього, щоб користувач зумів вийти з програми, як показано тут:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Введення <code>quit</code> (&quot;вийти&quot;) дійсно призводить до виходу з гри, але так само спрацює будь-що, що не є числом. А все ж таки, це щонайменше не найкращий спосіб. Ми хочемо, щоб гра сама зупинялася, коли ми відгадали число.</p>
<h3 id="Вихід-Після-Вдалої-Здогадки"><a class="header" href="#Вихід-Після-Вдалої-Здогадки">Вихід Після Вдалої Здогадки</a></h3>
<p>Запрограмуймо гру виходити, якщо користувач виграв, додавши інструкцію <code>break</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Додавання рядку <code>break</code> після<code>You win!</code> примусить програму вийти з циклу, якщо користувач відгадав таємне число. Вихід із циклу призведе до виходу з програми, бо цикл - це остання частина функції <code>main</code>.</p>
<h3 id="Обробка-Неправильних-Вхідних-Даних"><a class="header" href="#Обробка-Неправильних-Вхідних-Даних">Обробка Неправильних Вхідних Даних</a></h3>
<p>Для покращення роботи гри, замість аварійного виходу, коли користувач вводить не число, зробімо так, що гра ігнорувала те, що ввели, щоб користувач міг продовжувати відгадувати. Ми можемо зробити це, змінивши рядок, де <code>guess</code> перетворюється зі <code>String</code> на <code>u32</code>, як показано в Блоці коду 2-5.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {guess}&quot;);

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Блок коду 2-5: ігнорування введеного не-числа і запит ввести іншу відгадку замість аварійного завершення програми</span></p>
<p>Ми замінили виклик <code>expect</code> на вираз <code>match</code>, щоб перейти від аварійного завершення програми до обробки помилки. Згадаймо, що метод <code>parse</code> повертає тип <code>Result</code>, а <code>Result</code> - це енум, що має варіанти <code>Ok</code> та <code>Err</code>. Ми використовуємо тут вираз <code>match</code>, так само як робили з <code>Ordering</code>, що його повертає метод <code>cmp</code>.</p>
<p>Якщо <code>parse</code> зможе вдало перетворити стрічку на число, він поверне значення <code>Ok</code>, що міститиме результат - число. Це значення <code>Ok</code> буде відповідати зразку першого рукава, і весь вираз <code>match</code> поверне значення <code>num</code>, яке <code>parse</code> обчислив і поклав всередину значення <code>Ok</code>. Це число потрапить саме туди, куди нам треба - в нову змінну <code>guess</code>, яку ми створюємо.</p>
<p>Якщо <code>parse</code> <em>не</em> зможе перетворити стрічку на число, він поверне значення <code>Err</code>, що міститиме більше інформації про помилку. Значення <code>Err</code> не відповідає шаблону <code>Ok(num)</code> у першому рукаві <code>match</code>, але відповідає шаблону <code>Err(_)</code> у другому. Підкреслення <code>_</code> перехопить будь-яке значення; в цьому випадку, ми кажемо, що вираз має відповідати будь-якому <code>Err</code>, незалежно від інформації, що міститься у ньому. Тож програма виконає код другого рукава, <code>continue</code>, який каже програмі перейти на наступну ітерацію циклу <code>loop</code> і знову запитати наступну спробу. Таким чином, програма ігнорує всі помилки, які можуть зустрітися <code>parse</code>!</p>
<p>Нарешті все у нашій програмі має працювати як треба. Спробуймо запустити її:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>Блискуче! Лишилася тільки одна дрібна правка, і гра-відгадайка буде завершена. Згадаймо, що програма все ще виводить таємне число. Це було потрібно для тестування, але псує гру. Видалімо <code>println!</code>, який виводить таємне число. Блок коду 2-6 показує остаточний код.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {guess}&quot;);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Блок коду 2-6: Повний код гри відгадайки</span></p>
<p>Отже, ви зуміли вдало зібрати гру відгадайку. Вітаємо!</p>
<h2 id="Підсумок"><a class="header" href="#Підсумок">Підсумок</a></h2>
<p>Цей проєкт був вступом до багатьох концепцій мови Rust через практику: <code>let</code>, <code>match</code>, функції, використання зовнішніх крейтів та інших. У кількох наступних розділах ми детальніше розберемо ці концепції. Розділ 3 розповідає про концепції, які є у більшості мов програмування, такі як змінні, типи даних, функції і показує, як ними користуватися в Rust. Розділ 4 досліджує володіння, концепцію мови Rust, що є найбільш відмінною від інших мов. Розділ 5 обговорює синтаксис структур і методів, а Розділ 6 детально розкриває, як працюють енуми.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch01-03-hello-cargo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch01-03-hello-cargo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch03-00-common-programming-concepts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
